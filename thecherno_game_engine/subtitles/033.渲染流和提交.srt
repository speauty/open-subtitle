1
00:00:00,133 --> 00:00:05,625
嘿，伙计们，我叫TheCherno，欢迎回到游戏引擎系列，所以上次我们看了VertexArrays
hey, what's up guys, my name is TheCherno, welcome back to my game engine series, so last time we took a look at VertexArrays

2
00:00:05,625 --> 00:00:08,475
如果你们还没有看过那期视频，一定要去看看啊
definitely make sure that you check out that video, if you haven't already

3
00:00:08,766 --> 00:00:15,900
而且我们的应用程序几乎已经到了阶段，实际上不需要调用任何类型的原始OpenGL调用
and our kind of Application was almost up to the stage, where we didn't actually need to call any kind of raw OpenGL calls

4
00:00:15,900 --> 00:00:20,507
为了将我们的小矩形和三角形渲染到屏幕上，这非常令人兴奋
in order to render our little rectangle and triangle onto the screen, which was pretty exciting

5
00:00:20,866 --> 00:00:26,725
然而，剩下的最后一件事可能是整个事情中最关键的部分，那就是实际的DrawCall
however the last thing that remained was probably the most critical part of the whole thing, and that is the actual DrawCall

6
00:00:27,075 --> 00:00:32,475
现在什么是DrawCall，简单地说，这只是一个将某些内容实际绘制到屏幕上的调用
now what is a DrawCall, well to put it simply, it's just a call to actually draw something onto the screen

7
00:00:32,675 --> 00:00:34,175
对吧，这是我们的命令
right, it's our command

8
00:00:34,300 --> 00:00:39,925
我们告诉显卡的地方，我给了你一堆信息，你知道，绑定的着色器，我告诉过你要怎么做
where we actually tell the graphics card, I've given you a bunch of information, you know, boud shader, I've told you how to do things

9
00:00:40,225 --> 00:00:45,244
我需要你们实际继续运行具有绑定这种几何的顶点着色器
I need you to actually go ahead and run that vertex shader with this kind of geometry bound

10
00:00:45,600 --> 00:00:51,575
实际上运行这个像素和片段着色器来处理屏幕上每个像素的颜色，我希望你们能做到那点
and actually run this pixel shader this fragment shader to work out the colors of every pixel on the screen, you know, I want you to actually do that

11
00:00:52,466 --> 00:00:59,025
这是实际的draw命令，称为DrawCall，现在在这种情况下，DrawCall就是glDrawElements
it's the actual draw command, right, that is called a DrawCall, now in this case, our DrawCall is glDrawElements

12
00:00:59,400 --> 00:01:04,025
对吧，有很多不同的方式来实际调度绘制命令，但是我们使用的是glDrawElements
right, there's a bunch of different ways to actually dispatch draw commands, but we're using glDrawElements

13
00:01:04,025 --> 00:01:10,725
那就是实际的OpenGL代码，仍然在我们的实际Application中，现在想删掉它
and that's the actual piece of OpenGL code, that is still inside our actual Application, now we want to get rid of that

14
00:01:10,933 --> 00:01:16,025
但是为了实现那个，就像正确地而不是仅仅像破解它一样，我们需要某种渲染器，对吧
but to do that, like properly and not just like hack it in, we need some sort of Renderer, right

15
00:01:16,166 --> 00:01:20,650
实际上，今天，我们要做的是讨论整个渲染架构
and in fact today, what we're going to do is we're going to talk about this entire rendering architecture

16
00:01:20,650 --> 00:01:25,825
我真的很想用图表来正确地讨论这个问题，今天不打算这么做
and I really want to actually discuss this properly with diagrams, not going to do that today

17
00:01:25,825 --> 00:01:30,000
因为我只是要向你们展示一切的实际实现，太长了
because I'm just going to show you guys the practical implementation of everything, far too long

18
00:01:30,100 --> 00:01:35,500
如果我真的要讨论两种理论类型的视频，这段视频可能会长达大约一个小时
the video will probably be about about an hour long, if I was to actually discuss both the theoretical kind of

19
00:01:35,733 --> 00:01:40,175
这将如何运行的，绘制图表，然后也为它编写所有代码，所以这将是它的代码部分
how this is gonna work and draw diagrams, and then also kind of write all the code for it, so this is gonna be the code part of it

20
00:01:40,533 --> 00:01:46,166
你们对渲染器的实际类型感兴趣，特别是渲染器来渲染API来渲染命令
you guys are interested in the actual kind of Renderer, specifically Renderer to RenderAPI to RenderCommand

21
00:01:46,166 --> 00:01:51,325
Hazel的那种架构，在下面发表评论，我可能会制作一期专门的视频来谈论那个
that kind of architecture in Hazel, drop a comment below, I'll probably make a dedicated video just talking about that

22
00:01:51,566 --> 00:01:56,366
可能就像一周中的事情一样，我不会想，只是你们知道，略过主要的只是为了解释这一点
probably like a mid week thing, I'm not gonna like, just you know, take over the main episode just to kind of explain this

23
00:01:56,366 --> 00:02:00,175
我可能想做一个周中事情，只是一个额外的视频，那将在某种程度上补充这点
I wanna maybe make a mid week thing, just an extra video really, that will kind of supplement this

24
00:02:00,175 --> 00:02:03,266
所以在我们继续之前，让我知道你们是否感兴趣
so let me know if that's something that you're interested in, before we continue

25
00:02:03,266 --> 00:02:08,550
只想感谢所有使这个系列成为可能的朋友，patreon.com/TheCherno, 非常感谢所有这些人
just want to thank all the patrons that make this series possible, patreon.com/TheCherno, huge thank you to all of those people

26
00:02:08,550 --> 00:02:13,375
因为没有你们，这个系列就不会在这里，如果你们继续支持这个系列
because the series just wouldn't be here without you guys, if you go ahead and support the series

27
00:02:13,375 --> 00:02:17,400
你们会得到很多好处，比如提前拿到视频，通常提前一周
you'll get a lot of kind of perks, such as getting videos early, like a week early usually

28
00:02:17,400 --> 00:02:22,598
所以当新视频出来时，比如YouTube上的直播，你们可以在patreon上马上看到下一期了
so when a new episode comes out, like live on YouTube, you can already see the next ones right away on patreon

29
00:02:22,600 --> 00:02:27,933
因此，就像你们只是在其他所有人之前醒来，然后还可以访问我已经拥有的私有开发存储库
so it's like just you just wake ahead of everyone else, and then you also get access to the private development repository in which I already have

30
00:02:27,933 --> 00:02:30,675
就像一个完整的渲染器和一堆其他很酷的东西，比如我想我
like a full Renderer and a bunch of other cool things like I think I'm

31
00:02:30,675 --> 00:02:37,025
本周，我在此外观中添加了类似的动画，因此我们具有动画度量，并且添加了材质系统
this week I've added like animation to this look, so that we have like animated measures, and I've added like a material system

32
00:02:37,100 --> 00:02:42,475
这非常令人兴奋，而且我基本上只是在努力，就像我想的一个小爱好项目一样
it's pretty exciting, and it's kind of I'm just working on that basically, just as like a little hobby project I guess

33
00:02:42,475 --> 00:02:46,450
尽我所能，所有这些东西，甚至有一个路线图，就像
just as fast as I can, and all that stuff, and there's even like a road map, like that's like

34
00:02:46,450 --> 00:02:52,900
我已经在该私有github存储库上设置了github项目，就像github项目，目前正处理类似任务
I've set up like a github project on that private github repository, there's like a github project with like tasks I'm currently working on

35
00:02:52,900 --> 00:02:57,725
这有点像一个真正的软件开发团队，所以它真的很酷，一定要去看下，并为该系列提供帮助
it's kind of like a real software development team, so it's really cool, definitely check that out, and helps about the series

36
00:02:57,725 --> 00:03:03,225
因为这就是我们可以免费获得这些视频的方式，这太神奇了，好吧，我们要深入研究这个
because that's how we can have these videos for free, which is amazing, okay, we're gonna dive into this

37
00:03:03,737 --> 00:03:06,933
正如我所说，不要过多谈论架构，你们会通过代码看到它
as I said, not going to talk too much about the architecture, you'll kind of see it through the code

38
00:03:06,933 --> 00:03:11,866
我认为这不是我向你们解释它是如何运行的，并且需要很长时间才能做到那样
I think it's rather than me kind of explaining to you how it works, and taking a long time to do that

39
00:03:11,866 --> 00:03:17,675
我想真正进入并开始实际编写代码，在此之前，我会给你们一些理论知识
I want to just really get in and start actually writing code, before I do that, I will give you some theoretical knowledge though

40
00:03:17,675 --> 00:03:25,900
因为我想教你们，而不是给你们看，不仅仅是你们面前的编写代码，所以需要的是渲染器
because I'm trying to teach you guys, not to show you, not just the write code in front of you, so basically what we need is a a Renderer

41
00:03:25,900 --> 00:03:28,800
那么渲染器是做什么的，对吧，让我们考虑渲染一个三角形
so what does a Renderer do, right, let's think about rendering a triangle

42
00:03:28,800 --> 00:03:30,875
我们实际上需要做什么来渲染一个三角形
what do we actually need to do to render a triangle

43
00:03:31,025 --> 00:03:35,749
对吧，不要只是把它想象成三角形，把它想象成几何体
right, and don't just think of this as a triangle, think of it as some piece of geometry

44
00:03:36,666 --> 00:03:41,450
好吧，让我们在脑海中让世界变得漂亮一秒钟，然后考虑一个立方体
alright, so let's just make the world pretty for a second in our minds, and think about a cube

45
00:03:41,566 --> 00:03:46,850
你们想在3D世界中渲染一个立方体，实际上需要什么，嗯，我能想到一些组件，对吧
you want to render a cube in your 3D world, what do you actually need, well there's a few components that I can think of, right

46
00:03:47,100 --> 00:03:52,100
要实际渲染某些内容，我们知道我们需要VertexArray，它包含VertexBuffer和IndexBuffer
to actually render something, we know that we need the VertexArray, which is something that contains the VertexBuffer and the IndexBuffer

47
00:03:52,200 --> 00:03:56,800
对吧，或者引用这两个，我们需要一个着色器，否则我们不知道怎么做
right, or references to those two, we need a shader, otherwise we have no idea how to do stuff

48
00:03:57,525 --> 00:03:59,500
我认为至少是那样，差不多就是那样
and I think that's at minimum, that's pretty much it

49
00:03:59,975 --> 00:04:04,025
是吧，我的意思是我们需要喜欢每一帧清除屏幕，但这只是我们并不真正关心的细节
right, I mean we need to like clear the screen every frame, but that's kind of just details that we don't really care about

50
00:04:04,650 --> 00:04:11,930
嗯，现在一个立方体和3D世界，我们在哪里与立方体有关，对吧，我们如何看立方体
um now a cube and 3D world well, where are we in relation to the cube, right, how are we looking at the cube

51
00:04:12,733 --> 00:04:14,765
那是一个相机系统，对吧，所以我们需要一个相机
that's a camera system, right, so we need a camera

52
00:04:15,125 --> 00:04:18,525
什么是相机，一个相机用来投影矩阵和视图矩阵，对吧
what is the camera, a camera is used to projection matrix and view matrix, right

53
00:04:18,525 --> 00:04:28,450
这两块信息，我们绝对需要相机的概念，还需要立方体在世界空间中的实际位置，对吧
those 2 pieces of information, we absolutely need in the form of a camera, we also need the actual position of the cube in world space, right

54
00:04:28,450 --> 00:04:33,700
因此，在我们的3D世界中，立方体实际上位于何处，它旋转角度是什么，你们知道如何看它
so where in our 3D world is the cube actually located, what's the house it rotated, you know how does it see it

55
00:04:33,700 --> 00:04:36,884
我们需要立方体的整个变换矩阵，那真的很重要
we need the whole transformation matrix of the cube, that's really important

56
00:04:37,900 --> 00:04:42,388
如果我们谈论的是更完整的渲染器的更高级的细节，我们最终将在这里
if we're talking about more advanced details of a more complete Renderer that we will eventually have here

57
00:04:42,975 --> 00:04:48,125
我们还需要知道立方体有什么表面材料，那么立方体是由什么制成的
we also need to know what surface material the cube has, so what's the cube made out of

58
00:04:48,125 --> 00:04:50,733
它是木制的吗，它是塑料的吗，它有多反光吗
is it wooden, is it plastic, how reflective is it

59
00:04:51,066 --> 00:04:54,875
它是如何纹理的所有这些东西，我们需要知道实际立方体的材料
how is it textured all of that kind of stuff, we need to know the material of the actual cube

60
00:04:55,133 --> 00:05:00,987
我们还需要知道关于环境的信息，对吧，所以我们需要知道环境中有什么灯
we also need to know information about the environment, right, so we need to know what lights are in the environment

61
00:05:00,987 --> 00:05:06,625
是否有一些光，是否有巨大的定向光从某个地方发出，因为我们在外面，那就是阳光
is there some light, is there a huge like directional light coming from somewhere, because we're outside, and that's how sunlight

62
00:05:07,066 --> 00:05:11,400
你们知道，这个世界是什么样子，我们有像环境地图，某种像光线地图
you know what does the world look like, do we have like an environment map, some kind of like radiance map

63
00:05:11,666 --> 00:05:16,566
那基本上只是描述了我们周围的环境，因为那对于像人脸照明这样的事情非常重要
that basically just describes the environment around us, because that's really important for things like image face lighting

64
00:05:16,566 --> 00:05:23,846
我们将来会使用的，对吧，我们需要所有的信息，希望我向你们描述的方式
which we'll be using in the future, right, we need all that information, and hopefully the way that I've kind of described to you

65
00:05:24,300 --> 00:05:29,275
它开始将它分为两个不同的东西，那与环境有关
it starts to separate it to two different things stuff, that's concerned with the environment

66
00:05:29,400 --> 00:05:34,850
与我们所关注的实际对象有关的东西，对吧，这是两种重要的东西
and stuff that's concerned with the actual like object that we're underling, right, those are the two kind of important things

67
00:05:35,475 --> 00:05:39,950
那么环境，那是什么，那是我们的照明环境，那么我们的灯在哪里
so again environment, what is that, that's our lighting environment, so what are where are our lights

68
00:05:40,266 --> 00:05:44,350
你们知道，有没有一堆点灯，它们就像一个大的方向灯，对吧
you know, is there a bunch of point lights, is they're like a big directional light that stuff, right

69
00:05:44,350 --> 00:05:49,875
除了立方体地图，那就是我们的环境，我们需要任何形式的反射，对吧
as well as the cube map, that is our environment, that we need for any kind of reflections, right, to do with that

70
00:05:49,875 --> 00:05:58,800
我们需要它来渲染，就像基于物理的材料，对吧，这两个，然后是相机，我们在哪里看
and we need that for rendering, like physically based materials, right, those two things, and then our camera, where are we looking in, right

71
00:05:58,800 --> 00:06:04,750
那种东西是基于环境的，你们真的可以开始那样区分，因为如果你们想一想
that kind of stuff is based on the environment, and you can really start to differentiated that way, because if you think about it

72
00:06:04,750 --> 00:06:09,850
如果我想渲染两个立方体，对吧，我想渲染一个物体的整个场景
what if I want to render two cubes, right, I want to render a whole scene of objects

73
00:06:09,850 --> 00:06:18,725
我需要什么，我需要为每个对象，比如更新环境地图、灯光设置或相机，不
well what do I need for that, do I need to for each object, like update the environment map or the light setup or the camera, no

74
00:06:18,966 --> 00:06:24,325
我正在从一台相机上查看场景，所有对象都将使用相同的参数来渲染
I'm looking at the scene from one camera, all the objects are going to be rendered with that, same set of parameters

75
00:06:24,733 --> 00:06:31,450
那就是你们如何知道什么属于实际场景，那就是需要做的，当告诉渲染器，开始一个场景
that's how you know what belongs to the actual scene, that is what we need to do, when we tell our Renderer, we want to begin a scene

76
00:06:31,600 --> 00:06:37,350
所以我们会有一个像Renderer::BeginScene()这样的指令，对吧，BeginScene需要所有的信息
so we'll have a commander like Renderer::BeginScene(), right, BeginScene needs all that information

77
00:06:37,566 --> 00:06:42,475
它需要了解环境，需要了解相机，对吧，这些东西需要设置
it needs to know about the environment, it needs to know about the camera, right, that stuff needs to be set up

78
00:06:42,700 --> 00:06:48,525
在这种情况下，环境包括线条，那么我们就有了每个对象的基础，对吧
and the environment includes the lines in this case, then we have the object per object kind of basis, right

79
00:06:48,800 --> 00:06:52,576
所以我想渲染3个立方体，或者我不知道，也许我有一个关卡，我有像墙一样的墙
so I want to render 3 cubes or I don't know, maybe I've got a level, and I've got like walls

80
00:06:52,576 --> 00:06:57,625
我有比如字符之类的东西，对吧，我主要需要的是材料
and I've got like characters all of that stuff, right, the things that I primarily need for that are materials

81
00:06:57,800 --> 00:07:04,504
那么实际对象使用的是什么材料，对吧，我如何用什么材料渲染它，然后第二件事是
so what material is that actual object using, right, how do I render it with what material, and then the second thing is

82
00:07:06,400 --> 00:07:10,125
第二件事是什么，对象的转换，对吧，那么它在世界上的什么地方
what was the second thing, the transformation of the object, right, so where in the world is it

83
00:07:10,700 --> 00:07:15,733
对吧，那才是我们真正需要的两件重要的东西，基于我在这里描述的一切
right, those are the two important things that we actually need, and based on everything I've described here

84
00:07:15,733 --> 00:07:19,050
你们可以渲染一个3D场景，就像没有问题一样，对吧，搞定
you can render a 3D scene, like no problem at all, right, done

85
00:07:19,300 --> 00:07:22,225
对吧，你们需要那种东西来真正实现那个
right, you need that kind of stuff to actually make that happen

86
00:07:22,600 --> 00:07:27,700
所以我们要做的是，我们要你们中精力，我们还没有这些，这只是一点概念，对吧
so what we're gonna do is, we're gonna focus, we don't have any of this yet, this is a little conceptual, right

87
00:07:27,700 --> 00:07:33,700
我们实际上没有相机系统，实际上没有材质系统，我们实际上没有灯光或环境
we don't actually have a camera system, we don't actually have a material system, we don't actually have lighting or environments

88
00:07:33,875 --> 00:07:37,250
对吧，我们将来肯定会有的，但我们现在不会
right, we will in the future definitely, but we don't right now

89
00:07:37,666 --> 00:07:42,150
但是我们仍然会为所有这些东西奠定基础，了解大局很重要
but we're gonna still lay the foundation for all that kind of stuff, and it's important to understand the big picture

90
00:07:42,300 --> 00:07:48,225
因为我不想坐在这里，给你们一些像真正的入门级基础初学者教程，那就像
because I don't want to sit here, and give you some kind of like really entry level basic beginners tutorial, that's just like

91
00:07:48,225 --> 00:07:51,550
哦，你们知道，我们要这样渲染三角形，不，我在看大局
oh you know, we're gonna render triangle this way, no, I'm looking at the big picture

92
00:07:51,550 --> 00:07:56,350
我以前写过游戏引擎，我以前在3A游戏引擎上工作过，对吧，我知道它们是如何运行的
I've written game engines before, I've worked on 3A game engines before, right, I know how they work

93
00:07:56,550 --> 00:08:02,225
这就是我，看看整个事物的整体观点，并奠定这种基础
and this is me, kind of taking a look at the whole holistic view of things, and laying this kind of groundwork

94
00:08:02,225 --> 00:08:06,025
这样你们就明白了，渲染比像，嘿，让我们提交这个东西要复杂一点
so that you understand that, a render is a bit more complicated than just like, hey, let's submit this thing

95
00:08:06,550 --> 00:08:09,675
但另一方面，我试图让它变得足够简单，这样我就可以把整件事挤成一期
but on the other hand, I'm trying to make it simple enough, so that I can squeeze this whole thing into like an episode

96
00:08:10,066 --> 00:08:14,575
也不要让你们太困惑，我实际上很快就能看到这种谷物的结果
and also not confuse you guys too much, I actually see results on this grain pretty quickly

97
00:08:15,800 --> 00:08:20,275
而对象的东西，我们没有特别像变换矩阵，从来没有真正谈论过它们
and the object stuff, we don't particularly have either like transformation matrices, never, really talked about them yet

98
00:08:20,275 --> 00:08:23,533
我们会在未来，但这很重要，你们明白这两者之间的区别
we will in the future, but it's just important, you understand that distinction between

99
00:08:23,533 --> 00:08:26,525
渲染器的一部分和实际对象的一部分，好吗
what's part of the Renderer and what's part of the actual object thing, okay

100
00:08:28,200 --> 00:08:32,775
因此，我们现在要做的实际上是编写这种渲染器，BeginScene和EndScene
so what we're going to go ahead and do right now is actually write that kind of Renderer, BeginScene EndScene

101
00:08:32,866 --> 00:08:36,800
所以这个流程的方式是，我们基本上说，嘿，渲染器，我开始一个场景
so the way that this is going to flow is, we basically say, hey, Renderer, I'm beginning a scene

102
00:08:37,333 --> 00:08:40,225
那是我们提供所有渲染器的地方，所以相机，环境
that's where we supply all the Renderer stuff, so the camera, the environment

103
00:08:41,150 --> 00:08:46,725
然后我们渲染所有网格，我们渲染的每个网格通常将处于不同的变换
then we render all of our meshes, each mesh that we render is going to be at a different transform usually

104
00:08:46,725 --> 00:08:52,950
因此，我们将采用某种转换矩阵，以便最终，显然它将进入着色器
so we'll take in some kind of transformation matrix, so that eventually, obviously that'll make its way to the shader

105
00:08:52,950 --> 00:08:54,800
那就是我们实际上转换某些东西的方式，对吧
and that's how we actually transform something, right

106
00:08:55,575 --> 00:08:58,300
那就是我们所有方法去的地方，最后我们有一个EndScene
that's where all of our methods go, and then finally we have an end scene

107
00:08:58,600 --> 00:09:03,724
对吧，这个场景的信号已经结束了，对吧，然后通常会发生
right, that just kind of signals of this scene is over, right, and then usually what happens is

108
00:09:03,724 --> 00:09:10,500
所有这些东西都不会立即渲染，它只是被提交到渲染中，就像命令队列一样
all of that stuff doesn't get rendered immediately, it just gets submitted into a render, like command queue essentially

109
00:09:10,500 --> 00:09:17,900
所以我们用它创建一个渲染命令，然后提交，对吧，我们只是花时间提交整个场景
so we create a render command out of it, and we submit that, right, and we kind of just take our time to submit the whole scene

110
00:09:17,900 --> 00:09:20,025
无论如何，我最终都解释了这一期的所有内容
I ended up explaining everything in this episode, anyway

111
00:09:20,275 --> 00:09:23,225
但我还是想在专门的视频中进行更深入的介绍
but I would love to do it more in depth anyway in a dedicated video

112
00:09:23,566 --> 00:09:28,600
但关键是，我们花所有时间将所有内容提交到渲染指令队列中，对吧
but the point is, we take all this time to submit everything to a render kind of command queue, right

113
00:09:28,600 --> 00:09:34,575
以后可以在单独的渲染线程上进行计算，对吧，那就是多线程游戏引擎实际上所做的
which again could be later evaluated on a separate render thread, right, that's what a multi threaded game engine actually does

114
00:09:34,575 --> 00:09:40,575
那实际上是我们将来要做的，对吧，但是我们要创建这种指令队列
and that is actually what we're gonna do in the future, right, but we're gonna create this kind of command queue

115
00:09:40,775 --> 00:09:47,640
我们的渲染器必须履行的指令的权利，我们花时间提交所有这些，然后当整个场景提交时
right of commands that our renderer has to fulfill, we take our time to submit all of that, and then when the whole scene has been submitted

116
00:09:47,640 --> 00:09:49,975
我们实际上知道是什么构成了整个场景
and we actually know what makes up the whole scene

117
00:09:50,200 --> 00:09:52,775
只有这样，才能渲染它，为什么，因为你们猜怎么着
only then do we render it, why, because guess what

118
00:09:52,775 --> 00:09:57,300
当你们拥有场景的完整全貌时，你们可以真正对其进行大量优化
when you have the full big picture of your scene, you can really heavily optimize it

119
00:09:57,700 --> 00:10:04,875
你们可以只是卷曲的东西，在视图结霜之外，可以决定哪些材质，哪些对象具有相同的材质
you can just, just curl things, that are outside of the view frosting, you can decide which materials which objects have the same material

120
00:10:04,875 --> 00:10:06,400
这样你们就可以把它们批量绑在一起了
so that you can batch them together

121
00:10:06,766 --> 00:10:11,775
你们可以做非常酷的优化排序所有需要实际完成的事情
you can do really cool kind of optimization sorting all of that kind of stuff that needs to actually be done

122
00:10:11,775 --> 00:10:17,350
你们只能做，一旦有了整个场景，所以不能只是继续和即时模式，只要它一进来就渲染一切
you can only do, once you have the whole scene, so you can't just go ahead and immediate mode, just render everything as soon as it comes in

123
00:10:17,700 --> 00:10:22,775
那就是我们今天要做的，因为那将是最快的方法，但是很快我们就会重构这个东西
that's what we're gonna do today, because that's gonna be the quickest way to do this, but very soon we're gonna restructure this thing

124
00:10:22,775 --> 00:10:27,486
我们要构建这个渲染器，这样它就像一个真正的渲染器一样工作，这将是非常令人兴奋的
and we're gonna kind of build this Renderer, so that it actually works like a real Renderer, and that's gonna be super exciting

125
00:10:27,886 --> 00:10:33,425
无论如何，足够多的讨论，让我们来创建整个渲染器，向你们展示它如何与OpenGL交互
anyway, enough talking, let's jump in and create this whole Renderer thing, and I'm going to show you how it interacts with OpenGL

126
00:10:33,733 --> 00:10:38,350
因为显然我们需要实际调度该DrawCall，并且该DrawCall是glDrawElements
because obviously we need to actually dispatch that DrawCall, and that DrawCall is glDrawElements

127
00:10:38,350 --> 00:10:39,900
这当然是特定于OpenGL的
which of course is OpenGL specific

128
00:10:40,266 --> 00:10:44,620
在DirectX中，你们知道，我们就像调用上下文或驱动程序一样，然后像DrawIndexed一样
in DirectX, you know, we'd be like calling the context or the driver whatever, then be like DrawIndexed

129
00:10:45,400 --> 00:10:49,350
然后那就是自己的事情，这是DirectX中的等效DrawElements
and then that would be doing its own thing, that's the equivalent DrawElements in DirectX

130
00:10:49,650 --> 00:10:51,466
但是在这里，我们只处理DrawElements
but here, we're just dealing with DrawElements

131
00:10:51,466 --> 00:10:56,133
让我们继续创建整个渲染器，是的，我的意思是这是大事情的开始，所以这真的很酷
let's go ahead and create this whole renderer thing, and yeah I mean this is the beginning of something big, so that's really cool

132
00:10:56,133 --> 00:11:01,166
让我们直接进入代码，好吧，这是我们上次有的，重要的是我们有这个
let's go ahead and jump into the code, okay, so this is what we had last time, it's important that we have this

133
00:11:01,166 --> 00:11:06,225
因为这是我们的参考，它应该看起来完全一样，对吧，所以我们现在需要做的是
because this is our reference, it should look exactly the same, right, so what we need to do now is

134
00:11:06,225 --> 00:11:10,575
进入Application，想想接口，这是我首先喜欢做的，对吧
go into Application, and just think about the api, that's what I like to do first of all, right

135
00:11:10,925 --> 00:11:12,799
所以我们有这个ClearColor，并且设置了它
so we have this ClearColor and we set it

136
00:11:12,800 --> 00:11:20,125
然后我们清除缓冲区，我们绑定了这种东西，然后有了真正的DrawCall，现在我要做的是
and then we clear our buffer, which is great, we bind this kind of stuff, and then we have our actual DrawCall, now what I'm going to do is

137
00:11:20,400 --> 00:11:27,366
一开始，我们真正要做的是调用Render::BeginScene，就像我说的那样，实际上就像调度
at the beginning, what we're really going to do is call Render::BeginScene as I said, right, and this is going to actually like dispatch that

138
00:11:27,366 --> 00:11:31,775
它将开始那个场景，它将包含关于场景的所有信息，对吧
it's going to start that scene, that's going to contain all of the information about the scene, right

139
00:11:31,775 --> 00:11:37,299
所以基本上我们在这里处理的是一个相机，你们知道，灯光，然后是环境，你们可能会争论
so essentially what we're dealing with here is a camera, you know, lights, and then environment, and you could probably argue

140
00:11:37,300 --> 00:11:41,650
环境实际上是，或者灯光实际上是实际环境的一部分，对吧
the environment is actually, or lights are actually part of the actually environment, right

141
00:11:41,650 --> 00:11:48,399
但那基本上是场景所需要的，在将来，我们可能只有一个结构，这基本上就像SceneSettings
but that's essentially what a scene needs to have, and in the future, we might just have a struct, that is essentially like our SceneSettings

142
00:11:48,400 --> 00:11:50,620
或者我们的SceneSetup，或者任何你们想称之为的东西，对吧
or our SceneSetup or whatever you want to call it, right

143
00:11:50,620 --> 00:11:54,725
但是现在，我们没有这些，我想也许在下一期
but for now, we don't have any of this, I think maybe in the next episode

144
00:11:54,725 --> 00:11:58,421
或者我们可能会谈论相机，因为那将是最重要的事情之一
or so we're gonna probably talk about cameras, because that's gonna be one of the most important things

145
00:11:58,533 --> 00:12:01,075
我们也不可能开始3D场景
and there's also no way that we can begin a 3D scene

146
00:12:01,975 --> 00:12:08,799
构建3D场景，而无需实际设置我们可以像鼠标一样控制的相机，因此很快就会发生
building a 3D scene without actually having a camera set up that we can control with like the mouse, so that's going to happen soon

147
00:12:09,300 --> 00:12:15,299
还有个EndScene，对吧，这个场景的哪个序列是，就那样，我们做的和这个场景相似，对吧
we'll have an EndScene, right, which sequence of this scene is kind of, that's it, that's the end, we're done similar to this scene, right

148
00:12:16,466 --> 00:12:22,325
然后在中间是我们提交几何的地方，对吧，所以我们可以有一个叫做Submit的方法，对吧
and then in the middle is where we kind of submit our geometry, right, so we could have something that's called Submit, right

149
00:12:22,532 --> 00:12:25,700
然后我们可以只提交一个网格，你们可以叫这个函数SubmitMesh
and then we can maybe just submit a mesh, you can call this function SubmitMesh

150
00:12:25,700 --> 00:12:28,550
你们可以叫它SubmitGeo或SubmitGeometry，对吧
you can call it SubmitGeo or SubmitGeometry, right

151
00:12:28,550 --> 00:12:32,525
你们可以随便叫它，我只想让它很简单，就叫它Submit
you can call it whatever you want, I'm just gonna leave it really simple, and just call it as Submit

152
00:12:32,825 --> 00:12:38,500
我之所以可以将其保留为Submit，是因为我的意思是显然我们正在使用CPP，有重载功能
the reason I can just leave it as Submit is because, I mean obviously we're dealing with CPP, we have overload functions

153
00:12:38,800 --> 00:12:44,175
所以根据我们实际提交的类型，我们应该能够很容易地辨别，如果这是一个网格
so based on the type that we actually submit, we should be able to easily discern, if this is like a mesh

154
00:12:44,400 --> 00:12:49,700
或者，如果是在这种情况下，我们将提交一个原始VertexArray，但那就是它的原理，对吧
or if it's in this case, we're just going to submit a raw VertexArray, but that's kind of how that works, right

155
00:12:49,900 --> 00:12:54,624
然后通常会发生的当然是，这种着色器的东西，与此相关，对吧
and then usually what will happen of course is, this kind of shader stuff, that's associated with this, right

156
00:12:54,624 --> 00:13:00,944
那将在一个材质里面，材质就像，一个网格会有一个材质，对吧，我们也没有网格
that will be inside a material, and the material will be like a mesh, will have a material, right, we don't have meshes yet either

157
00:13:01,166 --> 00:13:04,899
但是当我们这样做的时候，它们会有材质，对吧，所以当我们提交这个的时候
but when we do, they'll have materials, right, so when we kind of submit this, that's kind of

158
00:13:04,900 --> 00:13:10,030
这个着色器在网格内部，在内部，在材质内部，在网格内部，对吧
this shader is inside the mesh,  that's inside, it's inside the material, it's inside the mesh, right

159
00:13:11,066 --> 00:13:14,500
所以那就是我们如何在更完整的渲染器中访问它的方式
so that's how we kind of get access to it in a more complete kind of Renderer

160
00:13:15,125 --> 00:13:18,825
好了，最后，通常我们要做的是，在某个时候，我们刷新渲染器
okay, and then finally, usually what we do is, at some point, we flush the Renderer

161
00:13:18,825 --> 00:13:20,800
现在通常这是在一个单独的线程上完成的
now usually this is done on a separate thread

162
00:13:20,800 --> 00:13:26,300
如果你们正在谈论多线程游戏引擎设计，但是你们现在知道我们显然没有
if you're talking about a multi threaded game engine design, but you know for now obviously we're we don't have any of that

163
00:13:26,700 --> 00:13:29,500
我们甚至没有真正的渲染命令队列，我们稍后再谈
we don't even have a real render command queue, and we'll talk about that later

164
00:13:29,500 --> 00:13:34,699
因为同样，我们需要将所有内容基本上提交到缓冲区中，然后可以在其他线程上执行
because again, we need to submit everything into basically a buffer, that can then be executed on a different thread

165
00:13:34,700 --> 00:13:41,075
所以我们稍后再谈，这也将是我们未来做的一件大事，好吧，酷，就那用
so we'll talk about that later, that's going to be a huge thing that we do in the future as well, okay, cool, so that's it

166
00:13:41,075 --> 00:13:46,650
所以很明显，我想提交的是m_SquareVA，我现在仍然需要绑定我的着色器
so obviously the thing that I want to submit is m_SquareVA, and I still need to bind my shader right now

167
00:13:46,650 --> 00:13:53,666
因为那实际上还没完成，所以我要做的是，开始场景，绑定着色器，然后渲染VertexArray
because that's not actually done yet, so what I do is, I begin my scene, I bind my shader, and then I render my VertexArray

168
00:13:53,666 --> 00:13:59,375
然后我将为此做同样的事情，所以我将绑定第二个着色器，对吧
and then I'm going to do the same thing for this, so I'm going to bind this second shader, right

169
00:14:00,400 --> 00:14:07,567
然后我将渲染第二个VertexArray，因此复制Submit，这次我将提交这个VertexArray
and then I'm going to render this second VertexArray, so I'll copy this submit call, and this time I'll submit this VertexArray

170
00:14:07,700 --> 00:14:13,533
应该就是那样，现在就这种ClearColor而言，这应该会放在其他地方
and that should be it, now in terms of this kind of stuff this ClearColor, this is going to leave somewhere else

171
00:14:13,533 --> 00:14:20,333
所以Renderer是高级类，对吧，Renderer是一个实际的，就像它是一个完整的渲染器，对吧
so the Renderer is the high level class, right, a Renderer is an actual like it's a it's a full on Renderer, right

172
00:14:20,333 --> 00:14:23,933
它不处理任何事情，例如哦，清屏，应该在下面，对吧
it doesn't deal with things, like oh that's clear the screen, that's beneath it, right

173
00:14:23,933 --> 00:14:30,800
它处理诸如场景和网格以及高级const构造之类的东西，因此我们在这里需要做的实际上是
it deals with things like scenes and meshes and high level const constructs, so what we need to do for here is actually

174
00:14:30,800 --> 00:14:35,375
取决于你们想如何想这个东西，显然术语是不同的，我喜欢叫它RenderCommand
well depends how you want to wear this stuff, obviously terminology is different, I like calling it RenderCommands

175
00:14:35,675 --> 00:14:36,825
所以就是RenderCommand::Clear()
so RenderCommand::Clear()

176
00:14:37,100 --> 00:14:42,950
对吧，然后对于ClearColor，我们将执行RenderCommand，例如SetClearColor，对吧
right, and then for the ClearColor, we'll do RenderCommand, you know, a SetClearColor for example, right

177
00:14:42,950 --> 00:14:47,625
同样，你们可以随心所欲地构建它，对吧
again you could construct this however you like, right

178
00:14:47,625 --> 00:14:51,333
所以你们实际上可以做的是，看到，我想用特定的颜色清除
so what you could actually do is, see that, I want to clear with a specific color

179
00:14:51,333 --> 00:14:55,075
然后把它放在这里，我们就像这样设置清除颜色
and then just pump that in here, we're just going to set the clear color like that

180
00:14:55,566 --> 00:15:00,475
设置清除颜色不是什么事情，通常这样做，无论如何，通常并不真正关心清除颜色是什么
setting the clear color is not something, that's done that often, anyway, usually you're not really care what color you clear to

181
00:15:00,733 --> 00:15:04,566
因为你们将在ClearColor之上渲染所有内容，所以你们永远都不会真正看到ClearColor
because you'll be rendering everything on top of the ClearColor, you should never really see the ClearColor

182
00:15:04,566 --> 00:15:08,766
事实上，我可能会争辩说，一个好的清除颜色会像洋红色，嗯，一些真正令人反感的东西
in fact I'd probably argue that a good ClearColor would be like magenta, well something really offensive

183
00:15:08,766 --> 00:15:13,486
所以你们知道，哦，我的天哪，就像我把我的几何图形渲染成永远不应该出现的清除颜色
so that you know that, oh my gosh, like I'm rendering past my geometry into the ClearColor that should never happen

184
00:15:13,766 --> 00:15:19,625
因为无论如何，如果你们有一个大的3D场景，那么你们应该总是像某种skybox或环境一样
cause you should always have like some kind of skybox or environment mount, anyway, if you have a big 3D scene, alright

185
00:15:20,566 --> 00:15:26,470
就那样，对吧，这取代了我们这里所有的代码，对吧，现在让我们来谈谈实现它
that's it, right, this replaces all of the code that we have here, right, so now let's talk about implementing it

186
00:15:26,800 --> 00:15:31,799
所以我们已经有一个Renderer，我们有一个Renderer接口，但这将得到稍微重构
so we already have a Renderer, and we have a Renderer api, but this is going to get slightly restructured

187
00:15:31,800 --> 00:15:33,725
我们实际上创建了一个Renderer接口类
we actually create a Renderer api class

188
00:15:33,725 --> 00:15:39,133
现在你们可以称之为RenderAPI，这是一个巨大的类似思想流派
now this you could call this RenderAPI, it's a huge like school of thought here

189
00:15:39,133 --> 00:15:42,175
我的意思是，它可能像RenderAPI或RenderAPI
I mean, it could be like RendererAPI or RenderAPI

190
00:15:42,393 --> 00:15:45,000
通常我看起来很多人称之为RenderAPI，只是因为它更容易
usually I look a lot of people call it RenderAPI, just because it's easier

191
00:15:45,000 --> 00:15:49,300
但是我实际上喜欢将其称为RendererAPI，因为它不像什么是RenderAPI，对吧
but I like to actually call it RendererAPI, because it's not like what of what is RenderAPI, right

192
00:15:49,600 --> 00:15:50,975
这就是Renderer的接口
this is the API for the Renderer

193
00:15:51,466 --> 00:15:56,312
这是一件不同的事情，所以我想要更具体一些，并仔细考虑我的命名
it's a bit of a different thing, so I like to be a bit more specific I guess, and deliberate with my naming

194
00:15:56,800 --> 00:16:05,000
所以RendererAPI将是一个类，这将再次实现，这将是一个接口，它将是
so RendererAPI is going to be a class, that is going to be again implemented depending, it's gonna be an interface, it's gonna be

195
00:16:05,333 --> 00:16:10,375
它将在每个平台上有一个实现，对吧，就像物理渲染接口一样
it's gonna have an implementation per platform, right, per actual like physical like rendering api

196
00:16:10,375 --> 00:16:12,825
对吧，所以我们将有一个用于OpenGL，一个用于DirectX
right, so we'll have one for OpenGL, one for DirectX

197
00:16:13,750 --> 00:16:17,000
现在我们实际上需要在这里拥有的是实际的接口，对吧
now what we actually need to have in here is the actual api, right

198
00:16:17,333 --> 00:16:23,266
所以我们当前存储的实际接口类型，我不知道渲染器文件从哪里消失
so the actual api type we're currently storing inside, and I don't know where that renderer file disappear to

199
00:16:23,266 --> 00:16:29,399
让我们把它移到这里，这种东西，对吧，所以需要这个枚举类，就叫它API
let's move it here, this kind of stuff, right, so we need to have this enum class, I'm just going to call this API

200
00:16:29,400 --> 00:16:36,366
这将是API正在使用的，所以None或OpenGL，在这，我将在这里做另一个小的公共分隔符
and this is going to be what API was using, so none or OpenGL at this, right, right, I'll make another little public divider here

201
00:16:36,366 --> 00:16:41,075
只是因为我喜欢在顶部有类型，然后所有的公共方法，然后像你们所知道的所有
just because I like to have types at the top, then all the public functions, then like all the you you know

202
00:16:41,333 --> 00:16:48,999
私有方法，然后私有成员，无论如何，我们这里有这个API类型
private like methods and then after that the private members, anyway, we have this api type up here

203
00:16:49,266 --> 00:16:58,850
这将再次成为一个接口，对吧，所以virtual void Clear() = 0，对吧
this is again going to be something that's going to be just an interface, right, so virtual void Clear() right equals 0, right

204
00:16:59,200 --> 00:17:02,875
再说一次，我们可以像const和非const一样处理，我认为这没有必要
and again we could deal with like const and non-const, I didn't think that's necessary

205
00:17:02,875 --> 00:17:08,025
没关系，这永远不会有常量，任何东西都是RendererAPI，它只是一些命令
doesn't really matter, this is never gonna have const anything is a RendererAPI, it's just a series of commands

206
00:17:08,400 --> 00:17:11,166
这并不重要，尤其是对于OpenGL，因为它没有状态
it doesn't really matter, especially with OpenGL, because it doesn't have states

207
00:17:11,166 --> 00:17:18,318
我不会用这些东西来装饰名字，就目前而言，virtual void SetClearColor()
I'm not gonna bother kind of decorating names with that stuff, just for now at all, virtual void SetClearColor()

208
00:17:19,733 --> 00:17:28,558
我们有一个不错的数学库，不妨使用它，所以我将包含glm，所以就是const glm::vec4
we have a nice math library, we might as well use it, so I'll include glm, and I'm going to just use const glm::vec4

209
00:17:30,500 --> 00:17:35,350
因为我们将来可能会定义这样的颜色，所以无论如何，那么就是那样了
because we'll probably end up defining colors like that in the future, anyway, so that's gonna be there

210
00:17:35,766 --> 00:17:43,466
最后需要实际的DrawCall，virtual void DrawIndexd，我就叫它DrawIndexd吧
and then finally we need our actual DrawCall, so virtual void DrawIndexd, I'm gonna call it the same ways DrawIndexd calls it

211
00:17:43,466 --> 00:17:47,333
因为元素，我不知道，DrawElements很棒，但是我们再次将其称为IndexBuffer
because elements, I don't know, DrawElements is great, but again we're calling it an IndexBuffer

212
00:17:47,333 --> 00:17:55,225
因此，我们不妨将其称为DrawIndexd，现在会接收一个常量共享指针，绝对不错
so we might as well call this DrawIndexd, and again for now this is gonna take in a const shared pointer, definitely not bad

213
00:17:56,800 --> 00:18:00,733
也就是我们的VertexArray，好吧，现在我们以引用形式传入
there's gonna be our VertexArray, all right, now we're taking this by reference

214
00:18:00,733 --> 00:18:06,533
只是因为我们不需要像实际上一样以这种速度增加转速计数，所以就是vertexArray
just because we don't need to increment the Rev count at this rate like at all really, vertexArray

215
00:18:06,533 --> 00:18:10,866
因为当我真正拥有所有权的时候，只是在读取它，如果真的想的话，可以把它做成个弱指针
because when I'm actually taking ownership, we're just reading it, we could make this like a weak pointer, if you really wanted to, but

216
00:18:10,866 --> 00:18:17,600
但那是不必要的，我们就这样写吧，然后我们就包含VertexArray，好了
and that's just needless, we'll just leave it as that, and then we'll just include VertexArray, okay

217
00:18:18,733 --> 00:18:25,058
那显然也等于0，好了，所以那就是我们的RendererAPI，现在我们真正需要的是这些东西
and that's gonna obviously be equal 0 as well, okay, so that's our kind of RendererAPI, now what we actually need is this stuff

218
00:18:25,533 --> 00:18:36,266
所以需要个私有静态API s_API，对吧，这将是我们的静态，那么当前启用的API是什么
so we need to have a private static API s_API, right, this is gonna be our static, well what API is actually active at the moment

219
00:18:36,366 --> 00:18:45,100
然后我们将有一个inline API GetAPI()，对吧，那将返回s_API，当然是静态的
and then we're gonna have an inline API GetAPI(), right, and that's just going to return s_API, and that's going to be static of course

220
00:18:46,275 --> 00:18:51,200
所以必须创建个cpp文件，这样我们就可以包含这个API定义
so we'll have to make a cpp file, so we can contain this API definition

221
00:18:51,550 --> 00:18:56,942
那么就是RendererAPI.cpp，然后包含pch
so we'll call this RendererAPI.cpp, we'll include our pch

222
00:18:57,500 --> 00:19:14,500
包含RendererAPI.h，namespace Hazel，然后我将复制它，等于RendererAPI::API::OpenGL
we'll include the actual render, RendererAPI.h, namespace Hazel, and then I'm just gonna copy that, equals RendererAPI::API::OpenGL

223
00:19:14,500 --> 00:19:18,550
因为那正是我们在使用的那个，然后我们就把这个命名空间粘贴在任何地方
because that's the one we're using, and then we'll just stick this namespace everywhere

224
00:19:19,566 --> 00:19:22,250
好了，酷，就这样，那实际上是我们需要的
okay, cool, so that's it, that's actually all we need here

225
00:19:22,500 --> 00:19:27,533
那就是选择的RendererAPI，显然我们需要一个实际的api
that's RendererAPI that's selected, obviously we need to have an actual api

226
00:19:27,533 --> 00:19:30,366
对吧，但那将是一些东西，实际上将存储在我们的Renderer中
right, but that's going to be something, that's actually going to be stored in our Renderer

227
00:19:30,366 --> 00:19:33,900
当它想要将命令分派到RendererAPI时，具体地说，那可能是
when it wants to dispatch commands to the RendererAPI, and specifically that's probably going to be

228
00:19:34,200 --> 00:19:42,333
在我们实际需要的RenderCommand类中，现在不确定是否应该在与Renderer相同类中创建
inside the RenderCommand class that we actually need, now I'm not sure if we should create this in the same class as the Renderer

229
00:19:42,333 --> 00:19:47,025
我会说不，只是因为它会变得很大，所以我要做的是创建一个头文件
I would say no, just because it's gonna get pretty big, so what I'll do is I'll create a header file

230
00:19:48,900 --> 00:19:58,150
那就是RenderCommand.h，对吧，并且RenderCommand.h就是我们实际的原始渲染指令
that's going to be RenderCommand.h, right, and RenderCommand.h is going to be our actual raw render commands

231
00:19:58,650 --> 00:20:06,646
所以渲染指令会在这里调用这个接口，实际上，让我们删除这个，还有这个
so render commands are going to call into this api, and actually in, let's delete this for one and also this

232
00:20:07,266 --> 00:20:14,326
顺便说一句，我们仍然可以有GetAPI，我想包含RenderCommand，它将包含RenderAPI
we can still have GetAPI by the way, I'll just include, I think RenderCommand, which will include RenderAPI

233
00:20:16,866 --> 00:20:23,253
我们仍然会有这些命令，对吧，抱歉，仍然会有这个GetAPI函数，只是因为它对我们有用
we'll still have these commands, right, sorry, we'll still have this GetAPI function, just because it's useful to us

234
00:20:23,253 --> 00:20:29,750
渲染器使用的是什么API，但有点不同，它将是一个RendererAPI::API，然后是GetAPI
the renderer what api it's using, but this will be a bit different, it'll be a RendererAPI::API yet and then GetAPI

235
00:20:29,750 --> 00:20:37,542
我们只会返回这里的s_RendererAPI，这是不同的，不是吗，这种在某种程度上变得一样
we'll just return this RendererAPI that we have here, this is different, isn't it, this kind of becomes the same in a way

236
00:20:38,175 --> 00:20:46,822
因为Renderer可以访问RenderCommand，所以最后就是RendererAPI::GetAPI()，对吧
because the Renderer will have access to actual render commands,  so it'll just end up being a RendererAPI::GetAPI() like that, right

237
00:20:47,733 --> 00:20:53,066
这当然不会被存储，所以我们仍然会有它，只是因为我们仍然需要知道API
and this of course will not get stored, so we'll still have that there, just because we still need to be aware of the API

238
00:20:53,066 --> 00:20:59,100
然后，我们将不得不进入所有的接口并修复它，应该非常容易，实际上所做的只是添加那个
and then we'll have to go into all of our apis and actually fix that, should be pretty easy, really all we're doing is just adding that

239
00:20:59,933 --> 00:21:08,475
所以如果我复制它并粘贴到任何地方，我想，我们也需要为VertexArray这样做，好了，搞定
so if I copy that and paste it everywhere, and I think, we also need to do it for our VertexArray, okay, done

240
00:21:08,475 --> 00:21:13,750
那是我们唯一要做的改变，把它扔回去，好吧，酷，所以回到Renderer
and that's the only change we have to make, just throw it back to that, okay, cool, so back in the Renderer

241
00:21:16,400 --> 00:21:20,766
我们将拥有我们所有的实际函数，对吧，我会在设置RenderCommand之前设置这些函数
we're gonna have all of our actual functions, right, and I'll set these up before I set up the RenderCommander

242
00:21:20,766 --> 00:21:30,222
所以你们知道它的原理，我想，所以static void BeginScene()，对吧，我们将接受我们所有的
so that you kind of know how it works, I guess, so static void BeginScene(), and again to do, right, we'll take in all of our kind of

243
00:21:31,466 --> 00:21:34,325
就像我们需要的场景参数一样，但是现在什么都没有
like scene parameters that we need, but for now we'll have nothing

244
00:21:34,625 --> 00:21:38,175
然后就是static void EndScene()，对吧，我把它们放在一起
all our static void EndScene(), right, I'll put them close together

245
00:21:39,666 --> 00:21:46,623
然后我们需要我们的实际提交，对吧，当有了提交后，我们可能会有
and then we need our actual submission, right, and again after we have submission, we'll probably have

246
00:21:47,533 --> 00:21:52,762
我将接受一个const std::shared_ptr<VertexArray>&，就像在RendererAPI中一样
and I'll take in a constant shared pointer, it's our VertexArray, just like in the RendererAPI

247
00:21:55,650 --> 00:21:58,400
这个就是我们的vertexArray，好了
and this will be our vertexArray okay

248
00:21:59,733 --> 00:22:02,766
那很简单，在这种情况下，你们可以做的是
that's pretty straightforward, in this case, what you could do is

249
00:22:02,766 --> 00:22:09,299
立即将它分发到你们实际拥有的实际渲染命令，但是你们知道，我的意思是，我不会那样做
just immediately dispatch it to the actual render command that you actually have, but you know, I mean, I'm not going to do that

250
00:22:09,300 --> 00:22:14,775
因为这必须是以后的适当实现，对吧，但是如果我们看看这个函数要做什么
because this has to be a proper implementation for the future, right, but if we look at what this function is going to do

251
00:22:15,400 --> 00:22:18,325
我实际上要做的是，我要确保，来到这个cpp文件
and what I'll do actually is, I'll make sure we've goto cpp file

252
00:22:18,325 --> 00:22:22,775
我将删除这个旧代码，我将在这里使用视觉辅助
I'll delete this old code, I'll just use visual assist here

253
00:22:23,200 --> 00:22:28,200
只需为我们的函数创建所有实现，搞定，BeginScene现在什么都不做
just create all of the implementations for our functions, done, BeginScene's going to do nothing for now

254
00:22:28,200 --> 00:22:33,533
Endscene后面也不会做什么，正如我所说，BeginScene使用所有相同的参数，它会做什么
Endscene's going to do nothing in the future, as I said, BeginScene takes all about same parameters, what does it inter do

255
00:22:33,533 --> 00:22:40,350
它需要确保我们使用的着色器基本上得到正确的统一变量，而这些统一变量将成为
it needs to make sure that the shaders that we're using basically get the right uniforms, and those uniforms are going to be things

256
00:22:40,350 --> 00:22:46,925
就像使用的是哪个环境映射，那么从哪个立体数据映射中采样，就像相机一样，有点细节
like which environment map we're using, so which cube map sample from, it's going to be like the camera, kind of details

257
00:22:46,925 --> 00:22:50,700
像投影矩阵和视图矩阵一样，相机在wallspace中
like the projection matrix and the view matrix, where the camera is in wallspace

258
00:22:50,700 --> 00:22:56,099
我们可能需要对灯光之类的进行任何计算，对吧，这样就可以设置这些东西，BeginScene
any calculations we might need for lighting and stuff like that, right, so that stuff is going to be set up and BeginScene

259
00:22:56,100 --> 00:23:02,900
最终可能存储在当前场景中，以便在渲染某些内容时，它可以将这些内容提交到着色器中
and eventually probably stored in the current scene, so that when you render something, it can submit that kind of stuff into the shader

260
00:23:02,900 --> 00:23:05,600
你们可以上传那个数据作为着色器统一变量，对吧
you can upload that data as shader uniforms, right

261
00:23:06,375 --> 00:23:08,533
所以那就是它以后要做的，对吧，现在它不认为
so that's what it's gonna do in the future, right, now it does not think

262
00:23:08,533 --> 00:23:13,509
因为我们没有那些，所以Submit是我们唯一要实现的，在这种情况下，做了什么，非常简单
because we don't have any of that, submit is the only thing that we do, and what does it do in this case really simple

263
00:23:13,800 --> 00:23:20,025
它只是说RenderCommand，好吧，它实际上要做的是，把它提交到一个立方体中，对吧
it just says RenderCommand, well again, it's, what it's actually gonna do, right, is, it's gonna submit it into a cube, right

264
00:23:20,025 --> 00:23:25,825
智能是渲染命令队列，然后最终该渲染命令队列可能会在不同的线程上进行计算
intellect is render command queue, and then eventually that render command queue is going to get evaluated probably on a different thread

265
00:23:26,200 --> 00:23:30,750
它会被渲染，对吧，但是现在，我们再次做这个非常简单的方法，对吧
and it will get rendered, right, but for now, again we're doing this really easy way, right

266
00:23:31,100 --> 00:23:38,414
我们只是说RenderCommand::DrawIndexed()，对吧，它只是接收那个vertexArray，好了
we're just saying RenderCommand::DrawIndexed(), right, and it's just going to take in that VertexArray, okay

267
00:23:39,600 --> 00:23:44,900
所以RenderCommand::DrawIndexed() 不存在，因为RenderCommand类甚至不存在，但它将
so RenderCommand::DrawIndexed() doesn't exist, because the RenderCommand class doesn't even exist, yeah but it's going to

268
00:23:45,366 --> 00:23:49,799
现在RenderCommand，这就是有趣的地方，RenderCommand中会发生什么
now RenderCommand, this is where it's interesting, what's going to happen in RenderCommand is

269
00:23:49,800 --> 00:23:57,475
它将有一个RendererAPI&，对吧，s_RendererAPI，对吧
it's going to have a RendererAPI pointer, right, s_API, RendererAPI pointer, right

270
00:23:57,800 --> 00:24:00,075
这个RenderCommand将是非常简单的，对吧
and this RenderCommand is gonna be real simple, right

271
00:24:00,200 --> 00:24:07,175
这将是，几乎就像实际实现的静态包裹类，所以在这种情况下，RenderCommand要做的是
this is gonna be, this is almost like a static wrapper for the actual implementation, so in this case, what RenderCommand is gonna do is

272
00:24:07,400 --> 00:24:15,000
同样，我们有个叫DrawIndexed的指令，接收const std::shared_ptr<VertexArray>&
again we have a command called DrawIndexed, which takes in a const shared pointer of VertexArray

273
00:24:15,150 --> 00:24:16,275
对吧，所以把它放在这里
right, so we'll put that in here

274
00:24:16,533 --> 00:24:19,050
我们甚至可以使它内联，因为是个太简单的函数
we can even make it inline, because it's a real simple function

275
00:24:19,300 --> 00:24:24,225
也就是s_RendererAPI->DrawIndexed(vertexArray)
and it's just going to say s_RendererAPI->DrawIndexed(), and in this case vertexArray

276
00:24:24,545 --> 00:24:28,200
基本上就是那样，对吧，它只是个小的内联函数，再说一次，它是内联
that's basically what it is, right, it's just a little inline, again, it's inline

277
00:24:28,200 --> 00:24:33,400
所以它不应该是个扩展函数调用之类的，对吧，即使我们没有内联标记它，我相信编译器会
so it shouldn't be an extra function call or anything like that, right, and even if we didn't mark it inline, I'm sure the compiler would

278
00:24:33,700 --> 00:24:38,548
如果你们编译并发布具有优化的版本，并且已打开足够的优化，对吧
if you compile and release mud with optimizations, with sufficient optimizations turned on, right

279
00:24:39,133 --> 00:24:43,092
然后让我们编写那样的代码，真的很酷，对吧
and then that just let's us write code such as that, which is really like cool, right

280
00:24:43,092 --> 00:24:50,550
只要确保我们显然把它变成一个static void，必须是静态的，我们实际上必须实现这个
and just make sure that we obviously make this a static void, and this has to be static, and we actually have to implement this

281
00:24:50,733 --> 00:25:03,625
因此，我们将创建一个RenderCommand.cpp文件，其中包含pch和RenderCommand.h
so we'll create a RenderCommand.cpp file, which will include our pch of course and our RenderCommand.h

282
00:25:04,766 --> 00:25:10,450
然后我们将把它设置为，我们必须马上创建一个OpenGL的
and then we're just going to set this to be, and we have to create the OpenGL one in a minute

283
00:25:10,450 --> 00:25:18,675
当然，因为这将是我们的实际代码，但这就是new OpenGLRendererAPI，对吧
of course because that's going to be our actual code, but this is going to be new OpenGLRendererAPI, right

284
00:25:19,300 --> 00:25:29,250
当然，这需要包含Hazel/Platform，我实际上不记得了
and this will of course include that, which is going to be in Hazel/Platform, and I actually can't remember

285
00:25:29,566 --> 00:25:35,166
如果Platform在Hazel里面，所以我永远不能，不是，好吧，所以它将是包含Platform
if Platform is inside Hazel, so I never can, it's not, okay, so it's gonna be an include Platform yeah

286
00:25:35,166 --> 00:25:41,750
它不应该是，因为它不是接口的一部分，也就是Platform/OpenGL/OpenGLRendererAPI
it shouldn't be, because it's not part of the api, Platform/OpenGL and OpenGLRendererAPI

287
00:25:41,966 --> 00:25:49,742
那就是我们原始的OpenGL调用的位置，所以现在在Platform/OpenGL中，创建那个文件
that's where our raw kind of OpenGL calls are really gonna go, so right now inside Platform/OpenGL, I'm gonna make that file

288
00:25:50,966 --> 00:26:02,150
所以我要右击这里转到一个新项目，我们会有一个头文件，也就是OpenGLRendererAPI
so I'm going to right click here go a new item, we're going to have a header file, it's going to be called OpenGLRendererAPI

289
00:26:02,150 --> 00:26:11,600
然后我们还将创建一个cpp文件，这将是一个cpp文件，包含pch，创建了这么多文件
and then we're also going to make a cpp file, that's going to be a cpp file, will include our pch, we're creating so many files

290
00:26:11,600 --> 00:26:27,968
但你们应该明白了，这不太烦人，包含Renderer，抱歉，Hazel/Renderer/RendereAPI.h
but you guys kind of get the idea, no clue, this isn't too annoying, we'll include you know Renderer, sorry, Hazel/Renderer/RendererAPI.h

291
00:26:28,525 --> 00:26:47,834
对吧，namespace Hazel，然后就是class OpenGLRendererAPI，是个RendererAPI，对吧
right, namespace Hazel, and then we'll have our class, OpenGLRendererAPI, which will be a RendererAPI, right

292
00:26:48,175 --> 00:26:53,533
然后这就非常简单了，我们将选中所有这些并实现它，对吧，简单
and then this is gonna be really simple, we're just gonna grab all of this stuff and implement it, right, easy

293
00:26:53,933 --> 00:27:04,487
因此，我们将去掉等于0，并添加个override，我将再次得到
so we'll get rid of the equals 0, and add an override instead, um and again I'm just gonna get

294
00:27:05,800 --> 00:27:12,500
让我们将namespave Hazel也放入cpp文件中，将用VA来为我们生成这些，很好，而且简单
let's just put namespace Hazel as well into the cpp file, I'm just gonna get visual assist to generate this stuff for us, nice, and simple

295
00:27:13,333 --> 00:27:16,212
好了，酷，所以我想这东西实际上会实现我们的
okay, cool, so I guess what this stuff's gonna do is actually gonna do our

296
00:27:16,300 --> 00:27:25,625
它实际上将运行我们的代码，因此我们需要包含glad，SetClearColor将调用glClearColor
it's actually gonna run our code, so we need to include glad, right, SetClearColor is gonna call glClearColor, right

297
00:27:25,800 --> 00:27:34,725
用color.r，color.g，color.b，color.a，对吧，和xyzw一样，对吧
with color.r, color.g, color.b, color.a, right, it's the same as XYZW, right

298
00:27:35,700 --> 00:27:40,750
glm只是为我们提供了可以访问的相同变量的多种别名，那就很好
glm just gives us multiple kind of aliases for the same variables that we can access which is nice

299
00:27:41,766 --> 00:27:47,150
glClear，我们再执行一次glClear，这东西是你们知道的，临时的
glClear we'll just do glClear again, this stuff is you know, quite temporary

300
00:27:47,150 --> 00:27:51,975
因为很多时候，你们不想清除颜色和缓冲区，也不想清除
because a lot of the times you don't want to clear both the color and the buffer, and you don't want it clear

301
00:27:51,975 --> 00:27:56,375
但是颜色缓冲区和深度缓冲区，但是现在真的很简单，很原始
but the color buffer and the depth buffer, but for now again really simple, really primitive

302
00:27:56,375 --> 00:28:00,450
以后我们可能会取你们实际想要的或想清除的标记
in the future we're probably taking flags as to what you actually want to do, what you actually want to clear

303
00:28:00,800 --> 00:28:04,600
而且这个Clear指令可能是帧缓冲区实际上最终会调用的
and also this clear command is probably something that frame buffers will actually end up calling

304
00:28:05,533 --> 00:28:14,466
不仅仅是像这样的循环，DrawIndexed会执行glDrawElements，现在我们只是绘制三角形
not just like inside our loop like that, DrawIndexed is gonna do our glDrawElements, again for now we're just drawing triangles

305
00:28:14,466 --> 00:28:20,025
因为我们不知道我们现在真正想绘制的是什么样的图元，就像现在的三角形
because we have no idea what kind of primitive like, like type we actually want to draw at the moment, just triangles for now

306
00:28:21,300 --> 00:28:33,166
计数将是vertexArray->GetIndexBuffer()->GetCount()，GL
count is gonna be vertexArray GetVertex GetIndexBuffer, right, IndexBuffer->GetCount(), gl again

307
00:28:33,166 --> 00:28:38,925
我们现在只有一种类型的IndexBuffer，那是一个无符号int，也就是GL_UNSIGNED_INT
we've only got one type of IndexBuffer right now, and that's an unsigned int, GL_UNSIGNED_INT

308
00:28:39,175 --> 00:28:46,800
然后是nullptr，好了，那么继续，那就是DrawCall，完成了，好了，现在在里面
and then the point into this is gonna be null, okay, so there we go, that's how DrawCall, done, okay, and now inside

309
00:28:47,575 --> 00:28:57,166
显然，从我们实际的接口，对吧，抱歉，不是从接口，从RenderCommand，这里有点晕了
obviously from our actual like interface, right, sorry, not from our interface, from RenderCommand, I'm getting a little bit lost here

310
00:28:57,166 --> 00:29:02,825
因为这些东西是，有很多东西，而且它甚至没有出现在我的搜索中，这太棒了
because this stuff is, there's tons of this stuff, and it's not even showing up in my searches, which is fantastic

311
00:29:02,825 --> 00:29:10,066
但是在RenderCommand中，你们可以看到，因为当前的API设置为OpenGLRenderAPI
but inside RenderCommand, you can see that, because the API at the moment is set to be OpenGLRenderAPI

312
00:29:10,066 --> 00:29:19,100
而且我不确定为什么这些不运行，RendererAPI中，抱歉，显然只在RenderCommand中
and I'm not sure why this stuff is not working, RenderAPI, inside, sorry, it's just inside RenderCommand obviously

313
00:29:21,333 --> 00:29:26,766
因为它被设置为OpenGLRenderAPI，对吧，当我们从RenderCommand调用DrawIndexed
so once because it's set to OpenGLRenderAPI, right, when we actually call DrawIndexed from a RenderCommand

314
00:29:26,766 --> 00:29:32,300
会把它分发到那里，那就可以了，对吧，很明显，在以后，这种东西会动态地设置
is going to dispatch it to that, and that's just going to work, right, obviously in the future, this kind of stuff will be said dynamically

315
00:29:32,300 --> 00:29:37,475
不仅仅等于new OpenGLRenderAPI，当我们启动应用并创建正确的上下文时
not just equals new OpenGLRenderAPI, when we start up our Application, and we create the right context

316
00:29:37,750 --> 00:29:44,050
它实际上将通过创建一个新的OpenGLRenderAPI来指定使用哪个RenderAPI，好了，酷
it's going to actually specify which RenderAPI is using by creating like a new OpenGLRenderAPI, okay, cool

317
00:29:44,950 --> 00:29:47,299
而且显然不用担心内存泄漏之类的
and yeah obviously don't worry about like memory leaks or anything like that

318
00:29:47,300 --> 00:29:54,199
这是个指针，它将持续我们整个应用的整个生命周期，一个指向没有成员的类指针
this is a pointer, that's going to last the entire lifetime of our whole Application, and also it's a pointer to a class with no members

319
00:29:54,200 --> 00:30:00,775
如果内存泄漏，也只是一个字节，对吧，我想这只是一个字节的内存，我们永远不会清除
so it's a one byte memory leak, if it is a memory leak, right, and I guess it's just one byte of memory that we're never going to clear up

320
00:30:00,775 --> 00:30:06,725
直到应用结束，因为它永远不需要清理，所以请不要担心，好了，酷
until the end of Application, because it never needs to be cleared up, so please don't worry about that, okay, cool

321
00:30:08,133 --> 00:30:12,125
我认为这几乎完成了，我甚至不记得输入的代码
I think this is almost done, I don't even remember the code that I've typed

322
00:30:12,125 --> 00:30:16,366
那么如果转到Renderer.cpp，我的意思是DrawIndexed，对吧
so if we go to Renderer.cpp, yeah I mean DrawIndexd, right

323
00:30:16,366 --> 00:30:21,300
老实说，我们会分发它，我认为那应该很好，所以如果我们回到应用中
we dispatch that, and I think that should be pretty good, to be honest, so if we go back into Application

324
00:30:23,566 --> 00:30:29,866
我应该能够做的只是调用，它只是包含实际的Renderer
what I should be able to do is just call, it just include the actual Renderer

325
00:30:30,366 --> 00:30:39,575
Hazel/Renderer/Renderer.h，对吧，如果还没有包含在内，那应该完全是
what is it Hazel/Renderer/Renderer.h, right, if that's not already included, which should totally might be

326
00:30:39,733 --> 00:30:43,650
无论如何，我们会包含那个，然后而不是执行所有这些
anyway, we'll include that, and then instead of doing all of this

327
00:30:44,300 --> 00:30:48,775
你们知道，我们应该设置ClearColor，因为我们可以将其设置为与以前相同的东西
you know, we should set our ClearColor as we can set it to the same thing that we had it as before

328
00:30:50,066 --> 00:30:57,450
在这里，我们只是稍微清除了颜色缓冲区，现在清除了颜色和深度，很好，所以将其弹出
here we were just clearing the color buffer a bit, now we're clearing both color and depth, which is good, so we'll pop that in there

329
00:30:58,933 --> 00:31:04,475
所以显然没有，Renderer是否包含RenderCommand，因为如果它包含RenderCommand
so apparently doesn't have, does Renderer include RenderCommand, because if it does

330
00:31:05,175 --> 00:31:07,325
那么包含了的话，所以我们应该可以访问
then it does, so we should have access to that

331
00:31:07,325 --> 00:31:12,875
我们的RenderCommand没有这个，RendererAPI，当然，我们需要实际创建这些函数
our RenderCommand doesn't have that, are RendererAPI does, yeah of course, we need to actually make those functions

332
00:31:13,266 --> 00:31:16,575
所以这个SetClearColor和我们这里的所有东西都会复制这个
so this SetClearColor and everything that we have here will copy this

333
00:31:16,975 --> 00:31:18,966
我们会把它粘贴到这里，我们会稍微改变一下
we'll paste it here, and we'll kind of change it a bit

334
00:31:18,966 --> 00:31:24,059
所以这变成内联静态而不是虚拟的，对吧，然后很明显这个的实现
so this becomes inline static instead of virtual, right, and then obviously the implementation of this

335
00:31:24,533 --> 00:31:29,929
只是要把它分发到RendererAPI，所以就是s_RenderAPI->Clear()
is just going to be dispatching it to the RendererAPI, so RendererAPI::Clear()

336
00:31:31,766 --> 00:31:40,500
并且这个也变成了s_RendererAPI->SetClearColor (color)，好了
and this becomes RendererAPI->SetClearColor(color), okay

337
00:31:41,000 --> 00:31:44,625
然后回到这里，现在应该可以了，所以我们有了ClearColor
and then back here, that should now work, so we have our ClearColor

338
00:31:45,025 --> 00:31:54,999
我们就用大括号包起来创建一个vec4，然后呃，是的，我的意思是不再需要这些代码了
we'll just put Kelly brackets around this to create a vec4, and then uh in yeah, I mean instead of wearing it any this code anymore

339
00:31:55,333 --> 00:32:00,675
所以我们刚刚开始我们的场景，你们甚至可以，如果想的话，甚至可以把它放在个范围内
so we've just got kind of, we begin our scene, which you could even, if you want to, you know, you could even put this into a scope

340
00:32:01,066 --> 00:32:07,000
只是为了让你们清楚什么时候开始，什么时候结束，也许是这样，不会为此烦恼
just so that you're kind of clear as to when you kind of begin and when you end, maybe something like that, not gonna bother with that

341
00:32:07,000 --> 00:32:10,525
但是有些人这样做只是为了以防万一，可以这样做，如果你们愿意
but some people do that just in case it helps you, you can do that, if you want

342
00:32:11,250 --> 00:32:12,957
我们有了BeginScene和EndScene
we have BeginScene, we have EndScene

343
00:32:13,366 --> 00:32:18,825
然后我们实际上绘制了场景，所以绑定了着色器，提交了应该绑定它的VertexArray
and then we actually draw our scene, right, so we bind the shader, we submit the VertexArray which should bind it

344
00:32:19,133 --> 00:32:21,693
哦，那是我没有做的一件事，我没有绑定我的VertexArray
oh, that's one thing I didn't do, I didn't bind my VertexArray

345
00:32:22,050 --> 00:32:25,999
所以Renderer，对吧，当它提交这个，并说让我们绘制索引
so the Renderer, right, when it submits this, and says let's draw index

346
00:32:26,000 --> 00:32:31,150
它应该做的是显然绑定VertexArray，然后实际发出draw命令
what it should do is actually bind the VertexArray obviously, and then actually issue the draw command

347
00:32:31,600 --> 00:32:36,533
这是一个DrawCall，渲染命指令，渲染指令不会做很多事情，对吧
this is a DrawCall, this is a render command, render commands do not do multiple things, right

348
00:32:36,533 --> 00:32:41,725
除非它们可能是特别应该的，对吧，渲染命令不会做很多事情
unless they're like maybe specifically supposed to, right, render commands do not do multiple things

349
00:32:42,066 --> 00:32:49,499
这意味着你们不喜欢例如像VertexArray绑定在这里，不，这是一个，这只是DrawIndex
what that means is that you do not like for example be like VertexArray bind here, no, this is a, this just DrawIndex

350
00:32:49,566 --> 00:32:52,300
它所做的只是绘制索引，这是绑定任何东西，什么也不做
all it does is draw index, this is bind anything, doesn't do anything

351
00:32:52,475 --> 00:32:55,291
这是一个普通的RenderCommand
it's a plain old vanilla RenderCommand

352
00:32:55,666 --> 00:33:00,999
因此，Renderer负责抽象，例如像绑定顶点一样，对吧，绑定材质
so the Renderer is in charge of abstraction such as being like bind the vertex, right, binders share the set of the materials

353
00:33:01,000 --> 00:33:07,499
做所有的排序，对吧，因为它的级别要高得多，这就是它的原理，好吧，运行一下看看
do all the sorting that kind of stuff, right, cause it's much higher level, and that's what it operates on, okay, I'll stage it, now work

354
00:33:07,499 --> 00:33:13,722
让我们点击f5，看看会发生什么，我真的需要做一些上面有它的t恤，很快就会来，好了
let's hit that f5, and see what happens, I really need to make some t shirts with that on it, coming soon, okay

355
00:33:13,722 --> 00:33:19,525
一旦编译完了，你们可以看到，我们得到了完全相同的结果，非常棒，就是那样，对吧
and once our crochet compile, you can see, we get the exact same result, which is pretty awesome, okay, so that's that, right

356
00:33:19,700 --> 00:33:26,200
从理论上讲，我们可以做的是，实际上只是在这里去掉glad，所以我们不会再包含glad了
theoretically, what we can do hopefully is, actually just get rid of glad here, so we're not going to include glad anymore

357
00:33:26,500 --> 00:33:33,550
我们也没有包含在头文件中，如果点击control f7来编译这段代码，它运行了，对吧，漂亮
we're not including in the header file either, right, if I hit control f7 to compile this code, it works, right, beautiful

358
00:33:33,666 --> 00:33:40,275
所以我们不再需要glad了，我们只是完全使用Hazel自己的API来实际渲染这些东西，很酷
so we don't need glad anymore, we're just completely using Hazel's own API to actually render this stuff, which is pretty cool

359
00:33:40,733 --> 00:33:46,733
至于家庭作业，你们可以做的是从应用类中删除代码，放入Hazel中，然后移动到SandBox
for homework, what you guys could do is remove this code from the Application class, this inside Hazel and move it into Sandbox

360
00:33:46,733 --> 00:33:53,966
因为我们真的应该开始这样做，我可能会在下一期中这样做，但这将是一个很好的小练习
because we should really start doing that, and I'll probably do that in the next episode, but that'll be a nice little exercise

361
00:33:53,966 --> 00:33:59,150
你们将不得不移动所有这些VertexArray的东西，希望它可以跨模块运行，并且可以正确链接
you'll have to move all this VertexArray stuff, and hopefully it works across module, and it links properly

362
00:33:59,400 --> 00:34:06,799
应该，一切都应该很棒，就是这样，这很酷，我们有渲染器的开始
it should, everything should be great, and that's that, that's pretty cool, we have the beginnings of our Renderer

363
00:34:06,800 --> 00:34:09,536
无论如何，我希望你们喜欢这个视频，如果喜欢的话，就为它点赞吧
anyway, I hope you guys enjoyed this video, if you did, you can hit the like button

364
00:34:09,536 --> 00:34:10,799
就像我在视频开头所说的那样
as I said in the beginning of the video

365
00:34:10,800 --> 00:34:14,099
你们可以通过访问patreon.com/TheCherno来支持本系列
you can help support this series by going over to patreon.com/TheCherno

366
00:34:14,099 --> 00:34:21,375
非常感谢让该系列成为可能的那些朋友，下一期我们会讲相机
huge thank you as always to all the people that make this series possible, next time we're going to talk about cameras

367
00:34:21,375 --> 00:34:27,775
因为，不，这一切都很好，我们可以在屏幕上渲染一堆对象，但是这里缺少两件事，对吧
because, no, this is all great, that we can render a bunch of objects on the screen, but there's two things that's missing from this, right

368
00:34:28,450 --> 00:34:34,275
正如我所说，我们不知道在哪里渲染，在哪里渲染对象，我们不提供任何类型的转换矩阵
as I said, we don't know where we're rendering, where we're rendering the objects, we're not supplying any kind of transformation matrix

369
00:34:34,275 --> 00:34:38,133
我们需要实现那个，然后另一件事是，我们需要实际提供一个相机
we need to do that, and then the other thing is, we need to actually supply a camera

370
00:34:38,133 --> 00:34:42,933
这样我们就可以移动相机，做所有有趣的事情，所以下次我们要谈谈相机
so that we can move the camera around, and do all of that kind of fun stuff, so we're gonna talk about cameras next time

371
00:34:42,933 --> 00:34:47,400
然后在那之后，我也不确定，下次我们谈论相机时，我还
and then after that, I'm not sure either, next time we'll either talk about cameras, I haven't decided yet

372
00:34:47,866 --> 00:34:53,299
或者我们将讨论实际的变换矩阵，对吧，以及如何实际
or we'll talk about the actual transformation matrix, right, and how to actually

373
00:34:54,000 --> 00:34:57,528
如何实际绑定转换为我们运行到屏幕上的图元
how to actually tie transforms into primitives that we run runs onto the screen

374
00:34:57,900 --> 00:35:02,925
因为这种运行方式是转换实际上需要上传到着色器
because the way that kind of works is that transform actually needs to be uploaded to the shader

375
00:35:02,925 --> 00:35:07,500
所以从这个意义上说，它需要知道你们用什么着色器渲染
so in that sense, it needs like, it needs to know what shader you're rendering with

376
00:35:07,500 --> 00:35:09,699
并且要正确地做到这一点，需要一个材质系统
and to do that properly requires a material system

377
00:35:09,700 --> 00:35:14,100
但是很明显，我们有一种方法可以快速实现，我们可能会这样做
but obviously there's a way for us to do what kind of quickly, and we'll probably do that

378
00:35:14,100 --> 00:35:19,012
这样我们就可以开始在屏幕上看到一些东西，真的很令人兴奋，因为一旦有了这样的东西
so that we can actually start having stuff on the screen, and that's pretty really exciting, because once we have that kind of stuff

379
00:35:19,800 --> 00:35:23,300
我们可以，你们知道，一旦我们有一个好的相机系统和提交的方法
we can just, you know, once we have a good camera system and ways to kind of submit

380
00:35:23,420 --> 00:35:27,425
就像使用某个相机开始场景，然后使用不同的转换提交对象一样
like begin a scene with a certain camera, and submit objects with different transforms

381
00:35:27,425 --> 00:35:29,175
我们实际上可以开始构建场景
we can actually start building up a scene

382
00:35:29,333 --> 00:35:33,900
这些是我们需要的主要构建，然后从那里你们知道，我们可以开始渲染一个实际的3D场景
those are the main building box we need, and then from there you know, we can start rendering an actual 3D scene

383
00:35:33,900 --> 00:35:38,533
这最终是什么样的转向，但是你们知道的，我们还可以做其他的事情，比如纹理
which is ultimately where what kind of steering to was, but you know there's other stuff we can do along the way, like textures

384
00:35:39,600 --> 00:35:42,150
因为这是一种2D的东西，所以我们可以，你们知道的
because that's kind of a 2D thing, anyway, so we can you kno

385
00:35:42,150 --> 00:35:44,375
我们现在正在绘制一个矩形，为什么不对其进行纹理处理，对吧
we're drawing a rectangle right now, why not texture it, right

386
00:35:44,733 --> 00:35:46,275
所以我们必须在某个时候处理这个问题
so we'll have to deal with that at some point

387
00:35:46,275 --> 00:35:50,333
然后还有其他我现在不想做的事情，但是我的意思是我们应该
and then there's other things that I don't really wanna do now, but we I mean we should

388
00:35:50,333 --> 00:35:55,941
但它只是关闭了我们，这是非常复杂的，但基本上是那种渲染器命令队列和多线程渲染器
but it just closes us down, and it's very complicated, but basically that kind of renderer command queue and multi threading our renderer

389
00:35:56,133 --> 00:36:01,599
一旦我们真的有了3D设计可以玩，这些东西可能会在将来完成，因为这更像是一种优化
that stuff will probably do in the future, once we actually have a 3D design to play around with, because that's more of an optimization

390
00:36:01,600 --> 00:36:05,966
在这一点上，这绝不会成为瓶颈，它只会进一步使我们的代码复杂化
that's no way gonna be a bottleneck at this point, and it's just gonna further complicate our code

391
00:36:05,966 --> 00:36:12,075
所以我宁愿先做其他的事情，不管怎样，让我知道你们的想法，下次见，拜
so I'd rather kind of do the other stuff first, anyway, let me know what you guys think, and I will see you next time, goodbye

