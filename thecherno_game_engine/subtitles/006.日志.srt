1
00:00:00,000 --> 00:00:03,400
嘿，你们好，我是TheCherno，欢迎回到我的游戏引擎系列
hey, what's up guys, my name is TheCherno, welcome back to my game engine series

2
00:00:03,400 --> 00:00:11,000
那么上次我们讲了入口点，关于如何定义引擎和应用的入口，以及它们的原理
so last time, we took a look at entry points on how we actually had to kind of define an entry point for both our engine and application, how all that worked

3
00:00:11,350 --> 00:00:16,700
如果你们还没看过的话，一定要去看看那期视频，并且今天我们会看一看日志
definitely check out that video, if you haven't already, and today we're gonna be taking a look at logging

4
00:00:16,700 --> 00:00:23,625
以及如何在我们的引擎中使用日志库，这样我们就可以用不同的颜色将内容记录到控制台
and how we can actually use a logging library in our engine, so that we can log things to the console in various like special colors

5
00:00:23,625 --> 00:00:28,550
在我们代码库的任何地方都有特殊的标记，不管怎样，应该会很有趣
and just everywhere throughout our codebase special tags, and anyways, gonna be a lot of fun

6
00:00:28,975 --> 00:00:33,875
首先，和往常一样，对所有让这个系列成为可能的赞助人表示衷心的感谢
first of all, I just want to give a huge thank you as always to all the patrons that make this series possible

7
00:00:33,975 --> 00:00:37,600
如果你们还没支持这个系列，可以访问patreon.com/thecherno
if you guys aren't supporting the series, we've got a patreon.com/thecherno

8
00:00:37,600 --> 00:00:39,450
没有你们，就没有这个系列
the series wouldn't be here without you guys

9
00:00:39,450 --> 00:00:44,050
因此和往常一样，非常感谢你们，作为对支持本系列的奖励
so a huge thank you as always, and as a as a reward for supporting this series

10
00:00:44,050 --> 00:00:48,000
你们将获得我已经编写的实际Hazel引擎的源代码等东西
you'll also get things like source code to the actual Hazel engine that I've already written

11
00:00:48,125 --> 00:00:54,475
因为我马上就会写，每周也会提前做视频，所以总是很有趣的
as I'm writing it kind of just immediately as well as videos per week early, so it's always interesting 

12
00:00:54,475 --> 00:01:00,510
当我做这些视频时，因为在某种意义上，我是为一批人做的，比第二批人早一周
when I make these videos, because in a sense, I'm making it for like one group of people a week before the second group of people

13
00:01:00,510 --> 00:01:05,350
所以当这个视频在网上公开的时候，好像我早就忘记了
so by the time this video is actually public for everyone for the whole internet, like I've already long forgotten about it 

14
00:01:05,350 --> 00:01:09,525
因为我已经忙着为赞助人制作下一期视频了，但无论如何，让我们先看看日志吧
because I already made the next video for patrons, but anyway, let's get into logging

15
00:01:09,525 --> 00:01:12,600
那么什么是日志，为什么需要它，以及我们今天要做什么
so what is logging, why do we need it, and what are we going to do here today

16
00:01:13,000 --> 00:01:20,250
那么日志基本上只是记录事件的一种方式，对吧，我说的是自由意义上的事件
so logging is just a way for us to basically log events, right, I say events in kind of a liberal sense

17
00:01:20,250 --> 00:01:26,220
就像是因为事件真的不是任何事情，就像任何时候，我想说，嘿，发生了什么事，对吧
like because events don't really really be anything, like anytime, I want to be like hey something happened, right

18
00:01:26,220 --> 00:01:34,625
我想要有一种与人们交流的优势，人们不仅在开发它，也可能在使用它，对吧
I want to essentially have a way of the edge in communicating with us, the humans who are both developing it, but also possibly using it, right

19
00:01:34,625 --> 00:01:43,125
那么一个很好的例子就是，启动引擎，对吧，让我们打印出系统初始化执行的东西
so a good example is we started the engine, right, let's print off the kind of system initialization things that happen

20
00:01:43,425 --> 00:01:50,640
甚至可能是系统信息，比如系统信息，比如关于系统的信息
maybe even system information information as well, say system information, information, like this information about the system

21
00:01:50,640 --> 00:01:56,000
不管我们在运行某些东西是否工作，文件是否被打开
that we're running on whether or not things certain things worked, whether or not said files were opened

22
00:01:56,000 --> 00:02:02,925
着色器是否被成功编译，这儿有很多信息需要反馈
whether or not like the shaders were compiled successfully, there's so much information, that we need to basically give as feedback

23
00:02:02,925 --> 00:02:09,929
因为至少对我来说，一款好的软件是面向客户的
because to me at least like a good piece of software is very kind of client-facing in the sense

24
00:02:09,929 --> 00:02:17,519
这就像当你们写一个软件，即使是比较复杂的，当出错时，你们需要知道实际发生了什么
that like when you write a piece of software, that is even moderately complicated, when things go wrong, you want to know what's actually happened

25
00:02:17,519 --> 00:02:23,750
对吧，但是你们的电脑运行这些代码，执行这些复杂的操作，特别是随着代码库的增长
right, but your computer's running all of this code, it's doing all of these complicated operations, especially as the code base grows

26
00:02:24,000 --> 00:02:31,850
它会执行所有这些复杂的操作，但也会缄口不言，那可不是我们想要的，对吧
it's gonna be doing all of these complicated operations, but it's gonna be kind of keeping it to itself, that's not what we want, right 

27
00:02:31,850 --> 00:02:37,550
因为如果事情出了问题，或者即使进展顺利，我们也不知道到底发生了什么
because if something goes wrong, or even if something goes right, we have no idea of actually seeing what's happened 

28
00:02:37,925 --> 00:02:43,325
并且我真的很想知道，发生了什么，对吧，我就必须要知道
and I really like to know, what is going on, right, I just have to know

29
00:02:43,475 --> 00:02:47,225
电脑做了什么，处于什么状态，对吧
what the computer is done, and what state is kind of in, right

30
00:02:47,450 --> 00:02:51,802
并且那就是日志的作用，日志是我们在写代码时
and that's where logging comes in, logging is a way for us to actually as we write our code 

31
00:02:51,802 --> 00:02:55,750
当我们编写复杂的代码时，反馈信息给我们自己的一种方法，基本上也就是好了
as we write our complex code to communicate back to ourselves, and basically say okay

32
00:02:55,750 --> 00:03:02,069
所以我试着做这件事，这发生了，这是现状，这是正在发生的，这是我接下来要做的
so I tried to do this, this happened, this is the status, this is what's going on, this is what I'm gonna do next well 

33
00:03:02,069 --> 00:03:06,525
这是一个错误，比如你们知道的，也许可以修复它，那么还有很多警告之类的东西
this was an error, you know, maybe fix this, you know, so many things like warnings as well

34
00:03:06,525 --> 00:03:07,675
这儿有很多事情我们需要去处理
there's so many things we want to do

35
00:03:07,675 --> 00:03:14,300
所以除了能够和我们自己反馈原因，比如通过printf或者std::cout之类的
so apart from just being able to communicate back to ourselves why, like a printf or like std cout or something like that

36
00:03:14,600 --> 00:03:22,575
我们可能还想知道消息来源，以及严重程度
we also probably want information about where that message is coming from, as well as potentially the severity of that message

37
00:03:22,575 --> 00:03:28,475
所以而不是像你们知道的，就这一堆被打到终端的文字
so instead of just being like you know, here's like a bunch of you know text being printed out console 

38
00:03:28,600 --> 00:03:32,575
我们可以用不同的颜色，比如错误是红色，警告是黄色
we might want to use different colors, so like errors might be red, warnings might be yellow

39
00:03:32,675 --> 00:03:39,800
普通的信息是绿色，不重要的是灰色之类的，或者希望我们需要的这整个系统
normal stuff might be green, stuff that's not important might be like gray or something, there's the kind of this whole system that we want

40
00:03:40,500 --> 00:03:45,275
能让我们轻松地在运行的终端中滚动查看
that really provides us like with the way to just easily be able to like scroll through our running a console

41
00:03:45,275 --> 00:03:49,475
并且就像，哦，不，我看到了一个红色的信息，让我们调查一下，那可能是有问题
and be like, oh no I saw a red message there, let's investigate there, that's probably something wrong well

42
00:03:49,829 --> 00:03:55,175
或者也许我们知道黄色不太重要，可以忽略它，不过这儿还有很多东西需要处理
or maybe we know yellow is probably not that great, we can kind of ignore it, there's so many things that we wanting to deal with

43
00:03:55,425 --> 00:03:58,775
所以正因为如此，我要在日志库里删除那些
so because of that, what I'm gonna be riding out or in logging library

44
00:03:59,175 --> 00:04:04,275
我们可以那样做，只不过那可能要花上一段时间，大概一周的时间
um we could do that, that would take a while maybe like a week's worth of excises

45
00:04:04,275 --> 00:04:16,950
比如要花一周的时间，但我认为日志最大的问题是格式化不同的类型，对吧
like a week's worth of work really is what I was gonna say, but the idea is that the biggest issue with logging I think is formatting different types, right

46
00:04:16,950 --> 00:04:22,300
所以打印hello world之类的很简单
so printing just hello world or whatever is easy

47
00:04:22,300 --> 00:04:27,825
因为我们可以这样，这是我的字符串，就那样，完成了，好了
because we can just be like this is my text string that, that's kind of, that's kind of it, that's done, right

48
00:04:27,825 --> 00:04:33,650
但当我们有，如果你们看一个真正的引擎代码库，想要打印东西
but when we actually have, if you actually look at a real kind of engine code base, and you want to print stuff

49
00:04:33,916 --> 00:04:36,120
你们想要打印的可不仅仅就是文本了，对吧
you want to print much more than just text, right

50
00:04:36,120 --> 00:04:42,025
比如打印数字，打印对象，打印指针，我们想打印的东西太多了
you want to print numbers, you want to print objects, you want to print pointers, you want there's so many things that we want to print

51
00:04:42,300 --> 00:04:47,750
并且我们需要一种好的方式来格式化字符串，并加强格式化，写出一种好的C#风格
and we need a good way to format that string properly, and strength formatting, writing a good kind of C# style

52
00:04:47,750 --> 00:04:53,950
string.format函数需要很多工作，并且大概有一千行代码，对吧
string dot format function is a lot of work, and probably about a thousand lines of code, right

53
00:04:53,950 --> 00:04:56,400
所以我并不想在这上面花时间
so it's not something that I really want to spend time on

54
00:04:56,400 --> 00:05:03,675
在这个系列中，我只是想给你们，我想我是在用一种服务编写代码的方式来解释这些
in this series, I just I'm trying to give you guys, I guess there is I'm explaining all this in a way in service writing code

55
00:05:04,475 --> 00:05:08,950
只是因为我想让你们知道，当我做决定的时候，脑子里在想些什么，好吧
it's just because I kind of want to give you guys an idea of what that's going through my head when I decide, okay

56
00:05:08,950 --> 00:05:12,800
我们不会自己写这个，就用一个库，并且对于这个
we're not going to write it ourselves, we're just gonna use a library, and for this

57
00:05:12,800 --> 00:05:20,050
这实际上是因为我希望能够支持字符串格式
it's literally because of the fact that I want to be able to support string formatting

58
00:05:20,300 --> 00:05:27,075
并且可能像你们知道的，实际日志消息的参数数量是未知的
and probably like you know an undetermined amount of arguments for our actual log message

59
00:05:27,300 --> 00:05:33,000
并且那是一种更简单的做法，用一些好的库，已经写好的库，再使用它
and that's something that it's much easier to just take something good, that has been written and reuse it

60
00:05:33,000 --> 00:05:34,710
而不是写其他的东西
instead of kind of writing everything else else

61
00:05:34,710 --> 00:05:40,982
因为那样的话，这里就有了，不论如何，我们将使用一个库spdlog
because then this would take over here, anyway, so we're gonna be using a library called spdlog

62
00:05:41,125 --> 00:05:43,675
那么就在这儿打开github吧
so if we just open up github over here

63
00:05:44,400 --> 00:05:50,700
我在这里得到的只是一小部分，我会把这个链接放在描述里，并且也为它点了星星
what I've got here is just to get up a drop, and I'll leave this in the description, I was just I've also starred um 

64
00:05:51,325 --> 00:05:56,200
所以你们可以自己去看看，它非常非常快，甚至可以运行在异步模式下
so you guys can check this out for yourselves, it's very it's quite fast, it's even runs an asynchronous mode

65
00:05:56,200 --> 00:05:58,750
并且这里有一个很好的使用示例
and there's a really nice usage sample here

66
00:05:58,750 --> 00:06:04,025
你们可以自己去看看，我最喜欢的东西，你们知道的，比如格式
that you can kind of look at yourself, the primary things that I like, you know, it's stuff like formatting

67
00:06:04,025 --> 00:06:06,600
我的意思是，如果你们看这个，这些是不同类型的信息
I mean, if you look at this, these are the different kind of messages

68
00:06:06,600 --> 00:06:10,125
有警告的重要信息或任何不需要使用的信息
that you have warn critical info or whatever we don't have to use

69
00:06:10,125 --> 00:06:15,975
我们可以选择使用其中的任何一种，但你们可以看到，他们喜欢的信息是一种C#的风格
we can use any kind of subset of these as we choose, but you can see, that the way they love messages is very kind of C# style

70
00:06:16,825 --> 00:06:22,260
它们是如何得到引用的参数，所以第一个就是这个第一个
how they've basically got which argument is refers to, so that the first one, the only one 

71
00:06:22,260 --> 00:06:30,225
然后对那个参数有不同的格式化选项，你们可以用不同的顺序来做参数
and then different formatting options for kind of that argument, and you know, you can do, like you know, arguments in different kind of order 

72
00:06:30,225 --> 00:06:35,675
无论如何，这是这是非常棒的，非常明显的C#风格，真的很好，我真的很喜欢它
and anyway, this is just this is just great, it's very C# style,  which is really good, and I really like it 

73
00:06:36,170 --> 00:06:41,371
当然，如果你们看看一份许可证，我们需要为我们使用的每个库做的，那就是MIT许可证
and also if you look at a license of course, which we need to do for every library that we use, it's the MIT license 

74
00:06:41,675 --> 00:06:47,475
你们可以看到，我们得到了所有我们需要的许可只要我们保留了这个版权声明
you can see, we have all the permissions that we need as long as we actually retain this copyright notice

75
00:06:47,475 --> 00:06:51,350
当然我们会在我们的引擎中保留它，好了，酷
which of course we will inside our engine, ok, cool 

76
00:06:51,350 --> 00:06:53,925
既然我们已经决定使用它，那么如何使用它
so now that we've decided to use this, how do we use this

77
00:06:53,925 --> 00:07:01,225
现在我可以做一个完整的视频，关于如何在你们的代码库中正确使用第三方库
now I could make an entire video on the proper way to use third-party libraries in your codebase 

78
00:07:01,225 --> 00:07:11,350
因为没有正确的方法，基本上，由于这儿是C++，C++处理各种模块的约束
because guess what there is no proper way basically, there is C++, C++ laws dealing with kind of modules 

79
00:07:11,350 --> 00:07:18,380
或者库也不是那样的，这儿没有真正的标准方式，比如人们会有不同的方式，人们可能会
or like just libraries is just not that, there's no real standard way to, like people will have different ways, people might be like

80
00:07:18,380 --> 00:07:21,575
哦，比如你们知道的，你们看看，例如使用自己的系统
oh you know, you see, eg use kind of your own system

81
00:07:21,575 --> 00:07:25,700
如果没有的话，可能就会使用子模块，就像它不会那样
 if you didn't get, maybe use Sub-modules, like it doesn't that 

82
00:07:25,700 --> 00:07:29,750
这儿没有一种语言能够找到一种方法来导入库并使用它们
there's no kind of language to find a way to actually import libraries and use them

83
00:07:30,075 --> 00:07:35,125
所以我可能会做一个视频来介绍我在我的职业生涯中发现的各种不同的方法
so maybe I will make a video on various ways to do it, and what I've kind of found throughout my kind of career 

84
00:07:36,000 --> 00:07:44,900
但很多时候，关键在于选择一个你们想要使用的构建系统，比如CMake或premake之类的
but a lot of times, it basically comes down to pick a build system that you want to use, such as CMake or premake or something like that

85
00:07:45,950 --> 00:07:52,050
然后确保你们使用的每个库，把那些写进你们的构建系统
and then just make sure that every library that you use, you kind of rice a you write that into your build system

86
00:07:52,450 --> 00:07:59,500
然后对于这样的东西，可以单独维护它们，然后在更新时更新它们
and then for things like this, you either can kind of maintain them separately, and just update them kind of as updates come out

87
00:07:59,700 --> 00:08:01,900
或者你们可以像我那样git submodule添加它们
or you can add them, like as I git submodule

88
00:08:01,900 --> 00:08:04,100
如果你们还没有使用git的话，就不能把它们作为子模块使用
if you didn't use git, you cannot add them as it git submodule

89
00:08:04,400 --> 00:08:09,500
那可能是最好的方法，但还是没有，这儿还是没有正确的方法去实现这些
that's probably the best way to do it for that, but there's still kind of no, there's no right way to do things

90
00:08:10,125 --> 00:08:14,960
最终这些会过期，或者最终会得到一个库，想要使用它
and eventually things will go out of date, or eventually like you'll run into a library, you want to use that

91
00:08:14,960 --> 00:08:20,100
没有使用你们使用的构建系统，所以必须自己写，比如，我想使用某个东西
doesn't use the build system you use, so you'll have to write your own kind of, you know, for example, I want to use something

92
00:08:20,100 --> 00:08:25,650
我用CMake作为例子，实际上并不在这个系列中，但不管怎样，我用的是CMake
I'm using CMake as an example, I'm not actually in this series, and probably warrant, but anyway, I'm using CMake

93
00:08:26,425 --> 00:08:28,725
我决定使用这个，它没有相同的CMake
I decided to use this, this doesn't have same CMake

94
00:08:28,725 --> 00:08:32,175
好吧，我必须编写自己的CmakeList文件，以便为CMake编译此文件
okay, I have to write my own CMakeLists file to make this compile for CMake

95
00:08:32,175 --> 00:08:38,125
然后我在我的代码中使用它，那些基本上是你们最后可能要在库中做的事情
and then I use that in my code, that's essentially something that you'll probably end up having to do for libraries 

96
00:08:38,125 --> 00:08:44,750
除非你们所使用的库正好与所使用的构建系统一致，或者恰好与你们所使用的日期一致
unless everything happens to use the build system that you're using, and also happens to be for example on year 

97
00:08:45,125 --> 00:08:51,550
就比如git的版本控制系统，你们就可以把它用作子模块，总之，整个东西很乱
as like on Veron gets kind of version control system, so you can just use it as a submodule, so anyway, the whole thing is a mess

98
00:08:52,900 --> 00:08:56,950
并且我不想花太多时间讨论它，那就让我们把它下载到项目中
and I'm like I don't want to spend too much time talking about it, but let's actually just kind of download this into our project

99
00:08:57,575 --> 00:09:01,475
所以我们能做的，我们能做的事情有很多，可以克隆或下载这个
so all we could do, there's a number of things that we could do we could just clone or download this

100
00:09:01,475 --> 00:09:08,350
只下载一个压缩文件，并解压到我们的目录，也可以克隆到它自己的目录，然后复制文件
just download a zip file, and unzip it into our directory, we could clone this into its own directory and then copy the files

101
00:09:08,700 --> 00:09:15,530
或者，实际上，我是把它作为子模块添加到Hazel仓库中，那么这就意味着
or what I'm going to do is actually add it as a submodule to our Hazel repository, so what this means is

102
00:09:15,530 --> 00:09:27,125
我们的代码库中没有那个代码库，我们引用的是其他地方的现成git库
that we don't actually kind of have the code base in our code base, it's basically like it's basically we're referencing an existing git repository somewhere else

103
00:09:27,125 --> 00:09:34,500
这儿有一个远程地址，当克隆Hazel时，我们看到克隆了所有子模块，它也就克隆了那个
there's kind of at a remote address, and then when we actually clone Hazel, and we see also clone all the submodules, it clones that 

104
00:09:34,900 --> 00:09:41,200
这个很有用的原因是它能保持代码的完整版本
and the reason that that's kind of useful is because it kind of keeps a version kind of code intact as well, as less

105
00:09:41,200 --> 00:09:48,175
让我们从代码库中轻松地更新新代码而不需要手动做任何事情
let's kind of easily like kind of update to new code changes from their repository without kind of having to do anything manually

106
00:09:48,175 --> 00:09:52,200
我们只需要更新，只需要更新那个特定的子模块
we can just update, we can just update that specific submodule

107
00:09:52,200 --> 00:09:56,875
因为它是一个子模块，并没有将代码复制粘贴到我们自己的仓库中
because it is a submodule, and it's not actually copied and pasted code into our own repository

108
00:09:57,025 --> 00:10:01,500
以后我可能会单独做一个关于git子模块的视频
I may actually make kind of a standalone video on git submodules in the future

109
00:10:01,500 --> 00:10:04,340
因为使用这个在这个属性的上下文中使用它是最好的例子
because using this using it in the context of this properties in the best example

110
00:10:04,340 --> 00:10:11,700
但基本上我要做的就是复制这个地址，然后到Hazel，打开一个命令提示符窗口
but basically all I'm going to do is copy this address here, and then come down into Hazel, I'll open a command prompt window here

111
00:10:12,150 --> 00:10:20,726
然后输入git submodule add，然后粘贴路径，抱歉，是git仓库的url
and I'm going to just type in git submodule add, and now I have to I'll paste in the path or sorry the url to the actual git repository 

112
00:10:21,475 --> 00:10:27,200
然后我要做的是指定，我想把代码添加到哪里，现在你们可以看到，这真的很不错
and then what I'm going to do is specify where I want it to actually add this code into, now you can see that this is really nice

113
00:10:27,675 --> 00:10:33,650
这做得很好，我的意思是，它有include spdlog，并且那才是我们真正需要的唯一东西
this is really nicely done, I mean, it's got like include spdlog, and that's really kind of the only thing that we need

114
00:10:34,575 --> 00:10:42,175
尽管还有很多其他东西，比如我说的在包含路径中，这是我们需要的另一个东西
even though there's so much other stuff like what I'm saying is that in kind of into our include path really, this is the other thing that we need 

115
00:10:42,950 --> 00:10:52,500
但那没关系，我们稍后会整理，我想要存储所有这些第三方库的地方是在解决方案目录中
but that's okay, we'll sort that out later, so what is where I want to store all these third-party libraries is going to be kind of in the solution directory

116
00:10:53,500 --> 00:10:56,275
可能在Hazel内部
probably inside Hazel itself

117
00:10:56,275 --> 00:11:03,625
因为我不那么认为，我们应该在每个项目中使用第三方库，而不是整个解决方案
because I don't think that,. this will be like we should probably have third-party libraries per project, rather than for the entire solution

118
00:11:03,925 --> 00:11:10,550
那么在Hazel中，我要创建一个名为vendor 的文件夹，它指的是所有的第三方库
so inside Hazel, I'm going to make a folder called vendor write, which is going to refer to all third party libraries 

119
00:11:11,525 --> 00:11:17,750
然后这个库的名字是spdlog，因为显然我不希望所有这些文件都只放在vendor文件夹中
and then the name of this library which is going to be spdlog, because obviously I don't want all of these files just in my vendor folder

120
00:11:18,100 --> 00:11:24,825
那么那就是我要做的，点击回车，然后它会把那个仓库复制到那个项目中
so that's all I'm going to do, I'm gonna hit enter, and then it's going to actually clone that repository into that project

121
00:11:25,475 --> 00:11:28,150
并且你们还会看到，它完成后
and what you'll also see, once it finishes 

122
00:11:28,150 --> 00:11:34,300
会有一个文件出现在根目录中，叫作gitmodules，如果我们打开那个文件
is a file appear in our actual root directory called gitmodules, and if we just kind of open that file 

123
00:11:34,300 --> 00:11:37,000
在这里，我现在就用VS打开它
I'll just open it with Visual Studio at this point

124
00:11:37,000 --> 00:11:43,370
可以看到，它在这个路径中创建了一个新子模块，这里有一个路径，url是？，好了
you can see that, it's created a new submodule in this path, there's a path, and there's the url is company, okay 

125
00:11:43,370 --> 00:11:50,350
那么这就是子模块的定义，在Hazel中，你们会看到vendor/spdlog，就在这儿，对吧
so this is what actually kind of defines that submodule, and inside Hazel, you'll see vendor/spdlog, and then here it is, okay

126
00:11:50,725 --> 00:11:57,975
所以我们需要在项目中加入include来访问它，然后像这样保存它
so what we need to include in our project to get access to this is include, and then well keep this like this 

127
00:11:57,975 --> 00:11:59,600
所以基本上，这就是我们需要的路径
so basically this is the path we need

128
00:12:00,000 --> 00:12:08,450
所以我将复制这个路径，粘贴到下面的Hazel项目的右键属性中
so I'm going to copy this path, I'm gonna paste it into below right-click properties for our actual Hazel project

129
00:12:08,725 --> 00:12:14,600
来到C/C++，然后附加包含目录，在所有配置的通用目录下
I'm going to go to C/C++, and then additional include directories, under general for all configurations

130
00:12:14,600 --> 00:12:18,450
还有我们唯一的平台，添加这个，好了
and our only platform here, I'm going to add this, okay

131
00:12:18,925 --> 00:12:26,425
很简单，现在因为这是实际的Hazel，我要做的是创建一个适用于所有项目的通用路径
pretty simple, now because this is actual Hazel, what I'll do is I'll make kind of a universal path that works for all projects

132
00:12:26,425 --> 00:12:31,360
因为我们还需要在Sandbox中包含这个，因为这是一个头文件库
because we will have to actually include this in Sandbox as well, since this is kind of a header library

133
00:12:32,150 --> 00:12:37,300
那么然后是$(SolutionDir)/Hazel/vendor/spdlog/include，好了
so $(SolutionDir) and then Hazel/vendor/spdlog/include, okay

134
00:12:37,300 --> 00:12:42,925
把它复制到Sandbox这里，是的，这里，然后把它粘贴到这里
copy this go to Sandbox here, yes here, and I'll paste this into here

135
00:12:42,925 --> 00:12:48,925
现在这就有点烦人了，当我们转换到使用构建系统时，显然要在构建系统中很好地定义这个
now this is going to get a little bit annoying, when we switch to using a build system well, obviously define this nicely in the build system

136
00:12:49,275 --> 00:12:55,670
所以我们不需要在属性页中跟踪它，这可能会有点烦人，好了，酷
so we won't have to kind of keep track of it here in these property pages, which can get a little bit annoying, okay, cool

137
00:12:55,670 --> 00:12:58,775
那就完成了，现在我们可以开始使用这个库了
that is done, now we can actually start using that lib

138
00:12:59,025 --> 00:13:06,325
让我们为它做一个包装器，那么现在在这个点上，我们可以用spdlog作为spdlog
so let's make our own wrapper for it, so now at this point, we could just kind of use spdlog as spdlog 

139
00:13:06,550 --> 00:13:14,325
但我们显然不想在实际的客户端游戏中使用SpdLog:::Log之类的东西，对吧，这是Hazel引擎
but we obviously don't want to kind of have like spdlog log or whatever stuff in our actual client game, right, this is the Hazel engine

140
00:13:14,475 --> 00:13:20,325
我们应该有Hazel::Log之类的东西，那很重要，首先，我想改变接口
we should have Hazel log or something like that, that's important for a number of reasons, first of all, I want to change the api

141
00:13:20,325 --> 00:13:25,100
我不想让它看起来像他们的接口，因为他们的接口实际上很babos，我们需要一些东西
I don't want it to look like their api, because their api is actually quite babos we want something

142
00:13:25,100 --> 00:13:30,250
很简单，这是一个日志，这是一个引擎的日志系统，所以这个应该被放大
really simple, this is a log, this has come with a logging system for an engine, so really this should be magnified

143
00:13:30,850 --> 00:13:37,100
那有点像全局宏，我们可以使用日志级别的宏，我们不想让你们开始处理命名空间
that's kind of like a global macro that we can use log level or something like that, we don't want to have to like to start you dealing with namespaces 

144
00:13:37,100 --> 00:13:40,675
或者长串的字符串是完全没有必要的
or having like long kind of strings of Texas is like completely unnecessary 

145
00:13:40,875 --> 00:13:45,675
但如果进一步考虑，我们决定用另一个日志库替换这个日志库
but also if further down the line, we decide to replace this logging library with another log library

146
00:13:45,675 --> 00:13:50,825
我们应该能够在不改变任何客户端代码的情况下进行这种切换
we should be able to ha swap that kind of out without actually having to change any client code 

147
00:13:50,825 --> 00:13:54,550
因为我们希望我们的游戏代码像人们使用Hazel引擎时一样
because we want our game code like when people use the Hazel engine

148
00:13:55,250 --> 00:13:57,250
并开始做一些事情，比如记录一条消息
and start doing things like a logging a message

149
00:13:57,700 --> 00:14:02,450
如果我们决定在内部修改一些东西，我们不希望他们必须通过他们的代码库
and like if we decide to change something internally, we don't want them to have to go through their code base

150
00:14:02,750 --> 00:14:05,275
改变他们一直在使用的接口
and kind of change the api that they've been using

151
00:14:05,475 --> 00:14:11,000
因为我们决定改变一些东西，尽可能小的破坏变化是我们想要的
because we've decided to change something as minimal breaking changes as possible is what we kind of want

152
00:14:11,000 --> 00:14:19,160
因此，我们要创建一个日志类，它包含了很多spdlog功能，最后调用一些静态函数
so because of that, we're gonna create a log class, which kind of wraps a lot of spdlog functionality and just ends up calling kind of static functions

153
00:14:19,160 --> 00:14:26,150
我想那会向spdlog提供任何参数，所以基本上就是在搞包装器，让我们直接去实现那个吧
I guess that will then forward kind of arguments of whatever to spdlog, so we're basically is putting a wrap up, let's just go ahead and do that 

154
00:14:26,825 --> 00:14:37,225
那么在Hazel上，我右键点击添加新项，我们要创建一个类，然后把它命名为Log，好了
so over here on the Hazel, I'm going to right click hit add new item, we're going to just create a class, then we're gonna call it Log, ok

155
00:14:37,850 --> 00:14:46,250
每一层cpp都有日志，点击确定，这里就有了日志类，那么就输入命名空间Hazel
we're gonna have log on each level cpp, hit OK, and there, we have our log class, so I'm going to type in namespace Hazel

156
00:14:48,900 --> 00:15:03,550
这将是Hazel_API Log类，包含Core.h，可能放错地方了，我们把它移到Hazel文件夹，好了
this is going to be class Hazel_API Log, will include Core.h, now this is probably made it in the wrong place, let's just move this into the Hazel folder here, okay

157
00:15:03,900 --> 00:15:06,900
那么我们有了Core.h，我们要进入Log.cpp
so we've got Core.h, we're going to go into Log.cpp

158
00:15:07,300 --> 00:15:16,020
还要确保这是命名空间Hazel，到目前为止，那看起来不错，好了
and also make sure this is the namespace Hazel, and that looks pretty good to me so far, okay

159
00:15:16,125 --> 00:15:22,000
我不知道为什么它不能工作，它完全在同一个目录，所以我们假设这是VS在搞怪
so now I'm not sure why this isn't working, it's totally in the same directory, so we'll just assume that's Visual Studio being weird 

160
00:15:23,075 --> 00:15:32,225
那么现在我们需要考虑如何使用spdlog，所以要做的就是包含spdlog/spdlog.h
so now we need to think about how we can actually use spdlog, so the way we're going to do that is really just include spdlog/spdlog.h

161
00:15:32,850 --> 00:15:36,730
我们需要在头文件中这样做，你们马上就会知道为什么，现在我们只是想定义
we're gonna have to do this in the header file, and you'll see why in a minute, but now we just want to kind of define

162
00:15:36,730 --> 00:15:44,525
我们实际的接口看起来会像一些宏，这样我们就可以在需要的时候很容易地调用日志函数
what our at our actual api will kind of look like as well as probably some macro, so that we can kind of easily call logging functions as required 

163
00:15:44,775 --> 00:15:49,650
那么spdlog有一个很好的例子，我们可以从中复制一些代码
so spdlog actually has quite a nice example that we're going to kind of steal some code from

164
00:15:50,375 --> 00:15:55,325
你们可以看到，可以通过创建这种多线程控制台来创建一个新的控制台
you can see, that we create a new console by just kind of creating this kind of multi-threaded console 

165
00:15:55,325 --> 00:16:02,250
我们给它一个名字，那个名字以后也会很重要，因为它会被附加到每条消息的开头
we give it a name, and that names gonna be important later as well, because it's going to kind of be appended to the beginning of every message 

166
00:16:02,750 --> 00:16:08,650
然后我们可以有不同的类型，那么我要做的就是，创建两个控制台
and then we can kind of we have different varying types, so what I'm going to do is actually kind of we're gonna make two consoles

167
00:16:09,025 --> 00:16:16,875
一个用于客户端，一个用于实际的引擎，一个叫Core，另一个我想是我们的App控制台
one for the client, one for the actual engine, so call one core I guess, and one which will actually be kind of our app I guess console 

168
00:16:17,950 --> 00:16:25,100
显然，我们要把这些都抽象掉，这样就不会比调用像这样的成员函数好多了
and we're going to obviously abstract all this away, so that it's not a lot nicer than having to call like member functions like this 

169
00:16:25,750 --> 00:16:31,090
然后我们可能还会设置自己的格式选项，因为我们可以使用这个模式来设置
and then we're also gonna probably set our own formatting option, because we can actually use that pattern here to set

170
00:16:31,090 --> 00:16:35,825
我想是所有日志信息打印的格式
like I guess like a format for how all log messages will kind of get printed 

171
00:16:36,400 --> 00:16:42,150
那么让我们直接去实现那个，我要做的第一件事是跳出这个，创建一个init函数
so let's go ahead and do that, so the first thing I wanna do is I wanna get out of this, I'm gonna make an init function

172
00:16:42,150 --> 00:16:50,525
因为我们确实需要其中一个，然后我要创建一个inline static std::shared_ptr
because we definitely need one of those, and then I'm going to make an inline static std shared_ptr 

173
00:16:51,425 --> 00:16:57,125
我想它就是spdlog, spd类似logger或类似的东西
I think it's spdlog, spd like logger or something like that yep

174
00:16:57,125 --> 00:17:02,175
spdlog::logger会通过引用检查它，并且这是logger的一种输出
spdlog::logger will check that by reference and this will be kind of out for logger

175
00:17:02,175 --> 00:17:04,175
所以我们需要这样做，我们有我们的core logger
and so we'll have to do it, we'll have our core logger

176
00:17:04,450 --> 00:17:09,100
它会返回我们的，想一想，CoreLog，就在这儿创建
 which will return our, let's just see, CoreLog, which will make here 

177
00:17:09,100 --> 00:17:14,946
然后我们还有我们的客户端日志，也就是ClientLogger
and then we'll also have our client logger, ClientLogger

178
00:17:16,000 --> 00:17:26,625
你们可以想象，也就是s_CoreLogger和s_ClientLogger
which as you can imagine, I'm just going to end up being s_CoreLogger and s_ClientLogger

179
00:17:27,500 --> 00:17:34,225
还要包含memory.h，或者memory，这样我们就可以使用头指针，很好，那么我们继续
also include memory.h or just memory, so that we can use head pointers, okay, cool, so there we go 

180
00:17:34,225 --> 00:17:39,275
我们需要在这里设置一个日志和一个初始化函数，让我们到这里
we've got to kind of loggers set up here and an initialization function, let's go over here

181
00:17:39,418 --> 00:17:44,225
我们需要在实际的翻译单元中定义这两个
we'll have to define these two in our actual translation unit here

182
00:17:44,225 --> 00:17:51,625
所以我们会看到Log::s_CoreLogger和Log::s_ClientLogger，这是共享指针
so we'll see Log::s_CoreLogger and Log::s_ClientLogger, that is shared pointers here 

183
00:17:52,710 --> 00:18:02,925
并且这里是void Init()，我真的有点恼火，因为VS的格式在这里不起作用
and we'll have our void Init, I'm really kind of getting annoyed about visual studio water formatting not working here 

184
00:18:02,925 --> 00:18:15,025
让我试着构建这个，那么就是非静态的引用，当然，这些需要是静态的，再编译一次
let me just try and build this, okay, so the legal reference to Non-static, okay, yes of course, these need to be static, compile it again

185
00:18:15,200 --> 00:18:21,550
好了，很好，又成功了，我不确定这个智能感应或其他什么东西很烦人，有时是好的
okay, good, succeeded again, I'm not sure with this intellisense or whatever is going on is really annoying, sometimes it'll do

186
00:18:21,550 --> 00:18:26,375
但是不管怎样，好了，那么现在让我们创建这两个日志，好了
but whatever, okay, so now let's kind of create these two loggers that we actually have, okay

187
00:18:26,375 --> 00:18:32,425
那么我要做的第一件事是设置我们如何记录信息的模式
so the first thing that I want to do is actually set the pattern for kind of how we're going to actually log our messages 

188
00:18:32,425 --> 00:18:42,275
这就是格式，如果我们到这里，看看维基，我们进入自定义格式，你们可以看到
this is like the format, so if we go over here, and you go to I think the wiki, and we go into custom formatting, you can see 

189
00:18:42,275 --> 00:18:46,875
他们有一些关于如何使用这些模式的例子，还有一些标志
they've actually got examples of kind of how you can use these patterns, and a bunch of flags

190
00:18:46,875 --> 00:18:54,525
它说它将打印消息的哪一部分，使用这个，我之前准备了一个模式，基本上就是这个
which says like which part of the message it will print, and so using this, I've kind of prepared a pattern earlier, which is basically this

191
00:18:54,875 --> 00:19:01,200
那么这会使用正确的颜色，然后有时间戳，日志名，实际的日志消息
so this will kind of color it in the right way, then have the timestamp, and then have the name of the log, and then have the actual log message

192
00:19:01,200 --> 00:19:08,600
好了，那么我们只需要时间戳，日志的名字，不管它是core还是client
okay, so we're basically just having kind of the timestamp, the name of the logger, so whether or not is core or client 

193
00:19:09,350 --> 00:19:14,225
然后是我们实际的信息，所以它很简单，所有这些都会用正确的颜色包装起来
and then our actual message, so it's pretty simple, and all of that will be wrapped within the correct color for that 

194
00:19:14,350 --> 00:19:21,300
这些信息的严重性，所以现在我们已经完成了，可以开始创建这些，那么如果我们回到wiki
that kind of severity of message, so now that we've done that, we can actually start creating these, so if we go back to the wiki 

195
00:19:21,675 --> 00:19:29,670
或者只是仓库和例子，你们可以看到，他们所做的是创建这种stdout_color
or just the repository and laughter example, you can see that, what they do is they create this kind of stdout_color 

196
00:19:29,670 --> 00:19:46,230
然后是mt4多线程，那么继续写s_CoreLogger = spdlog::stdout_color_mt()，然后名字，好了
and then mt4 multi-threaded, so we're just going to go ahead and say  s_CoreLogger equals std sorry equals spdlog::stdout_color_mt(), and then the name, okay 

197
00:19:46,230 --> 00:19:51,050
对于这个，我们会叫它Hazel，好了，那将是我们的CoreLog
so for this, we're actually going to call it Hazel, okay, and that's going to be our CoreLog

198
00:19:51,925 --> 00:19:57,690
我们还会为客户创建一个，我将把这个叫做App，好了，就像那样的App
we're also going to make one for our clients, and I'm just gonna call this one App, okay, maybe App like that 

199
00:19:57,690 --> 00:20:03,780
实际上，我也要像这样创建Hazel，然后我还要设置用来打印消息的级别
in fact, I'm also going to make Hazel like this, and then I'm also gonna set the level of which we kind of print messages

200
00:20:03,780 --> 00:20:12,525
所以我认为应该是set_level之类的，我真的希望这能帮助我，我认为，确实是set_level
so I think if we just do like set_level or something, I really wish this would help me out, I think that level of the right yep set_level

201
00:20:12,525 --> 00:20:19,700
然后是实际的日志级别，VS一点用也没有，那么我们来看看它是什么
and then the actual log level, and again Visual Studio has just decided to not work at all, so let's just go here and see what it is 

202
00:20:19,700 --> 00:20:26,750
正如我们看见的spdlog::level::level，然后有一个level::enum，我认为trace是打印所有东西
as we see spdlog::level::level, and then we have a level enum which i think is sort of, trace is the kind of print everything

203
00:20:26,750 --> 00:20:31,600
所以我们像这样填入trace，然后对客户端做同样的事情，好了
so we'll just do trace like that, and then we'll do the same thing for clients, okay

204
00:20:31,925 --> 00:20:33,960
那么现在我们打印来自这两个日志的所有消息
so now we're printing all messages from both of these loggers

205
00:20:33,960 --> 00:20:39,500
或许我们也应该暴露这一点，这样我们就可以将级别设置成我们想要的样子
probably a good idea to also expose this, so that we can actually set our level to whatever we actually want it to be 

206
00:20:39,500 --> 00:20:45,950
但现在，我们将它保持在trace，我将按ctrl f7来编译这个文件，确保一切正常，好了
but for now, we'll just keep it at trace, I'll hit ctrl f7 to compile this file, make sure everything is fine, okay

207
00:20:45,950 --> 00:20:49,275
那么我们得到一个stdout_color_mt不是spdlog的成员
so we get a stdout_color_mt is not a member of spdlog

208
00:20:49,275 --> 00:20:58,250
我想我们实际上需要做的是包含另一个文件，也就是这个sinks文件
I think what we actually need to do is include another file, which is this sinks file

209
00:20:58,800 --> 00:21:03,480
那么让我们直接在CPP文件中包含这个，一切都编译成功了，好了
so let's go ahead include this just in cpp file, and there you go, everything compiled successfully,  alright

210
00:21:03,480 --> 00:21:07,722
那么现在我想在我们的客户端中使用这个东西
so now I want to actually use this stuff in our client

211
00:21:07,722 --> 00:21:14,175
那么我们能做什么呢，对吧，我暂时把这个作为一个测试实现，在Log::init中
so what we could do, right, and I will do this kind of as a test for now, in Log::init

212
00:21:14,450 --> 00:21:20,750
这个函数显然需要在某个地方被调用，那么我调用了什么，我不想在入口点调用它
this obviously this function obviously needs to get called somewhere, so what I got a call, I don't really want to call this in our entry point

213
00:21:21,000 --> 00:21:29,100
虽然我想现在我们需要一个系统初始化之类的函数
although I guess we will for now we do need to kind of have like a system initialization kind of function or something

214
00:21:29,400 --> 00:21:33,400
引擎实际上是初始化的，但现在，我还是会在这里调用这个
in which the engine actually is initialize, but for now again, I will call this in here

215
00:21:33,400 --> 00:21:36,750
这个会被包含到Sandbox中
this remember gets included into Sandbox

216
00:21:36,750 --> 00:21:45,759
那也是很重要的一点，但我想想，就是Hazel::Log::Init()，好了，如果我们进入Hazel.h
that's an important note to make as well, but I'll just see Hazel::Log::Init(), okay, and if we go into Hazel.h

217
00:21:45,759 --> 00:21:50,050
我当然会包含Log，所以我们会包含Hazel/Log.h
I will of course include Log yeah, so we'll do include Hazel/Log.h

218
00:21:50,475 --> 00:21:54,009
那么如果我现在构建我的Sandbox项目，这应该可以运行了
so if I build my Sandbox project now, this should work 

219
00:21:54,009 --> 00:21:58,050
并且如果我点击f5，它就会终止，为什么不呢
and if I hit f5, I think it'll just kind of terminate, why not

220
00:21:59,500 --> 00:22:03,350
我们可以在这里设置一个断点，然后点击f5，好了
let's maybe stick a breakpoint here, and hit f5, okay 

221
00:22:03,350 --> 00:22:10,450
现在我需要复制dll，我们真的需要做一个构建后置复制步骤，尽管我们将在下次做那个
now I need to copy the dll dll, we really need to make a post build copy step, we will do that next time though

222
00:22:11,325 --> 00:22:21,700
我要进入bin Debug Hazel, dll，复制到Sandbox中，然后f5，好了，那么它在提示这个存在
I'm going to go into bin Debug Hazel dll, copy into Sandbox for place, and f5, okay, so it's rotting this exists 

223
00:22:21,700 --> 00:22:25,475
但我忘记了，我们有那个死循环，Log，它似乎是工作的
but I forgot that we had that, that while true loop, Log it seems to work

224
00:22:25,475 --> 00:22:31,025
所以现在让我们尝试使用一些东西，来看看GetCoreLogger()
so maybe now let's try and use something, we'll see, GetCoreLogger()

225
00:22:32,125 --> 00:22:37,900
然后我想这只是一个warn，因为那应该是黄色的
and then I guess well it's just to a warn, because that should be out yellow

226
00:22:39,275 --> 00:22:47,409
我们将会看到initialized log，好了，然后我也会做同样的事情
will see initialized log, ok, and then I'm also going to do the same thing

227
00:22:47,409 --> 00:22:55,925
但对于客户端日志，我们会让另一个是info，那挺不错的，那么就打印hello吧
but with the client logger, and we'll make this just a what's another one info having that's great, so hello 

228
00:22:56,675 --> 00:22:59,625
我们应该从两个不同的记录器中得到两种不同的信息
so we should get two different kind of messages from two different loggers here

229
00:23:00,021 --> 00:23:01,800
好了，酷，那么你们可以看到，我们得到了一个黄色的信息
ok, cool, so you can see, we got a yellow message

230
00:23:01,800 --> 00:23:07,869
它说initialized log，来自Hazel，然后这来自App，我们得到一个hello，还有时间戳，很酷
it says initialized log, and it says that is from Hazel and then from App, we get a hello printing, and we also have the timestamp, which is cool

231
00:23:07,869 --> 00:23:13,100
那么log是如何完成的呢，这里有个问题，我不想每次都调用它，对吧
all right, so how log is basically done, now here's the issue, I don't want to call this every time, right 

232
00:23:13,100 --> 00:23:18,800
Hazel::Log::GetCoreLogger()，那真的很烦人，我想做的是创建宏
Hazel::Log::GetCoreLogger(), that's really kind of annoying, what I want to do instead is create and mouse macros 

233
00:23:18,800 --> 00:23:24,800
这让它很容易使用，所以我要做的是在外面，做一些定义
that make this really easy to kind of use, ok, so what I'm going to do is outside here, I'm gonna make a bunch of defines

234
00:23:24,800 --> 00:23:33,700
然后这个基本上是#define HZ_CORE，然后是严重程度，我不知道为什么这个已经在这里了
and then this basically going to just be define HZ_CORE, and then the log kind of severity, so I don't know why this is already kind of here 

235
00:23:34,000 --> 00:23:38,500
我不知道还有什么是不可能的，无论如何，我可能只是在我直播的某个时候打了这个关闭
I'm no idea what else that's can't be coming from, anyway, I probably just type that close sometime in my live

236
00:23:39,325 --> 00:23:46,300
那么就是HZ_CORE_ERROR(...)，对吧，因为我们会有很多参数
so what we'll say HZ_CORE and then error for example dot dot dot, right, because we're gonna have a very a number of arguments

237
00:23:47,299 --> 00:23:52,825
然后当它要调用Hazel::Log::GetCoreLogger()
and then when it's going to call Hazel::Log::GetCoreLogger()

238
00:23:52,825 --> 00:24:00,850
因为那是HZ_CORE_ERROR，然后我们会用error，然后__VA_ARGS__，对吧
because that's HZ_CORE_ERROR, and then we'll say error, and then __VA_ARGS__, right 

239
00:24:00,850 --> 00:24:05,700
也就是将宏中的变量参数转发给实际函数
which is just forwarding our variable arguments that we had in our macro to our actual function

240
00:24:05,700 --> 00:24:08,550
好了，也就是说，我们不会放分号之类的东西
okay, and that's that we're not going to put a semicolon or anything

241
00:24:08,550 --> 00:24:12,169
因为我们会在使用宏之后做，但基本上就是那样了，对吧
because we'll do that, after we use the macro, but that's basically it, right 

242
00:24:12,169 --> 00:24:16,600
如果你们想的话，可以把它包装在另一个宏中只在特定情况下才启用它
and if you wanted to, you could wrap this in another macro that only enabled it under certain circumstances 

243
00:24:16,600 --> 00:24:22,730
也许这是非常重要的，因为我们想在发行版本中去掉所有的日志消息
maybe well that would be definitely important, because we want to strip out all of our log messages in distribution versions

244
00:24:22,730 --> 00:24:27,500
显然，我们不想，我们不想浪费任何形式的性能日志消息到控制台
obviously, we don't want to, we don't, we don't want to be wasting any kind of performance logging messages to the console

245
00:24:27,500 --> 00:24:33,100
当我们发行实际应用时，那就可能是不可见的，但我们稍后会处理这个
that's probably not even going to be visible, when we distribute our actual applications, okay, but we'll deal with that later

246
00:24:34,300 --> 00:24:39,975
那么有了核心的error，我们可能会warn，info和trace，我想这就足够了
so we have core error, we'll do probably warn info and trace, I think is probably gonna be enough

247
00:24:39,975 --> 00:24:49,925
那么就是error，warn，info和trace，好了，那么trace就是trace，这个就是info
so error, warn, info, and a trace, okay, so trace will be trace, this will be info

248
00:24:50,825 --> 00:24:54,825
这儿还有一个fatal，但我现在要担心的是，这个warn
there's also a fatal one, but what I'm gonna worry about that I think now and warn

249
00:24:54,975 --> 00:25:02,725
让我们按照严重程度来组织这些，我们会用trace, info和error，实际上，还可以用fatal
let's kind of organize these in order of severity, so we'll do trace, info, one error, and in fact, you know, what I might as well do fatal

250
00:25:02,725 --> 00:25:09,275
因为我想我要用它来传达某种信息或者类似的东西，那么就是fatal
because I think I'm going to want to use that for a certain messages or something like that perhaps, so fatal

251
00:25:09,550 --> 00:25:14,400
好了，酷，我会很好地对齐这个，我想要使用Tab键之类的东西
okay, cool, and I will kind of just nicely aligned this, that I want to use tabs or anything

252
00:25:14,400 --> 00:25:21,000
因为那不能取决于你们Tab键的大小，让我们在这里使用空格键，以确保很好地对齐
because that can not work depending on your tab size, let's just use the spacebar here to make sure they're nicely aligned

253
00:25:21,200 --> 00:25:29,150
并且就有了所有的核心日志，我看看，就是Core log macros
and we have all of our kind of core log I will see, Core log macros

254
00:25:29,150 --> 00:25:34,700
好了，接下来，我们再实现一套客户端的，也就是Client log macros
okay, and then we're gonna do some client ones, so Client log macros

255
00:25:34,700 --> 00:25:37,999
那么我们要复制所有这些，唯一的区别就是
so we're gonna copy all of these, and the only difference is going to be the fact that

256
00:25:37,999 --> 00:25:47,900
他们没有说调用会完全去除那个，它只会在trace处有边缘所有这些，会像那样对齐这些
they don't say call will actually strip that entirely, it'll just be edges at trace and all that stuff, going to align these lips align these like that

257
00:25:48,550 --> 00:25:54,950
而不是CoreLogger，我将使用ClientLogger，好了，就那样，就得到了所有不同的Logger
and then instead of CoreLogger, I'm going to just use ClientLogger, okay, and that's it, there we go, we've got all of our different ones 

258
00:25:54,950 --> 00:26:00,650
但愿我没出什么错，对这两个都追踪一个小时的致命事件，看起来不错
I hopefully I didn't make any mistakes here, tracing for a one-hour fatal for both of these, looks great

259
00:26:01,575 --> 00:26:12,500
现在我要回到EntryPoint，并且这儿不是这个，你们可以看到，这里是HZ_CORE_WARN
now I'm just going to go back into our EntryPoint, and instead of this, now you can see, this is just going to come HZ_CORE_WARN

260
00:26:12,500 --> 00:26:17,425
对吧，然后把这个改成HZ_INFO，好了
okay, and then this just becomes HZ_INFO, okay

261
00:26:18,625 --> 00:26:23,300
我们只需要打印一个变量之类的东西来确保它是正常的
let's just print like a variable or something just to make sure that works

262
00:26:24,750 --> 00:26:28,725
int a = 5，好了，因为那也是可以运行的
int a equals five, okay, because that should work as well 

263
00:26:28,725 --> 00:26:34,950
当然，我们应该有一些变量消息这些变量类型的参数可以传递到这里
of course we should have variable messages of rather variable kind of arguments that we can actually pass in here

264
00:26:35,525 --> 00:26:41,525
点击f5，看看会发生什么，我们只修改了头文件，当然我们不需要复制那个dll，好了
let's hit f5, and see what happens, and we only modified the header files, of course we don't need to copy that dll, okay 

265
00:26:41,525 --> 00:26:43,725
好了，让我们看看，记录了，hello var = 5
there we go, let's see, log hello var equals five

266
00:26:43,725 --> 00:26:47,650
你们可以看到，一切正常，这很简单，现在看起来很好
you can see, everything works correctly, and it was really easy, and it looks really nice now 

267
00:26:47,825 --> 00:26:54,775
另一个明显的另一个要求是要有一个宏，我忘记说了，但我刚才做的是
and the other obviously the other requirement is being a macro, which I forgot to mention, but I kind of did just then was that 

268
00:26:55,325 --> 00:26:58,860
如果这不是一个宏，它就是一个总是被调用的函数，但如果它是一个宏
if this isn't a macro, it's a function that always gets called, but if it's a macro

269
00:26:58,860 --> 00:27:02,775
这意味着我们可以把它从发行版构建中去掉，所以如果我基本上说
it means we can strip it from distribution builts, so if I just basically say

270
00:27:03,075 --> 00:27:05,736
比如你们知道的，如果这是一个dist build
you know, if this is a dist build

271
00:27:06,550 --> 00:27:11,750
我可以把它定义为完全不同的东西，这意味着它会从实际的构建中剥离出来
I can define this to be nothing just like that, and that means that that gets stripped from the actual build 

272
00:27:12,450 --> 00:27:17,175
而且不在二进制文件里，也就是说不会把这个在发行版构建中运行，这是非常非常重要的
and it's not included in the binary,  which means that we're not running this in distribution builts, which is very very important

273
00:27:17,175 --> 00:27:23,375
那可能是主要的原因，不仅使我们的工作更容易，而且在需要的时候实际上可以剥离代码
that's probably the main reason not just to make our lives easier, but for actually stripping code out when required

274
00:27:23,375 --> 00:27:32,375
所以无论如何，那些确实是我们需要系统初始化之类的函数
so anyway, that's kind of that we do definitely need some kind of system initialization kind of function

275
00:27:32,375 --> 00:27:37,700
所以里面有Hazel或者Core之类的东西，我们下次肯定会讲到
so Hazel in it or something Hazel Core in it or something like that, we'll talk about that next time for sure 

276
00:27:37,700 --> 00:27:42,875
因为当我们开始初始化某些东西时，我们肯定不想在main函数中这样做
because as we start to initialize certain things, we definitely don't want to be doing this in the kind of main function  

277
00:27:42,875 --> 00:27:46,750
它被包含到我们的应用中，我们想在核心引擎中实现这个
that it gets included into our app we want to do that somewhere in the core engine 

278
00:27:47,700 --> 00:27:53,925
而且我也很讨厌dll不被复制，所以我想我们下次会改用构建系统
and then also I'm getting really sick of this kind of dll not being copied, so I think we're actually going to switch to using a build system next time 

279
00:27:53,925 --> 00:27:57,675
那应该很有趣，不管怎样，希望你们喜欢这个视频，如果喜欢，请给我点赞
that should be fun, anyway, hope you guys enjoyed this video, if you did, give me the like button

280
00:27:57,675 --> 00:27:59,775
我们现在有了一个很棒的日志库，我们可以实际使用
we've now got a great logging library that we can actually use

281
00:28:00,075 --> 00:28:03,200
那将是非常重要的，我想尽快把它放到那里
that's going to be really important, I wanted to get that in there as soon as possible 

282
00:28:03,200 --> 00:28:08,325
因为现在我们有了一种正确的方式来开始反馈实际主机上正在发生的事情
because now we have a proper way to start giving feedback as to what's going on to the actual console

283
00:28:08,325 --> 00:28:13,950
这对所有事情来说都非常有用，非常感谢所有让这一切成为可能的赞助人
which is gonna be just so useful for pretty much everything, huge thank there's always to all the patrons that make this possible

284
00:28:13,950 --> 00:28:21,925
链接是patreon.com/thecherno，可以帮助支持这个系列，它确实对我制作视频有帮助，没有你们，就不会有这些
patreon.com/thecherno is that link, you can help support the series, it really does help me kind of make videos, wouldn't be here without you guys

285
00:28:21,925 --> 00:28:26,425
非常感谢，你们将获得比这些视频中看到的更多的源代码
huge thank you, and you'll get access to much much more source code than you see in these videos

286
00:28:26,425 --> 00:28:34,230
因为在我做这些视频的时候，实际上也在一边写Hazel引擎，写得非常快
because as I'm kind of making these videos, I'm also actually writing the Hazel engine on the side and kind of as quick as I write it is as like

287
00:28:34,230 --> 00:28:39,450
那是你们得到的源代码，当我写的时候，可能会提交，赞助人会立即得到源代码
that's the source code that you get, so as I'm writing it and might be commits, patrons get that source code immediately

288
00:28:39,450 --> 00:28:45,800
所以如果你们有兴趣的话，一定要去看看，下次我们可能会使用一个构建系统
so definitely check that out, if you're interested, next time we're probably going to use finally switched using a build system

289
00:28:45,800 --> 00:28:49,600
因为首先，我想让这段代码在Mac和Linux上也能运行
because first of all, I want to start getting this code probably working on Mac and Linux as well

290
00:28:49,850 --> 00:28:53,225
因为我知道你们中有很多人在用那些OS
because I know there's a fair few of you guys who are using that

291
00:28:53,225 --> 00:28:59,350
就像我说的，我要写一种Windows，只是从我要实现Windows平台开始
as I said, I am gonna write a kind of Windows only to begin with in terms of the just I'm going to implement the Windows platform only

292
00:28:59,600 --> 00:29:05,000
引擎仍然是结构化的，支持多个平台，但我确实想要
the engine will still be structured in a way, that supports multiple platforms, but I do want to have

293
00:29:05,000 --> 00:29:08,575
因为人们会说，哦，我用的是Mac，我用的是Linux
like since people have been like oh but I'm using Mac, I'm using Linux

294
00:29:08,575 --> 00:29:14,250
一般来说，能够在Mac和Linux上轻松地构建这些代码是一个好主意
it is generally speaking a good idea to be able to build this code easily on Mac and Linux

295
00:29:14,250 --> 00:29:16,830
所以那就是我想要开始使用构建系统的原因
so that's why I want to start using a build system 

296
00:29:16,830 --> 00:29:23,100
并且我们也可以，我的意思是，一旦我们开始修改我们的项目文件通过添加很多包含部分
and also we can like, I mean you know, as soon as we start kind of actually modifying our project files by adding so many include parts 

297
00:29:23,400 --> 00:29:30,800
并且还有构建后置复制步骤，我们需要自动复制dll，而不是手动添加到VS中
and also like a post build copy step for example, which we need to copy that dll automatically, instead of adding that stuff to Visual Studio manually

298
00:29:30,800 --> 00:29:37,566
最好是把它放到一个实际的构建系统文件中，也就是配置文件
it's better to just finally dump that into an actual build system kind of file essentially a configuration file

299
00:29:37,825 --> 00:29:43,250
这样我们就不必在引擎和项目文件变得更复杂时复制所有内容
so that we don't have to, then copy everything across later as our engine and project files get more complicated

300
00:29:43,700 --> 00:29:47,284
不管怎样，希望大家喜欢这个视频，和往常一样，感谢大家的观看，我们下次见，拜
anyway, hope you guys enjoy this video, as always thank you for watching, I'll see you next time, goodbye

