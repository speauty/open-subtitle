1
00:00:00,166 --> 00:00:03,525
嘿，你们好，我是TheCherno，欢迎回到我的游戏引擎系列
hey, what's up guys, my name is TheCherno, welcome back to my game engine series

2
00:00:03,800 --> 00:00:10,325
那么上期我们添加glm并讨论了游戏引擎的数学库，如果还没看过的话，一定要去看看哦
so last time we added glm and talked about maths libraries in general for game engine, make sure you check out that video, if you haven't already

3
00:00:10,650 --> 00:00:15,875
今天我们要做一些ImGui调整，一些修复，实际上也就是给它添加一些新功能
and today we're going to be doing some ImGui adjustments, some fixes, some new features that we'll actually add to that

4
00:00:16,133 --> 00:00:21,475
实际上，我们将实现ImGui，在今天集成它的方式将变得更美好
and we'll actually our implementation of ImGui, the way that we've kind of integrated it in today's will change for the better

5
00:00:21,733 --> 00:00:27,725
这就像我想在我们真正开始运行渲染器之前，我想做的最后一个主要设置
and this is like kind of I think the last major setup that I kind of want to do before we actually start working on the renderer

6
00:00:27,725 --> 00:00:32,266
所以那就是我们要攻克Hazel的方向，我只想确保ImGui已经准备好了
so that's the direction where we're taking Hazel, I just want to make sure that ImGui's ready to go for all of that

7
00:00:32,266 --> 00:00:38,599
因为这是非常有用的，有一个很好的实现，那将帮助我们很多，当我们真正开始做渲染
because it's really useful to have a good inflammatation of that, that'll help us a lot when we actually start doing the render

8
00:00:38,600 --> 00:00:43,800
我们可以将ImGui中的各种东西结合起来，还可以使用自定义控件来表示数据
and we can tie in various things that ImGui as well as have custom controls that will represent data 

9
00:00:43,800 --> 00:00:46,425
那就像是从渲染和其他东西中得到的
that's coming in like from the render and all that stuff

10
00:00:46,425 --> 00:00:53,500
所以真的很重要，我迫不及待地想把这些激动人心的新特性都用ImGui移植到Hazel中
so it's really important stuff, and I really can't wait to get all this exciting new kind of features that ImGui into Hazel

11
00:00:53,800 --> 00:00:58,125
因此首先，我只想感谢所有在patreon.com/thecherno支持这个系列的朋友
so first of all, I just want to thank everyone who helps support the series on patreon.com/thecherno

12
00:00:58,566 --> 00:01:03,600
非常感谢这里的所有人，因为没有你们，这个系列就不会存在，所以非常感谢你们
huge thank you to everyone there, because this series just would not be here without you guys, so thank you so much

13
00:01:05,225 --> 00:01:09,050
对于支持，你们可以获得一些奖励，例如访问Hazel的开发分支
for supporting, you get certain rewards such as access to Hazel's development branch

14
00:01:09,050 --> 00:01:14,625
就是我实际上已经做了这些的分支，还有更多，事实上渲染基本是在那个分支中写完的
which is where I've actually already done all of this stuff and much much more, in fact the render is basically written in that branch

15
00:01:14,625 --> 00:01:17,950
我的意思是，就像所有的底层系统一样，所有这些东西都有一个渲染命令q
I mean it's like all of the lower level systems all of that stuff, there's a render command q

16
00:01:18,400 --> 00:01:24,950
该分支中已经实现了各种各样的渲染技术，请务必查看那些来帮助支持这个系列
there's various kind of rendering technologies already implemented in that branch, definitely check that out helps support the series

17
00:01:25,200 --> 00:01:31,775
很明显，我想，我们今天要做的ImGui之类的东西已经存在了一个多月了
and get access to stuff like that, obviously stuff like the ImGui stuff that we're gonna do today has been there, for like over a month I think

18
00:01:32,150 --> 00:01:35,500
所以如果你们想继续，不想只看这些视频
so if you kind of want to go ahead, and you want to just not just see these videos

19
00:01:35,500 --> 00:01:40,133
但实际上要获取一些为开发的源代码，所以一定要去看看那个
but actually get some get the source code as has been developed for a, so then definitely check that out

20
00:01:40,133 --> 00:01:42,625
通常你们会提前一周左右收到视频
and you'll also get videos like around a week early usually

21
00:01:43,366 --> 00:01:46,575
因此那也是帮助支持本系列的另一种好处
so that's also another kind of benefit that you get for helping to support this series

22
00:01:47,400 --> 00:01:53,366
好吧，不管怎样，我们今天要做什么，所以我们现在集成ImGui的方式是
alright, anyway, what are we doing today, so the way that we've integrated ImGui at the moment was

23
00:01:53,366 --> 00:01:59,100
我在ImGui一期中谈了很多，也许再看一遍，只是为了让你们有个想法
and I talked a lot about this in the ImGui episode, maybe watch that again, just so that you get kind of an idea 

24
00:01:59,100 --> 00:02:04,825
因为你们知道，这是软件工程，我们经常改变方向，改变想法
because you know, this is software engineering, we change direction, we change our minds quite often

25
00:02:05,450 --> 00:02:09,825
我说我并没有准备好在github上运行游戏引擎
and I said like it's not like I have a game engine ready to go on github

26
00:02:09,825 --> 00:02:15,925
现在我突然决定对我知道的每一步都做一系列的准备，我们在一起发展
and now suddenly I've decided to make a series of every step that I'd know, we're developing this together as we go along

27
00:02:15,925 --> 00:02:21,466
那就是为什么我制作了那期视频，但github的问题和所有这些东西，以及如何提交PR
that's why I made that video, but the github issues and all that stuff, and how to kind of submit pull requests

28
00:02:21,466 --> 00:02:25,000
我已经好几个星期没看了，顺便说一句，我真的需要重新开始
which I haven't even looked at in weeks, by the way, I really need to get back on that

29
00:02:25,275 --> 00:02:31,566
但不管怎样，嗯，因为所有那些，就像这是一个严肃的事情，随着我们的发展，那意味着
but anyway um, because of all that, like this is a serious thing developed as we go along, which means that that's like

30
00:02:31,566 --> 00:02:35,650
也许有一天早上醒来，我会觉得你们知道我们几个星期前做了什么，那是垃圾，那就扔了
I might wake up one morning, and be like you know what that thing that we did a few weeks to go, that's rubbish, let's crap it

31
00:02:36,000 --> 00:02:41,325
这并不是真正的案例之一，在某种程度上你们可能会看到，就是那样
and this isn't really one of the cases, this like in a way maybe you might see that it is

32
00:02:42,025 --> 00:02:48,300
因为我们在这方面的想法有点改变，但最终我很高兴我们有了ImGui的最初实现
because we are kind of changing our minds a little bit on that, but ultimately I'm glad that we had that initial implementation of ImGui

33
00:02:48,300 --> 00:02:53,350
因为这那让我向你们展示了一种我们可能想要自己实际实现它的方法
because that kind of allowed me to show you a way that we might want to actually implement it ourselves

34
00:02:54,333 --> 00:02:59,225
但由于我马上就会讨论如何使用ImGui的这些新特性
but because of the of these kind of new features that I'll talk about in a minute to do with ImGui

35
00:02:59,500 --> 00:03:04,000
只是，我觉得我们用稍微不同的方式做这件事要容易得多
it's just, I think it's just a lot easier for us to just kind of do it a slightly different way

36
00:03:04,600 --> 00:03:11,050
这与他们的代码有着更少的分歧，因为我们最终所做的
which is gonna be more kind of to do with like less divergence from their code, because what we ended up doing

37
00:03:11,050 --> 00:03:14,850
让我们跳过去看一看，我给你们复习一下
let's just jump across and take a look, and I'll give you guys a bit of a refresher

38
00:03:14,850 --> 00:03:20,125
所以当ImGuiLayer我们最终做了很多我们在这里做的事情是受到启发的
so when ImGuiLayer what we ended up doing was a lot of this stuff that we did here was inspired

39
00:03:20,500 --> 00:03:22,825
对吧，我们把它和Hazel事件联系起来了
right, we kind of hooked it up with Hazel events

40
00:03:22,825 --> 00:03:29,000
所有这些东西都是受到Hazel的启发，我很抱歉ImGui实际上做了什么
all of this stuff was kind of inspired by what Hazel, I'm sorry what ImGui actually did

41
00:03:29,000 --> 00:03:38,566
所以这个ImGuiOpenGLRenderer.h，就是我们实现的，基本上是他们自己的一个文件，对吧
so this file ImGuiOpenGLRenderer.h, which we kind of you know implemented, this is basically you know one of their own files, right

42
00:03:38,566 --> 00:03:46,789
我们所做的不是使用ImGui的GLFW实现，所以如果我们真的看看ImGui
and what we've kind of done is instead of kind of use the GLFW implementation of ImGui, so if we actually have a look at ImGui

43
00:03:46,789 --> 00:03:54,550
让我把Hazel折叠一下，如果看一下ImGui，我想如果真的去看这里没有包含的东西
let me just collapse Hazel, if we have a look at ImGui, I think if we actually go to the things properly not included here

44
00:03:54,866 --> 00:04:01,550
如果我们真的走到这里，去看看你们知道的GLFW的例子，也就是你们知道的opengl3
if we actually go here, and go to examples you know GLFW, which is here opengl3 you know

45
00:04:02,450 --> 00:04:07,054
这实际上是出于某种原因在这里实现的，glfw在哪里
which is actually implemented here for some reason, where is it glfw

46
00:04:07,825 --> 00:04:11,750
所以我们有opengl3，有glfw，对吧，所有这些东西，对吧
so we have opengl3, there's glfw, right, so all of this stuff, right

47
00:04:12,300 --> 00:04:20,725
这类东西，我们从这个文件中提取出来，实际上包含在我们自己的ImGuiLayer中，对吧
this kind of stuff, we kind of took from this file and actually included into our own ImGuiLayer, right

48
00:04:20,800 --> 00:04:26,366
基本上是通过类似事件调度的方式，所以鼠标按下，你们知道我们做了这种事情，现在很好
via like event dispatching essentially, so mouse press you know we did this kind of stuff, now that's great

49
00:04:26,500 --> 00:04:32,500
但问题是，这变得越来越复杂，例如ImGui正在新增的特性
but the problem is this is becoming more and more complicated, like ImGui is growing like for example the features

50
00:04:32,500 --> 00:04:35,600
让我们把这个往前说一点，然后讨论一下特性
let's actually dial this back a little bit, and talk about the features

51
00:04:35,600 --> 00:04:39,325
我们会想，为什么我们要做这个ImGui的事情，以及我们将从中获得什么
that we're going to be like why are we doing this ImGui thing, and what we're actually going to gain from that

52
00:04:39,666 --> 00:04:48,325
因此，在我看来，ImGui最近关注的是一些太重要、非常重要的事情，需要添加到ImGui中
so ImGui lately has kind of focused on too important, very important in my opinion kind of things to actually add to ImGui

53
00:04:48,466 --> 00:04:54,100
那就是停靠，也叫视口，所以停靠就是能够停靠窗口，对吧
and that is docking, and also something called viewport, so docking is just being able to dock windows, right

54
00:04:54,100 --> 00:04:58,950
就像看一下Visual Studio一样，你们知道，可以移动标签并将其固定到任何想要的窗口中
like if we have a look at Visual Studio, you know, we can rip off tabs and dock them into like any window we want

55
00:04:58,950 --> 00:05:02,675
比如这里我们可以创建这个，如果这里有团队资源管理器
like here for example we can create this, you know if we have team explorer here 

56
00:05:02,675 --> 00:05:07,650
我们可以把这个固定在这里，或者单独抓住那个标签，把它固定在这里
we can like just dock this here, or grab that tab individually and like dock it up here

57
00:05:07,925 --> 00:05:13,700
你们知道，我们可以做整个停靠的事情，对吧，ImGui实际上已经添加了那个
you know, we have this whole docking thing that we can do, right, ImGui has actually added that to ImGui

58
00:05:14,066 --> 00:05:19,899
这样你们就可以像停靠空间一样组织窗口，然后在其中可以有多个选项卡
so that you can actually organize your kind of window as like a dock space, and then in there you can have multiple tabs

59
00:05:19,900 --> 00:05:25,350
可以随意停靠它们，那真的很重要，因为我想为Hazel做的一件事就是有一个关卡编辑器
you can dock them however you like, that's really important, because one of the things that I want to do for Hazel is have a level editor

60
00:05:25,566 --> 00:05:30,350
我希望将其内置到运行时中，因为我们没有足够的资源来构建完整的应用栈
and I want that to be kind of built into the runtime, because we don't really have the resources to build a full application stack

61
00:05:30,350 --> 00:05:35,800
每一次，这都会让一切变得更加容易，并且也会与之相联系
and every time of that, and this is going to make everything so much easier, and to tie into that as well

62
00:05:35,800 --> 00:05:41,200
视口是他们制作的东西，基本上可以从ImGui中获取窗口
viewports is something that they've made, which basically enables you to grab a window from ImGui

63
00:05:41,200 --> 00:05:48,150
然后把它拖到主应用窗口之外，我会马上创建一个新窗口
and drag it outside of your primary kind of application window, and I'll actually kind of just on the fly create a new window

64
00:05:48,150 --> 00:05:51,466
新的渲染所有内容，它的行为有点像那个窗口
new rendering contacts and everything, and it'll act kind of like that window

65
00:05:51,466 --> 00:05:56,250
我们将看到，总之，我们将看到所有这些都在发挥作用，这可能是一期很长的视频
and we'll see that, at the end of today, we'll see all of that kind of working, this is probably gonna be a long episode

66
00:05:56,775 --> 00:06:03,000
无论如何，在我看来，这两个特性确实有助于使ImGui在
anyway, those two features in my opinion are like really help make ImGui very viable for just

67
00:06:03,000 --> 00:06:10,350
我们不需要任何其他UI框架，比如WPF，WindForms，Qt，无论什么，都不需要那些
we don't need any other like ui kind of framework, lik WPF you know windforms qt, whatever we don't need any of that

68
00:06:10,350 --> 00:06:16,533
因为我们可以直接使用ImGui，这两个特性让它变得更好，所以我对此感到非常兴奋
because we can just use ImGui, and these two features make it so much better, so I'm really excited about that

69
00:06:16,533 --> 00:06:19,766
但不管怎样，因为我们有这些功能和它们相当高级的功能
but anyway, because we have those features and their fairly advanced features

70
00:06:19,766 --> 00:06:25,335
特别是像能够动态创建窗口之类的东西，我不想实现所有那些
especially like being able to create windows on the fly and all of that stuff, I don't want to implement all that

71
00:06:25,335 --> 00:06:28,600
那不是本系列的内容，对吧，我不想实现和维护那个
that's not what the series is about, right, I don't want to have to implement that and maintain it

72
00:06:28,600 --> 00:06:35,250
因为ImGui的停靠分支，这是所有这些东西的所在，它实际上还没有被合并到master中
because the docking branch of ImGui, which is where all this stuff is, it hasn't actually been, it hasn't been merged into master yet

73
00:06:35,533 --> 00:06:38,550
这仍在开发中，他们可能会随着发展而改变
it's still kind of in development, they might change things as they go along

74
00:06:38,966 --> 00:06:46,100
所以我想做的就是使用它们的实现，比如imgui_glfw_implementation，和OpenGL渲染那些
so what I want to do is just use their implementation, like there imgui_glfw_implementation, there are OpenGL rendener all of that stuff

75
00:06:46,333 --> 00:06:52,650
像bin一样，可能会原样出现，没有任何变化，没有分歧，包含在Hazel和runner中
like verbadin might come as it is without any changes no divergence at all just included in Hazel and runner

76
00:06:53,075 --> 00:06:55,625
这样我们就可以很容易地合并他们所做的任何更改
that way we can easily merge any changes they make

77
00:06:55,625 --> 00:06:58,950
接下来的时间不会是ImGui更新的大约一个小时
and going forward this isn't gonna be about hour ImGui's got an update

78
00:06:58,950 --> 00:07:02,250
让我们花一天的时间来维护它，并更新所有代码以实现那个
let's spend a day like maintaining that, and updating all of our code to do that

79
00:07:02,250 --> 00:07:08,225
不，这就像你们知道的拖放一样，而且很有效，所以那就是我真正想做的
no, it'll just be like kind of just you know drag and drop kind of and it works, so that's what I really wanna do

80
00:07:09,066 --> 00:07:13,900
那就是我们今天要做的，好吧，这是一个相当大的小项目
and that's what we're gonna kind of do today, okay, it's quite a large little project

81
00:07:14,366 --> 00:07:17,250
我们实际上需要做很多改变，尤其是一个ImGuiLayer
there's a bunch of changes that we actually have to make, especially an ImGuiLayer

82
00:07:17,550 --> 00:07:20,875
事实上，我昨天做了这件事，我想是前一天，只是用了一种不同的方式
I actually did this I think yesterday, all the day before just in a different kind of

83
00:07:20,975 --> 00:07:26,675
我克隆了仓库，然后自己又克隆了一次，所以我们来看看这两者之间的区别
I cloned the repository and did it again kind of myself, so we'll kind of take a look at the diff between that

84
00:07:26,675 --> 00:07:31,725
我什么都没做，我知道你们喜欢直播，所以我要做的是看看不同，因为已经做了这项工作
I haven't done anything, I know you guys like live coding, so what I'll do is I'll take a look at the different, because I've already done this work

85
00:07:31,725 --> 00:07:35,400
我必须提前做，否则在这期视频中会花费太长时间
I had to do it ahead of time, otherwise it would have just taken too long in this video

86
00:07:35,733 --> 00:07:41,425
但我们会看一下差异，我们会逐行合并它，实际上我们会看到它是什么样子的
but we'll have a look at the diff, and we'll kind of merge it in line by line, and actually we'll see what it will look like

87
00:07:41,425 --> 00:07:47,366
所以我会复制粘贴和代码，但我现在所处的位置，我打开的项目
so I will be copying paste and code,  but this kind of where I'm at right now, the project I have open

88
00:07:47,366 --> 00:07:49,926
只是没有任何这些更改，将手动将它们拉入
just does not have any of these changes, will pull them in manually

89
00:07:50,275 --> 00:07:53,800
所以让我们看看这个，我们会看到，我们如何进行
so let's take a look at this, and yeah we'll see, how we go

90
00:07:54,100 --> 00:08:00,350
好了，这就是所有的，这是一个完全没有任何内容的仓库，如果我们现在就启动它
okay, so this is all the kind of, this is a repository with absolutely nothing, if we just launched this right now

91
00:08:00,350 --> 00:08:06,250
这样你们就可以看到我们所处的位置了，一旦它编译好了，你们就会看到有了标准的ImGui
so that you guys see where we're at, once it compiles, okay, you'll see we have our kind of standard ImGui thing

92
00:08:06,500 --> 00:08:10,650
我们可以把它拖来拖去，很明显，如果我们来到外面，你们会看到窗口没有出去或什么的
we can drag this around, obviously if we go outside, you can see the window does not go outside or anything

93
00:08:10,650 --> 00:08:17,750
所以这实际上是我们的基本实现，我想做的第一件事就是看看github
so this is in fact the kind of base implementation that we had, the first thing I wanna do is actually take a look at github

94
00:08:18,200 --> 00:08:23,950
所以我在ImGui的分支中有什么，除了主分支之外，这是我们目前所在的分支
so what I have here in my fork of ImGui, apart from just master being, which is the branche that we're currently on

95
00:08:23,950 --> 00:08:30,475
现在还有一个docking分支，它存在于实际的ImGui仓库中，对吧，docking就在这里
there's also this docking branch right now, this exists in the actual ImGui repository, right, docking here it is

96
00:08:30,900 --> 00:08:35,900
这实际上正在进行中，就像九天前和两天前的提交，这实际上正在积极进行中，对吧
and this is actually being worked on, like nine and two days ago was lust commit, this is actually being actively worked on, right

97
00:08:37,166 --> 00:08:45,325
我在15天前添加了premake文件，在这里也添加了premake文件，几乎就是三明治
so what I did is I added my premake file to like 15 days ago, you can see I added that premake file here as well, it's pretty much the sandwiches

98
00:08:45,325 --> 00:08:51,375
我还必须将premake添加到docking分支，因为实际上要从使用master切换到docking
I had to also add the premake file to the docking branch, because we're actually going to switch from using master to docking

99
00:08:51,775 --> 00:08:58,425
因此，我们需要做的第一件事实际上是打开一个命令提示符，我们将去切换那个
so the first thing we need to do then is actually open up a command prompt, and we're going to go and switch that

100
00:08:59,025 --> 00:09:03,225
我们有作为git子模块的ImGui，但目前有些主模块
we have ImGui as a git submodule, but currently some master

101
00:09:03,225 --> 00:09:07,561
事实上，如果我们使用它，那么Hazel/vendor/ImGui
in fact if we kind of go to it, so Hazel/vendor/ImGui

102
00:09:08,400 --> 00:09:13,225
如果我们执行git status，你们会看到我们在master上，对吧，在ImGui中
if we do a status, you'll see that we're on master, right, inside ImGui

103
00:09:14,200 --> 00:09:19,750
现在是origin master的最新，无论是否在master分支上，都需要切换到docking分支
and you know it's up to day with origin master whatever we're on the master branch, we need to switch to the docking branch

104
00:09:19,750 --> 00:09:25,000
所以我们这样做对于一个子模块来说很容易，只需切出docking分支，对吧
so the way we do that is very easy for a submodule, we just check out the docking branch, right

105
00:09:25,900 --> 00:09:27,800
然后必须进入一个目录
and then we have to go up a directory

106
00:09:28,566 --> 00:09:33,875
如果我们执行git status，你们会看到我们有ImGui，其中有新的提交跟踪内容
and if we do our status looks if we do our status, you'll see we have ImGui with new commits on track content

107
00:09:34,166 --> 00:09:41,250
因此，我们要做的是，我们只需提交，抱歉，我们只需将ImGui添加到我们的git中
so what we'll do is we'll just commit, sorry we'll just add that ImGui thing into our kind of into git

108
00:09:41,250 --> 00:09:47,550
对吧，那么现在实际发生的是，我们已经将分支切换到docking，现在将对其进行跟踪
right, so now what will actually happen is the fact that we've switched branch to docking, that'll be now tracked

109
00:09:47,900 --> 00:09:50,425
所以在那种情况下，你们知道我们基本上做完了
and so in that case you know we've basically done that

110
00:09:50,425 --> 00:09:54,500
所以总结一下，要切换它，需要将模块切换到不同的提交或不同的分支
so to summarize to switch it gets up module to a different commit or to a different branch

111
00:09:54,766 --> 00:10:02,375
你们要做的就是进入那个目录进行git checkout，然后提交那个目录，对吧，好吧，酷
what you have to do is actually go into that directory do a git checkout, and then commit that directory, right, okay, cool

112
00:10:02,625 --> 00:10:08,009
我认为ImGui甚至不需要反转控制的ni文件，无论如何，我们可以做很多事情
I don't think ImGui even needs to be inversion controlled ni file, anyway, there's a bunch of things that we can

113
00:10:08,009 --> 00:10:13,150
我们可能很快就会有一期维护视频，因为我认为有些东西在仓库中是错的
we'll probably have a maintenance episode soon, because I think that some things are just not right in the repository

114
00:10:13,533 --> 00:10:19,534
总之，现在我们已经完成了，并且我们已经将该分支切换到docking，应该可以开始了
anyway, now that we've done that, and we've switched that branch to docking, that should be ready to go

115
00:10:19,534 --> 00:10:21,525
对吧，所以我们实际上可以访问所有那些
right, so we actually have access to all of that

116
00:10:21,850 --> 00:10:26,302
所以现在我们需要做的是将所有的东西切换到与docking分支一起运行
so now what we need to do is switch all of our stuff to actually work with that docking branch

117
00:10:26,700 --> 00:10:32,300
现在是这样，我们需要两个新文件，对吧，如果我打开Hazel想去Sandbox，是的
now here's the thing, we need two new files, right, if I open up Hazel want to go Sandbox, yes

118
00:10:32,300 --> 00:10:35,850
例如，vendor被忽略，因为当时，无论如何，我们现在不讨论那个问题
the vendor for example think is ignored because of then, anyway, we won't talk about that now

119
00:10:36,266 --> 00:10:40,225
那么就是Hazel/vendor/ImGui，如果现在在docking分支上，对吧
so Hazel/vendor/ImGui, if this is now on the docking branch, right

120
00:10:40,666 --> 00:10:49,375
这里面有一些例子，你们知道我们有opengl3文件，我认为我们现在需要编译
so this has inside examples, you know we have you know that opengl3 file, I think that we now need to compile

121
00:10:49,800 --> 00:10:56,775
还有另一个是什么，glfw，对吧，这两个文件现在需要编译
and also what was the other one, the glfw one, right, these two files actually need to now be compiled

122
00:10:57,133 --> 00:11:02,866
我能做的是我可以把它们添加到premake中，然后像那样编译它们，但实际上我不会那么做
what I could do is I could just add them to premake, and have them be compiled like that, but I'm actually not going to do that

123
00:11:02,866 --> 00:11:08,175
实际上，我要在Hazel中创建一个文件，它只包含它们和它们的编译，我要调用那个文件
I'm actually going to make a file inside Hazel, that just includes them and compiles of them, and I'm going to call that file

124
00:11:08,175 --> 00:11:12,475
我将确保我处于显示所有文件模式，我将在ImGui中创建那个文件
I'll make sure that I'm in show all files mode, I'm going to create that file inside ImGui

125
00:11:14,166 --> 00:11:21,025
我将创建一个新项，就是一个cpp文件，我将其命名为ImGuiBuild.cpp，好了
I'll make a new item, it'll be a cpp file, I'll call it ImGuiBuild.cpp okay

126
00:11:21,400 --> 00:11:27,700
然后在这里，我实际上要包含所有需要从ImGui构建的文件，好了
and then over here, I'm actually going to include all of the files that I need to actually build from ImGui, okay

127
00:11:27,700 --> 00:11:35,150
因此，我要做的第一件事是包含pch文件，然后我将实际包含我们要编译的所有文件
so the first thing I'll do is I'll include the pch file, and then I'm going to actually include all of our files that we want to compile

128
00:11:35,575 --> 00:11:42,878
因此，从ImGui中，也就是examples，我们有GLFW文件，所以cpp文件不是h文件，对吧
so from ImGui, which is examples, we have the GLFW one, so the cpp file not the h file, right

129
00:11:43,725 --> 00:11:54,025
还有OpenGL，所以就是examples/imgui_impl_opengl3.cpp，好吧，在这里构建一点工具
and then also the OpenGL one, so examples/imgui_impl_opengl3.cpp, okay, so we've got like a little bit of a unity built here

130
00:11:54,400 --> 00:11:59,350
现在的问题是，这个opengl3文件需要一些opengl头文件
now the thing is, this opengl3 file needs some kind of opengl header file

131
00:11:59,466 --> 00:12:04,650
就像他们所说的加载程序一样，我们使用的是glad，所以我要做的就是在包含它之前定义它
so like a loader as they call it, we're using glad, so what I'm gonna do is just define that before we include it

132
00:12:05,133 --> 00:12:11,200
定义它，我们使用glad，好了，现在如果我们点击ctrl f7来编译这个
so define that, we're using glad, okay, so now if we hit ctrl f7 to compile this

133
00:12:11,200 --> 00:12:16,425
我们应该在这里编译所有符号，你们可以看到我们做得很好，我们成功了
we should basically get all of our symbols compiling here, and you can see we do okay, there we go one succeeded

134
00:12:19,100 --> 00:12:27,475
我们有crt安全警告，我们应该在实际构建文件中定义，但关键是我们成功了，对吧
yeah we have crt secure no warnings, we should be defined in our actual build file, anyway, but the point is there we go succeeded, right

135
00:12:27,475 --> 00:12:32,450
现在这包含了我们从这两个文件中需要的所有符号，这是手动编译的
so this is now contains all of the symbols that we need from those two files, which is compiling them manually

136
00:12:32,450 --> 00:12:39,175
因此，我们不必将它们实际签入ImGui，因为我想让Hazel实际控制一些东西
so we don't have to actually check them into ImGui, because again, there's something that I want Hazel to actually control

137
00:12:39,933 --> 00:12:45,525
好了，继续，ImGui现在正在编译，我们有了停靠和几个端口所需的所有其他东西
so there we go, ImGui's now compiling, we have all the additional stuff that we need for docking and for the few ports things

138
00:12:45,525 --> 00:12:51,825
这是docking分支的一部分，现在我们可以基本上摆脱ImGuiLayer，或者至少改变它
this is part of the docking branch now, now we can actually get rid of ImGuiLayer basically, or at least change it

139
00:12:51,825 --> 00:12:56,450
那与我们的情况不同，所以如果我打开我对ImGuiLayer所做的更改
so that it's not like what we have, so if I open up the changes that I've actually made to ImGuiLayer

140
00:12:57,133 --> 00:13:01,122
我做的第一件事就是把这些东西都删掉，对吧，我们不需要这些事件
the first thing I did was I got rid of a lot of these things, right, we don't need any of these events

141
00:13:01,266 --> 00:13:06,700
那么让我们到这里来，删除所有这些事件，对吧，继续，我们实际上会删除OnEvent
so let's go over here, and just delete all these events, right, go on, and we'll actually delete OnEvent

142
00:13:07,100 --> 00:13:12,125
OnUpdate实际上不需要存在，我们将用名为OnImGuiRender的方法来替换它
OnUpdate doesn't really need to exist, we're going to replace it with something called OnImGuiRender

143
00:13:12,573 --> 00:13:15,250
我真的不喜欢这儿的另一个东西，我不知道我是如何编写这段代码的
the other thing that I really don't like here, I don't know how I wrote this code

144
00:13:15,250 --> 00:13:17,800
但很明显，这些都是重写虚函数
but obviously these are overriding virtual functions

145
00:13:18,000 --> 00:13:24,625
所以我喜欢将它们标记为虚函数，这是可选的，但更重要的是，应该将它们标记为重写
so I like to mark them as virtual, which is optional to stylistic choice, but more importantly, there really should be marked as override

146
00:13:24,933 --> 00:13:27,950
只是为了说明它们实际上是我们重写的虚函数
just to make it clear that they're actually virtual functions that we're overriding

147
00:13:29,000 --> 00:13:32,775
我们将引入一个名为OnlmGuiRender的新函数，稍后我们将讨论那个函数
we're going to introduce a new function called OnlmGuiRender, which we'll talk about a little bit later

148
00:13:33,366 --> 00:13:36,725
但现在那就是我们所需要的，所以cpp文件发生了什么变化
but for now that's all we need, so the cpp file what has changed

149
00:13:38,425 --> 00:13:44,975
所以我们将包含这些内容，而不是OpenGLRenderer
so we're including this stuff instead of that OpenGLRenderer

150
00:13:45,300 --> 00:13:51,871
所以，让我们继续，只是加入这些包含，我们根本不需要这个OpenGLRenderer文件
so let's go ahead and just bump in those includes, we don't need this OpenGLRenderer file at all

151
00:13:52,200 --> 00:13:55,300
所以在platform/OpenGL中，我们有ImGuiOpenGLRenderer
so inside platform/OpenGL, we have ImGuiOpenGLRenderer

152
00:13:55,300 --> 00:14:00,250
基本上是这个文件的副本，对吧，opengl3文件
this was basically a copy of this file, right, the opengl3 file

153
00:14:00,366 --> 00:14:05,975
所以我们不知道我需要这个多久，我要过去把它们删除，确保你们从光盘中删除它们
so we don't know how long I need this, I'm going to go over here and just delete them, make sure you delete them of course from disc

154
00:14:05,975 --> 00:14:12,525
现在它们不见了，好吧，我们在platform/OpenGL文件夹中什么都没有，所以那是第一步
and now they're gone, okay, so we have nothing inside that Platform/OpenGL folder, so that's the first step

155
00:14:13,566 --> 00:14:17,825
那么我们要做的是，在这种情况下，我的意思是我已经复制了很多
then what we have to do is, well in this case, I mean I've pretty much copied

156
00:14:18,325 --> 00:14:19,600
我所做的是我已经复制了很多
what I've done is I've pretty much copied

157
00:14:19,600 --> 00:14:29,400
我想OpenGL已经完成了，也许他们有一个停靠的例子，我想它就是是这个main文件
what I'm going had inside, I think OpenGL's through, maybe they had like a little bit of a docking example, I think it was this main file even maybe

158
00:14:30,225 --> 00:14:36,150
那只是因为你们知道他们实际上做了很多事情，所以基本上我所做的就是复制那些
that just had like you know a bunch of stuff that they actually did, so basically what I did was like copied that

159
00:14:39,050 --> 00:14:43,625
我复制了它并把它放在这里，所以放在我们的ImGui类的OnAttach中
I copied that and put it over here, so into our ImGui kind of OnAttach

160
00:14:43,625 --> 00:14:46,000
所以我将复制这里的所有代码
so I'll grab all of this code that I've got here

161
00:14:46,933 --> 00:14:51,775
并且那就是OnAttach函数的基本情况，这些函数不需要进行按键映射
and that's basically what's happening with the OnAttach functions, this stuff where the key map doesn't need to be done

162
00:14:52,025 --> 00:14:57,366
因为那将在这个glfw文件中完成，对吧，在这里，你们可以看到
because that is now going to be done inside this glfw file, right, which is over here, so you can see

163
00:14:57,733 --> 00:15:01,375
让我们找到，好了，这是按键映射的东西，所以我们根本不需要担心那些
let's find that, there we go, there's the key map stuff, so we don't need to worry about that at all

164
00:15:01,666 --> 00:15:09,766
那只是他们编写的ImGui实际代码的一部分，这很好，而我在ImGuiLayer的cpp文件中
that's now kind of just part of ImGui's actual code that they've written, which is great, while I'm in the cpp file for ImGuiLayer

165
00:15:09,766 --> 00:15:15,150
我会把我们所有的东西都删掉，好了，然后继续到OnAttach
I'll just get rid of all this stuff that we have, okay, and then so on to OnAttach

166
00:15:15,150 --> 00:15:18,525
我会把我复制的代码粘贴进去，好了，完成了
I'll just paste in the code that I've copied, okay, done

167
00:15:19,700 --> 00:15:26,350
现在OnDetach，我不确定我们是否，好了，所以我们只想基本上关闭并销毁上下文
now OnDetach, I'm not sure if we, okay, so we just want to do basically shutdown stuff and destroy context OnDetach

168
00:15:28,066 --> 00:15:35,925
然后在里面，然后我做的另一个是添加了两个函数，叫做Begin和End，对吧
and then inside, okay, and then the other thing that I've done is I've added two functions called begin and end, right, void begin void end

169
00:15:36,375 --> 00:15:39,200
所以我们只需要添加那些，以及它将要做什么
so we'll just add those, and what that's gonna do

170
00:15:39,200 --> 00:15:44,825
我之所以那样做，是因为我希望层实际上能够执行自己的ImGuiRenderer，对吧
and the reason I've done that is because I want layers to actually be able to do their own ImGuiRenderer, right

171
00:15:45,266 --> 00:15:52,869
我希望他们能够写类似ImGui::Begin和ImGui::End的函数，这样他们就可以打开一个新窗口
all I want them to do is be able to write something like ImGui::Begin, ImGui::End, so that they can actually begin a new window

172
00:15:52,933 --> 00:15:58,434
然后只渲染一个控件和所有那些东西，那也是ImGuiRender的用武之地
and then just render a control and all of that stuff, and that's also where that ImGuiRender comes in

173
00:15:58,733 --> 00:16:04,875
因此，因为我们希望在这种功能中包含类似的层，这样它们就可以轻松地渲染窗口
so because we want to enclose like layers in that kind of functionality where they can just easily render a window

174
00:16:05,300 --> 00:16:10,900
我们需要实际开始和结束窗口渲染，并通过开始窗口渲染
we need to actually begin window rendering end window rendering, and by beginning and window rendering

175
00:16:11,175 --> 00:16:17,425
我的意思是开始一个结束的ImGui渲染，所以如果我们看一下代码，那实际上就是开始-结束
I mean begin an end ImGui rendering, so if we look at the code, that's actually even beginning end

176
00:16:19,175 --> 00:16:22,750
所以让我们，我希望我们能看看这些文件中的一个
so let's just, I wish we could just look at one of these files

177
00:16:22,750 --> 00:16:25,375
但不管怎样，因为这里有很多东西都改变了
but anyway, because there's a lot of stuff that's changed here

178
00:16:26,533 --> 00:16:33,279
我想没关系，我们只是复制这个，所以在begin里面，我们只有这个东西
I think doesn't matter, we'll just copy this, so inside begin, we just have this stuff

179
00:16:33,550 --> 00:16:36,275
对吧，基本上就是说开始一个新帧
right, which basically just says begin a new frame

180
00:16:37,266 --> 00:16:46,375
所以我们只需要写void ImGuiLayer begin，应该是begin，那就是其中的内容
so we're just write void ImGuiLayer begin, oops begin, this is the stuff that goes in there

181
00:16:46,375 --> 00:16:53,700
所以这基本上是一个OnUpdate和ShowDemoWindow，但我们实际执行的就是这部分
so this is basically it used to be an OnUpdate and ShowDemoWindow, but what we're actually doing is this part

182
00:16:53,700 --> 00:16:59,700
我们希望由层本身控制，对吧，例如游戏层或Sandbox中的任何东西
we want to be controlled by layers themselves, right, so for example the game layer or whatever we have inside Sandbox

183
00:17:00,100 --> 00:17:06,900
那应该是这样的，嘿，我想显示一个窗口，所以为了让它真正被编写出来，那是唯一的代码
that should be able to be like, hey, I want to show a window, so in order for this to actually be written, and that's the only code

184
00:17:07,333 --> 00:17:12,375
那需要由我们的客户端编写，我们需要在开头和结尾都有这个
that is required to be written by our client, we need to have this in begin and this in end

185
00:17:12,375 --> 00:17:14,125
这样我们就可以把所有的东西都放在这两者之间
so that we can put all of our stuff in between

186
00:17:14,533 --> 00:17:19,175
那就是OnImGuiRender函数的实际用途，所以你们将在实践中看到这一点
and that's where that OnImGuiRender function actually comes in, so you'll see this in practice in just a minute

187
00:17:19,600 --> 00:17:21,333
我们实际上不需要任何东西，也不需要OnUpdate
we actually don't need anything and OnUpdate

188
00:17:21,333 --> 00:17:26,100
所以我要去掉它，事实上我们不需要OnUpdate函数，所以我们也要去掉它
so I'll get rid of that, in fact we don't need an OnUpdate function, so we'll get rid of that as well

189
00:17:27,566 --> 00:17:40,129
好了，在这里，我们将有End函数，如果我去的话，End函数还有一些东西，直接复制
okay, so inside here, we will have our end function, if I'm going and the end function has a few more things, which will grab it

190
00:17:40,966 --> 00:17:46,950
更重要的是，它实际上从中得到了一些东西，它实际上得到了一些东西，我想那就是全部
and more importantly it's actually got something from, it's actually got something, I think that was all of it

191
00:17:47,666 --> 00:17:55,275
它实际上从停靠分支得到了一些东西，这是整个ViewportsEnable
yeah it's actually got something from the from the docking branch, which is this whole ViewportsEnable thing

192
00:17:55,275 --> 00:18:02,500
你们可以看到它运行了一些glfw的东西，很明显这是OpenGL特有的
and you can see it's got some glfw stuff that runs, now clearly this is kind of specific to OpenGL

193
00:18:02,500 --> 00:18:06,175
首先，因为我们正在进行OpenGL初始化和glfw，但那没什么问题
first of all because we're doing OpenGL init and also glfw, but that's fine

194
00:18:06,333 --> 00:18:10,325
我们最终可能会为每个平台提供一个单独的ImGuiLayer
we'll probably end up having a separate ImGuiLayer for each platform

195
00:18:10,325 --> 00:18:12,400
因为你们可以看到ImGui就是那样做的，对吧
because you can see that's what ImGui does, right

196
00:18:12,400 --> 00:18:17,050
他们有一个OpenGL的例子，有一个Vulcan的例子，有一个DirectX版本的例子
they have an example for OpenGL to have an example for Vulcan, they have an example for DirectX versions

197
00:18:17,050 --> 00:18:21,900
对吧，他们已经拥有了所有那些东西，我们将使用他们的代码，因为ImGui
right, they've got all of that stuff, we're just going to use their code for that, because ImGui is so kind of

198
00:18:21,900 --> 00:18:26,700
必须这样，我不想把它抽象成它自己的东西，他们应该能够以这种方式控制代码
it needs to be, I don't want to abstract it out into its own thing, they should just be able to control the code that way

199
00:18:26,700 --> 00:18:33,025
我们不需要做任何工作，这当然是最好的结果，因为那样我们就不会有任何问题
we don't have to do any work, which is of course the preferred result, because then we'll never have any issues

200
00:18:33,366 --> 00:18:39,325
一切都不会与他们的代码有任何分歧，一切都将是他们的，这是完美的，好吧，酷
everything will have no divergence at all from their code, everything will just be theirs, which is perfect, okay, cool

201
00:18:39,733 --> 00:18:44,250
总之，那就是我们所要做的，我将在OnImGuiRender中添加那个
so anyway, that's pretty much all we have to do, I will add that OnImGuiRender thing

202
00:18:44,966 --> 00:18:46,525
但我必须将其添加到层中，好了
but I have to add that to layer, okay

203
00:18:46,650 --> 00:18:52,550
所以我们要添加一些新的内容，也就是virtual void OnImGuiRender，好了
so we're adding something new which is going to be, virtual void OnImGuiRender, okay

204
00:18:53,000 --> 00:18:56,567
OnImGuiDrawer是另一个合适的名字，但无论如何，我会用这个
OnImGuiDrawer would be another appropriate name, but anyway I'll take this

205
00:18:56,933 --> 00:19:03,174
我将把它放在这里标记为override，这实际上会做什么
I'll put this into a here as an override, and what this will actually do

206
00:19:03,500 --> 00:19:07,943
或者我们可以用这个函数做任何类型的ImGui渲染
or what we're allowed to do with this function is do any kind of ImGui rendering

207
00:19:08,100 --> 00:19:13,375
好了，换句话说，对于这个例子，让我们看看，我们想绘制那个DemoWindow
right, so in other words, for this case, let's just see, we wanted to draw that DemoWindow

208
00:19:13,733 --> 00:19:16,550
我们可以执行ImGui::ShowDemoWindow()，对吧
we can just do ImGui ShowDemoWindow, right

209
00:19:16,750 --> 00:19:23,100
我们在这创建个静态布尔，static bool show = true
and we'll make a little static bool here, static bool show it was true

210
00:19:23,500 --> 00:19:30,200
好了，我们会把它传进来，所以这就是我们要做的，对吧，如果我们想创建个新窗口
okay, and we'll pass that in, so this is all we have to do, right, if we want us to make a new window

211
00:19:30,200 --> 00:19:35,825
我们可以只调用ImGui::Begin()和ImGui::End()，blava做得像我们马上要演示的那样
we can just do ImGui::Begin(), ImGui::End(), blava do like we'll actually demonstrate this in a minute

212
00:19:36,133 --> 00:19:40,175
但基本上我们不需要执行任何像NewFrame之类的函数
but basically we don't need to do any kind of like NewFrame none of that stuff

213
00:19:40,175 --> 00:19:46,250
因为这将设置在Begin和End之间，并且可以由任何层编写
because this will set in between begin and end, and can be as you can see written by any layer

214
00:19:46,466 --> 00:19:53,722
那很酷，我们马上就会看到这个，好吧，酷，就那样，我想我们还需要做什么
so that's pretty cool, and we'll see this in action in just a minute, okay, cool, so that's that, I think what else we have to do

215
00:19:54,466 --> 00:19:57,475
因此，我添加的其他重大更改估计是Application.h的内容
so the other big changes that I'm added guess what to application

216
00:19:57,900 --> 00:20:02,800
其中实际添加了m_ImGuiLayer作为一个实际的类似显式层
where actually added m_ImGuiLayer as an actual like explicit layer

217
00:20:03,133 --> 00:20:06,960
因此，我现在不再希望游戏能够控制这一点
so this is now no longer something that I want the game to be able to control

218
00:20:07,225 --> 00:20:10,025
因此在SandboxApp中，我们手动添加了ImGuiLayer
so inside SandboxApp, we manually added ImGuiLayer

219
00:20:10,400 --> 00:20:15,050
我不想再那样了，ImGuiLayer将由Hazel的运行时自动添加
I don't want that anymore, ImGuiLayer will be automatically added by Hazel's runtime

220
00:20:15,500 --> 00:20:20,000
也许在某些配置（如distribution）中，你们可能不想使用ImGui
perhaps in certain configurations like distribution, you might not want to use ImGui

221
00:20:20,000 --> 00:20:28,150
如果你们选择仅将ImGui用于调试目的，那么将有某种标志，可能只是完全剥离了ImGui
if you've chosen to only use ImGui for debug purposes, so we will have some kind of flag maybe there just strips ImGui completely

222
00:20:29,000 --> 00:20:34,725
但我认为ImGui是一种非常复杂的东西，就像它是Hazel固有的一样
but I see ImGui as being something that is quite intricate to actual like it's quite intrinsic to Hazel

223
00:20:35,133 --> 00:20:40,675
它只是Hazel的一部分，也就是说，如果你们不想明显地
it will just be part of Hazel, and that's that, you don't have to render anything with it, if you don't want to obviously

224
00:20:41,066 --> 00:20:48,325
但它将只是Hazel提供的中心界面，因此我将集中它
but um it will just be Hazel's central ui that Hazel provides, so because of that I'm going to centralize it

225
00:20:48,500 --> 00:21:01,475
所以在Application，创建个唯一指针，它就是ImGuiLayer，就是我们的ImGuiLayer，包含
so inside application, I'm going to make a unique pointer which is going to be ImGuiLayer, and it's going to be our ImGuiLayer, we're going to include

226
00:21:01,475 --> 00:21:04,800
我们可能要把它包含进去，虽然它不会变红
we're gonna have to include that probably, although it's not going red

227
00:21:05,350 --> 00:21:12,050
不管怎样，我都会把它包含进来，所以把这里的Hazel ImGui ImGuiLayer也包含进来
I'll include it anyway so include Hazel ImGui ImGuiLayer over here

228
00:21:12,050 --> 00:21:17,125
我们会把它做成这样，我们会说m_ImGuiLayout = std::make_unique()，就像那样
we'll make it so we'll say ImGuiLayout equals std::make_unique just like that

229
00:21:19,466 --> 00:21:26,425
然后我们实际上要做的是渲染它，所以在这执行m_ImGuiLayer->Begin()，然后必须通过
and then what we'll actually do is render it, so over here we'll do ImGui begin, then we have to go through

230
00:21:26,425 --> 00:21:33,000
既然在这里，也会调用End()，但接下来我们必须遍历所有层，并实际调用OnImGuiRender
I'll do end as well since I'm here, but then we have to go through all the layers, and actually call OnImGuiRender

231
00:21:33,300 --> 00:21:36,275
所以你们可以看到，这将介于Begin()和End()之间，好了
so you can see that this is going to sit in between beginning end, okay

232
00:21:36,800 --> 00:21:42,875
现在，当我们真的编写渲染器时，我已经在Hazel开发分支中完成了，它可供赞助商使用
now when we do actually write the renderer like, I've already done in the Hazel development branch, which is available for patrons

233
00:21:44,400 --> 00:21:47,525
我们必须在渲染线程上实际执行整个代码
we'll have to actually do this entire code on the render thread

234
00:21:47,866 --> 00:21:53,000
所以这里我们将有一个类似于多线程的体系结构，其中我们有一个更新线程
so here's we'll have like a multi thread kind of architecture where the we have an update thread

235
00:21:53,000 --> 00:21:58,850
这是一种应用线程，也是一个渲染线程，我们有一个渲染QR，我们也提交各种渲染命令
which is kind of just the application thread, and also a render thread, which we have a render QR, we submit every kind of render command too

236
00:21:58,850 --> 00:22:03,475
因此，整个区块最终将在该渲染线程上执行
so this whole chunk will actually be executed on that render thread eventually

237
00:22:04,175 --> 00:22:06,750
只是为了让你们知道，例如OnUpdate不会这样做
just so that you know like OnUpdate for example will not

238
00:22:06,800 --> 00:22:09,225
而OnUpdate是你们可以提交要渲染的内容的地方
and OnUpdate is where you can submit things for rendering

239
00:22:09,225 --> 00:22:15,500
但整个过程实际上都在渲染器上，因为我们在那里有原始渲染调用，就是那样
but this whole thing will actually be on the renderer, because we have raw render calls like right in there, so that is that

240
00:22:16,166 --> 00:22:21,125
但是我们有这种OnImGuiRender，所以如果我们现在在这上面的话，这应该会显示出来
but there we have this kind of OnImGuiRender, so this should just show, if we were on this right now

241
00:22:21,125 --> 00:22:27,700
希望它能显示我们的演示窗口，所以让我们来构建这个，我不知道我是否忘记了什么
hopefully it should just show our kind of demo window, so let's just build this, I don't know if I've forgotten anything

242
00:22:27,866 --> 00:22:34,050
我想我们会很快看到，但如果我只是构建这个，希望它会构建你们可以看到它
I guess we'll see pretty quickly, but if I just build this, hopefully it will build you can see it has

243
00:22:34,400 --> 00:22:38,800
所以让我们点击f5，看看会发生什么，好了，我们触发了个中断
so let's just hit f5 and see what happens, okay, so we have abort has been called

244
00:22:38,800 --> 00:22:44,575
如果我们再试一次，好吧，实际上，我刚刚意识到我忘了把这个添加到LayerStack中
if we retry this, okay, well I actually, I just realized I forgot to add this to the LayerStack

245
00:22:45,566 --> 00:22:50,250
那很烦人，但我想就是那样，因为我忘了做一些事情
so that's pretty annoying, but I think that's it, out of things that I forgot to do

246
00:22:50,250 --> 00:22:55,275
让我快速检查一下SandboxApp，我们这里没有任何ImGui代码，我们知道，好的，很好
let me check quickly check out the SandboxApp, we don't have any ImGui code in here do we know, okay, good

247
00:22:57,066 --> 00:23:03,050
另一件我想快速检查的事情是这个差异，所以Application.cpp 我在这里做什么
the other thing I want to quickly check out is this diff, so Application.cpp what do I do here

248
00:23:05,575 --> 00:23:12,325
事实上，我从未将其添加到LayerStack中，那很有趣，也可能是错的
I actually never did add it to the LayerStack, that's interesting, that's probably wrong as well

249
00:23:12,533 --> 00:23:17,050
所以这到底应该做什么，实际上我甚至不知道为什么我们要从他们那里得到这些
so what this should actually do, and actually I'm not even sure why we get that out of them

250
00:23:17,400 --> 00:23:20,810
但这绝对应该做的是，我们应该将其添加到LayerStack中
but what this definitely should do is, we should be adding it to the LayerStack

251
00:23:20,966 --> 00:23:24,375
因为我们不会明显地分离它是如何运行的
because we won't obviously detachion how did that even work

252
00:23:24,375 --> 00:23:26,625
如果我们不分离，我们就永远不会添加到LayerStack中
then if we don't, we never added to the LayerStack

253
00:23:26,766 --> 00:23:36,725
不管怎样，那很可疑，所以我们要执行PushOverlay，哦，实际上这让我想到了这一点
that's very suspicious, anyway, so we'll do we'll do PushOverlay, oh and actually that brings me to this point

254
00:23:37,533 --> 00:23:41,750
实际上，我们不能将其作为唯一指针，我甚至不知道我昨天编写的代码是如何运行的
we actually can't have this as a unique pointer, I'm not even sure how that code that I wrote yesterday worked at all

255
00:23:42,533 --> 00:23:47,725
但无论如何，我们不能把它作为，它不应该是唯一指针
but anyway, we can't have this as a, this shouldn't be a unique pointer at all

256
00:23:47,725 --> 00:23:54,575
现在我实际上在看这个，因为很明显所有权转移到了LayerStack
now that I'm actually looking at this, because obviously ownership is transferred to the LayerStack

257
00:23:54,625 --> 00:23:59,900
因此，ImGuiLayer现在是我们的LayerStack的一部分
so ImGuiLayer is now something that's part of our LayerStack

258
00:23:59,900 --> 00:24:06,750
这意味着层栈决定它何时被创建和删除，所以这必须是一个原始指针，好了，让我们点击f5
which means that layer stack determines when it gets created and deleted, so this has to be a raw pointer, there we go, so let's hit f5

259
00:24:06,750 --> 00:24:10,625
那很奇怪，我昨天写的代码，因为它确实有效，我确实测试了它
that's very weird though, that code that I wrote yesterday, because it definitely worked, I definitely tested it

260
00:24:11,175 --> 00:24:23,025
但我不知道怎么做，让我们看看这个，好吧，我们有，这很好，哦，这让我想起了
but I'm not sure how, let's take a look at this, okay, so we have, well this is great, oh and this reminds me well of something that

261
00:24:23,400 --> 00:24:28,950
我们对实际的层栈有一点问题，有人指出这儿有一个bug
we have a little bit of an issue with the actual layer stack, someone pointed this out, there's a bug

262
00:24:29,733 --> 00:24:36,150
我们跟踪层插入迭代，这不是最好的做法，因为如果整个集合在内存中移动
we keep track of the layer insert iteration, which isn't the best thing to do, because if the whole collection gets moved in memory

263
00:24:36,500 --> 00:24:47,000
必须使其失效并重新执行，因此，更好的方法实际上是使用一种类似于插入索引的层
this has to be invalidated and redone, so what a better way of doing this is actually to have a layer kind of insert index

264
00:24:47,175 --> 00:24:57,275
对吧，可能就像个无符号int，可以先把它设为零，然后在任何时候我们必须执行这个
right, which could just be like an unsigned int, right, we can set this to zero to begin with, and then what happens is whenever we have to do this

265
00:24:57,275 --> 00:25:05,676
我们基本上可以设置LayerInsert，我们可以使用这个LayerInsertIndex+
we can just basically set LayerInsert, we can use this kind of LayerInsertIndex plus

266
00:25:06,875 --> 00:25:11,566
就像，对不起，我们可以做m_Layers加索引
like, sorry, we can do m_Layers plus the index

267
00:25:11,566 --> 00:25:19,370
因此，它总是从begin开始，对吧，begin加上索引就是我想说的，就像那样，对吧
so that way it's always from begin, right, so begin plus the index is what I'm trying to say, just like that, right

268
00:25:20,166 --> 00:25:24,600
我们不需要再这样做了，我们也不需要再这样做了
we don't need to do this anymore, we also don't need to do this anymore

269
00:25:24,866 --> 00:25:33,352
好了，所以基本上我们要插入这个，层总是被推，开始加上索引，然后我们所要做的就是
right, so basically we're inserting this, layers are always going to be pushed begin plus that index, and then all we have to do is

270
00:25:33,425 --> 00:25:41,050
显然，因为我们刚刚插入了一个层，所以LayerInsertIndex递增，然后索引中的层递减
obviously since we've just inserted a layer, that layer insert index gets incremental, and then here that layer inside index gets decremented

271
00:25:41,050 --> 00:25:46,050
对吧，所以每当我们弹出一个层，我们就减少它，每当我们添加一个层，我们就增加它
right, so whenever we pop a layer, we reduce that, whenever we add a layer, we increase that

272
00:25:46,050 --> 00:25:51,325
举个例子，如果我们推一层，突然这一层变成了一层，那么我们推下一层到位置一，对吧
so for example if we push a layer, suddenly this is now one, so we push the next layer at position one, right

273
00:25:51,800 --> 00:25:56,650
然而，如果我们推一个叠加，它被推到类似的位置工具，不管怎样，这仍然是一个层
whereas if we push an overlay that gets pushed into like position tool whatever, this is still one

274
00:25:56,650 --> 00:26:04,566
所以当推另一层时，它会被推到覆盖层之前，对吧，所以基本上只是在那里保持一点距离
so when we push another layer, it'll get pushed him before that overlay, right, so that basically just keeps a little separation there

275
00:26:04,566 --> 00:26:08,750
但我们实际上不需要使用迭代器，只需要一个索引，那样会更好
but we don't need to actually use an iterator for that, just an index, and that'll be a lot better

276
00:26:08,750 --> 00:26:14,875
因为如果我们移动或者其他什么，如果调整向量的大小，迭代器就会失效，不需要更新它
because if we move or whatever, if we resize the vector, and the iterator kind of gets invalidated, we don't need to update it

277
00:26:15,333 --> 00:26:22,375
所以如果我们点击f5，现在也许这会起作用，好吧，看看这个，它实际上已经在外面的窗口中生成了
so if we hit f5, now maybe this will work, okay, and look at that, it's already actually spawned with the window outside

278
00:26:22,375 --> 00:26:28,900
但是你们看到，我们现在可以做的是，可以抓住这个演示窗口，然后像这样把它拖到外面
but you can see what we can do now is we can grab this ImGui demo window, and just drag it like outside of this

279
00:26:29,175 --> 00:26:34,580
就像这有多酷，对吧，可以把ImGui窗口放在外面，然后可以把它拖回这里，一切都好
like how cool is this, right, we can just have that ImGui window outside, and then we can drag it back here, and everything is fine

280
00:26:35,266 --> 00:26:40,025
如果我们像另一个窗口一样打开，那么如果我去喜欢的例子
if we open like another window, so if I go to like examples

281
00:26:40,025 --> 00:26:44,000
你们知道的，比如log，只要把它拖到外面，对吧
you know log for example, you just drag that outside, right

282
00:26:44,150 --> 00:26:47,666
好了，我们有多个窗户在空间中漂浮
and there we go, we have multiple lime glue windows just floating around in space

283
00:26:47,666 --> 00:26:52,825
真的很酷，现在dockspace也是或者只是停靠是另一件很酷的事情
which is really really cool, now the dockspace is also or just docking is another really cool thing

284
00:26:52,825 --> 00:26:55,875
如果我使用示例dockspace，对吧
so if I go example dockspace, right

285
00:26:55,875 --> 00:26:59,401
这整个窗口，现在是一个dockspace，我可以在这里拖动它
this whole window, now is a dockspace, where I can just like drag this in here

286
00:26:59,733 --> 00:27:03,399
你们可以把我的日志放在这里，可以看到，这就像一个普通的应用程序
you dock put my log down here, and you can see, it's just like a normal application

287
00:27:03,400 --> 00:27:10,350
这有点像是控制台，你们知道这有点像
it's kind of like must have been something else like console, you know this kind of becomes like a little

288
00:27:10,766 --> 00:27:18,526
我会将其并排停靠，这有点像visual studio或任何使用停靠的应用程序，对吧
and I'll dock this maybe side by side, this becomes like a little almost like kind of like visual studio or any kind of application that uses docking, right

289
00:27:18,866 --> 00:27:21,400
那真的很酷，我真的很喜欢这个，你们可以看到
so that's really really cool, I really like this, you can see

290
00:27:21,400 --> 00:27:24,475
我们完全可以在这里创建一个视口，就像一个视口
we can totally like make a viewport maybe here, like a viewport winter

291
00:27:25,133 --> 00:27:31,125
那将是我们的渲染器，我们有一个小的级别编辑器，就像立即设置的一样
and that will kind of be our renderer, and we have like a little level editor like set up pretty much immediately

292
00:27:31,125 --> 00:27:34,100
所以这是一件非常激动人心的事情，我真的很想做
so this is kind of, this is really exciting something that I really wanted to do

293
00:27:34,612 --> 00:27:38,775
很明显，我们可以抓住这些窗户，把它们拖到窗外，就像那有多酷，对吧
and obviously we can grab these windows and drag them off outside of the window, like how cool is that, right 

294
00:27:38,775 --> 00:27:43,800
我们现在完全可以用它来制作一个非常酷的应用程序，所以那就是我想添加的主要功能
we can totally make a really cool application with this now, so that's kind of the major features that I wanted to add

295
00:27:44,425 --> 00:27:52,200
现在我想留给你们一点家庭作业，我们如何让ImGui在这里运行，对吧
now I want to leave you guys with a little bit of a homework assignment, how do we get ImGui working here, right

296
00:27:52,200 --> 00:28:00,475
很明显，我有一个void OnImGuiRender，我可以把它放在这里，对吧，就放在这里
so I have obviously my void OnImGuiRender, which I can just like just put in here, right, just throw in here

297
00:28:01,525 --> 00:28:08,600
现在我理论上应该可以执行ImGui::Begin()，你们知道我们称之为测试
and now I theoretically should be able to do ImGui to begin you know we'll call this like test

298
00:28:09,800 --> 00:28:18,250
我应该能够输入ImGui文本，然后写一些hello world，然后ImGui就可以创建我的窗口了
I should be able to type in ImGui text, and you know write something like hello world, and then ImGui ends right to make my window

299
00:28:18,766 --> 00:28:23,250
现在很明显，我们需要包含ImGui，但目前我们还不能真正做到这一点
now obviously we need to include ImGui, which we actually can't really do at the moment

300
00:28:24,200 --> 00:28:30,650
所以让我们只包含ImGui/imgui.h，那就是我想要包含它的方式，以便使它包含运行
so let's just include ImGui/imgui.h, that's how I'd like to include it in order to make this include work

301
00:28:30,725 --> 00:28:34,975
我们应该回到Hazel，编辑premake文件
we should actually go back into Hazel, and edit the premake file

302
00:28:35,366 --> 00:28:40,850
所以我们在Sandbox下，就这儿，就在我们的include目录中
so that we are inside under Sandbox which is here in our include directories

303
00:28:40,850 --> 00:28:47,953
我们可以包括Hazel/vendor，对吧，这将包含我们所有的vendor
we can include Hazel/vendor, right, which will include all of our vendor stuff

304
00:28:48,225 --> 00:28:51,500
所以如果我重新运行premake生成项目
so if I rerun premake, generate projects

305
00:28:52,225 --> 00:28:59,766
好吧，我不能打开vendor/ImGui，那太遗憾了，为什么我们生成那个没有更多的问题呢
okay, I cannot open vendor/ImGui, that is a shame, why can't we generate that no great more problems

306
00:29:00,000 --> 00:29:03,825
这正是我想要的，所以这实际上没有，我们一定没有拉
just what I wanted, so this actually doesn't have, we must not have pulled

307
00:29:04,266 --> 00:29:10,825
那么执行git pull origin docking，对吧，只是为了拉层代码
so let's do git pull origin docking, right, just to pull the layers code

308
00:29:10,825 --> 00:29:14,433
其中包括我的premake文件，我想我们没有这样做
which would include my premake file, which I guess we didn't do

309
00:29:14,700 --> 00:29:21,450
好了，当然现在有了更小的premake文件，所以运行生成项目，你们可以看到生成了它们
okay, of course now we have premake file lower, so if we run generate projects, you can see we generate them

310
00:29:21,450 --> 00:29:24,450
我将重新加载所有这些内容，现在开始运行
I'll reload all this includes, now work

311
00:29:24,450 --> 00:29:29,700
所以如果我可以控制f7来构建它，你们可以看到它构建没问题，对吧
so if I can control f7 to build this, you can see it builds fine, right

312
00:29:30,266 --> 00:29:36,020
但如果我尝试并实际运行它，那么我将尝试并实际编译并链接它，而不仅仅是编译它
but if I try and actually run it, so I'll try and actually compile and link it not just compile it

313
00:29:36,933 --> 00:29:43,100
你们可以看到，我实际上得到了三个链接错误，对吧，这表示结果的链接符号开始出现错误
you can see, I actually get three linking errors, right, so this says error on resulted sound symbol begin

314
00:29:43,100 --> 00:29:48,800
在文本中，它们没有链接，为什么会那样，如果我们粗略地看一下链接结构
and in text somehow they're not linking in, why is that, so if we take a look at our linking structure roughly

315
00:29:49,100 --> 00:29:54,050
我们将ImGui构建到一个静态库中，然后包含在Hazel中，这是一个dll
we have ImGui being built into a static library, and then being included in the Hazel, which is a dll

316
00:29:54,775 --> 00:30:02,050
看起来这些符号实际上并没有被我们的dll文件导出，这是Hazel，对吧，那有点奇怪
so it looks like those symbols aren't actually being exported by our dll file, which is Hazel, right, that's a little bit weird

317
00:30:02,366 --> 00:30:06,018
为什么会发生那种情况，而那正是你们来解决这一切的原因
why is that happening, and that's where you guys come in to fix all of this

318
00:30:06,325 --> 00:30:09,333
所以想一想为什么会发生这种情况
so have a think as to why you think this is happening

319
00:30:09,333 --> 00:30:12,625
再说一次，只是想让大家明白一点，帮你们找出一点提示
again, just to make it really clear and help you guys out a little bit of a hint

320
00:30:13,009 --> 00:30:17,375
我们有静态ImGui库，所有这些符号当然都是静态库
we have our static ImGui library, all of those symbols of course is a static library

321
00:30:17,375 --> 00:30:21,825
因此所有这些符号都已包含在dll文件中Hazel.dll
so all of those symbols have been included into the dll file, which is Hazel.dll

322
00:30:22,125 --> 00:30:26,250
那么现在我的exe文件，这是针对Hazel的Sandbox链接
so then now on my .exe file, which is Sandbox links against Hazel

323
00:30:26,400 --> 00:30:29,100
为什么那些ImGui符号没有引入
why are those ImGui symbols not coming through

324
00:30:29,450 --> 00:30:32,850
我想知道，在下面留下评论，看看你们是否能找到解决方案
I wanna know, leave a comment below see if you can find a solution

325
00:30:33,133 --> 00:30:37,800
顺便说一句，我当然已经知道了解决方案，所以很清楚，实际上有很多解决方案
I of course already know the solution by the way, just so that's clear, and there's actually many solutions

326
00:30:37,800 --> 00:30:44,625
但我已经选择了一个解决方案，而且实际上已经在ImGui中，抱歉，在Hazel开发分支中
but I've already chosen a solution, and that's actually already in the ImGui, sorry, in the Hazel development branch

327
00:30:44,625 --> 00:30:48,475
那是patreon.com/thecherno，那是支持该系列的渠道，顺便说一句，如果你们认为它总是
that's patreon.com/thecherno, that's the channel to support the series, by the way, if you should think it was always

328
00:30:49,000 --> 00:30:52,975
不管怎样，我已经找到了解决方案，不过你们去看看能不能找到
anyway, I've already got the solution there, but have a go see if you can figure it out

329
00:30:53,300 --> 00:30:56,100
这也是一个很好的C++运行原理练习
this is a really good exercise of just how C++ works as well

330
00:30:56,766 --> 00:31:00,775
所以一定要看看，想一想，在下面的评论中留下你们的解决方案
so definitely check that out, and have a think, and leave your solution in the comments below

331
00:31:00,775 --> 00:31:04,340
如果你们中的一些人是对的，我可能会标记为最重要的评论
if for those of you who are right, I'll pin probably the top comment

332
00:31:05,275 --> 00:31:08,200
但我想说的是，如果你们正在看这期视频
but also I wanted to say, maybe if you're watching this video 

333
00:31:08,200 --> 00:31:12,525
在你们看评论之前，不要像第一个小时或其他什么时候那样对自己有兴趣
and not in like the first hour or whatever have a thing for yourself before you look at the comments 

334
00:31:12,525 --> 00:31:16,605
看看你们能不能搞定，下次见，拜
and see if you can figure it out, and I will see you guys next time, goodbye

