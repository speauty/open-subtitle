1
00:00:00,133 --> 00:00:01,000
嘿, 大家好
hey, what's up guys

2
00:00:01,033 --> 00:00:03,633
我是Cherno, 欢迎回到我的OpenGL系列教程
my name is Cherno, welcome back to my OpenGL series

3
00:00:03,633 --> 00:00:05,466
那么, 我们上一次讨论了顶点缓冲区
so, last time we talked about vertex buffers

4
00:00:05,466 --> 00:00:07,500
上面有个链接, 如果你没看过那个视频的话
there's a link up there, if you haven't seen that video

5
00:00:07,500 --> 00:00:09,700
但实际上, 有一些部分我们忽略了
but there were some parts that we were missing to actually

6
00:00:09,700 --> 00:00:10,866
得到三角形渲染
get our triangle rendering

7
00:00:10,866 --> 00:00:13,133
并且特别是我们遗漏的两个主要部分
and specifically the two major parts that we were missing

8
00:00:13,133 --> 00:00:15,750
就是顶点属性和着色器
were vertex attributes and shaders

9
00:00:15,750 --> 00:00:17,833
今天, 我们将学习顶点属性
today, we're going to cover vertex attributes

10
00:00:18,000 --> 00:00:20,100
所以, 什么是顶点属性
so, what is a vertex attribute

11
00:00:20,100 --> 00:00:22,500
基本上就是, OpenGL管道的工作方式
so basically, the way that the OpenGL pipeline works is

12
00:00:22,500 --> 00:00:24,900
我们在上一集稍微提到了一下
we've kind of discussed lightly in the last episodes

13
00:00:24,900 --> 00:00:29,200
以后我们会有更深入讲解这个的视频
and we will have some kind of in depth video on that in the future

14
00:00:29,200 --> 00:00:30,575
但是, 简单地说
but, to put it simply the way that 

15
00:00:30,575 --> 00:00:34,500
OpenGL管道的工作原理是我们为我们的显卡提供数据
the OpenGL pipeline works is that we basically supply our graphics card with data

16
00:00:34,500 --> 00:00:37,100
我们在显卡上存储一些内存
we store some kind of memory on the GPU

17
00:00:37,100 --> 00:00:39,833
它包含了我们想要绘制的所有数据
which contains all of the data of what we want to draw

18
00:00:39,833 --> 00:00:40,800
然后我们使用一个着色器
and then we use a shader

19
00:00:40,800 --> 00:00:44,500
是一个在显卡上执行的程序来读取数据
which is a program that is executed on the GPU to actually kind of read that data

20
00:00:44,633 --> 00:00:46,266
并且完全显示在屏幕上
and display it on the screen more or less

21
00:00:46,266 --> 00:00:48,833
通常我们画几何图形的方式
and typically the way that we actually draw geometry

22
00:00:48,933 --> 00:00:50,600
就是使用一个叫顶点缓冲区的东西
is we use something called a vertex buffer 

23
00:00:50,600 --> 00:00:54,033
这基本上是存储在显卡上的内存缓冲区
that is basically a buffer of memory that is stored on the GPU

24
00:00:54,300 --> 00:00:56,033
所以, 当对着色器编程时
so, when the program the shader

25
00:00:56,033 --> 00:00:58,533
实际上, 是从读取顶点缓冲区开始的
actually starts to read that vertex buffer

26
00:00:58,800 --> 00:01:01,233
它需要知道缓冲区的布局
it needs to know the layout of that buffer

27
00:01:01,233 --> 00:01:03,500
这个缓冲区实际上包含的就是
what is actually contained in the buffer is it

28
00:01:03,500 --> 00:01:04,466
只是一堆浮点数
just a bunch of floats

29
00:01:04,466 --> 00:01:06,833
它们指定了每个顶点的位置
which dictate the position of each vertex

30
00:01:06,925 --> 00:01:10,766
你也有纹理坐标, 法线之类的吗
do you also have texture coordinates, normal, anything else like that

31
00:01:10,800 --> 00:01:12,666
所以实际上, 我们不得不告诉OpenGL
we have to actually tell OpenGL

32
00:01:12,900 --> 00:01:15,933
内存中有什么, 又是如何布局的
what is in the memory, and how its laid out

33
00:01:15,966 --> 00:01:17,566
因为如果我们不这么做, 那么
because if we don't do that, then

34
00:01:17,733 --> 00:01:19,866
至于OpenGL, 只能看到它只是一堆字节
as far as OpenGL can see it's just a bunch of bytes

35
00:01:19,866 --> 00:01:21,866
这和c++是一样的, 对吧
it's the same as with c++, right

36
00:01:21,866 --> 00:01:24,166
我的意思是, 如果我写一个浮点数, 然后给它赋值
I mean if I write a float, and I assign it something

37
00:01:24,433 --> 00:01:26,200
我们知道内存中有一个浮点数
we know that the memory there is a float

38
00:01:26,200 --> 00:01:28,366
因为我告诉c++，这是一个浮点数
because I'm telling c++ this is a float

39
00:01:28,566 --> 00:01:30,766
如果我把它转换成一个整数
if I cast that to an integer by the boy

40
00:01:30,766 --> 00:01:32,266
我将它转换为一个整型指针
I cast it to an int pointer

41
00:01:32,400 --> 00:01:33,600
如果我取浮点数的内存地址
if I take the memory address of the float

42
00:01:33,600 --> 00:01:35,000
并将其转换为整型指针
and cast it to an int pointer

43
00:01:35,100 --> 00:01:35,866
然后解引它
and then dereference it

44
00:01:35,866 --> 00:01:37,166
我将得到完全不同的东西
I'm going to get something completely different

45
00:01:37,166 --> 00:01:39,300
因为它对这块内存做了不同的解释
because it's interpreting the memory differently

46
00:01:39,800 --> 00:01:41,533
这和这里的情况是一样的
that's kind of the same thing that's going on here

47
00:01:41,533 --> 00:01:43,200
所以我们需要能够告诉OpenGL
we need to be able to tell OpenGL

48
00:01:43,200 --> 00:01:45,633
前12个字节是三个浮点数
the first 12 bytes are three floats

49
00:01:45,633 --> 00:01:46,800
并且每个浮点数三个字节
four bytes per float

50
00:01:46,800 --> 00:01:48,333
并且, 这就是我的观点
and that is my position

51
00:01:48,733 --> 00:01:51,421
之后的八个字节是我的纹理坐标
the next eight bytes after that are my texture coordinates

52
00:01:51,421 --> 00:01:54,333
我有一个浮点数x和一个浮点数y或
I've got one float for x and one float for y or

53
00:01:54,475 --> 00:01:56,600
u或者v, 如果你喜欢这么叫它的话
u and v, if you want to call it like that

54
00:01:56,600 --> 00:01:58,800
所以我们需要一种方法能够告诉OpenGL
we need a way to be able to tell OpenGL

55
00:01:58,866 --> 00:02:01,633
这是我的内存布局, 并且这也正是
this is the layout of my memory, and that is exactly

56
00:02:01,866 --> 00:02:04,500
这整个VertexAttribPointer可以为我们做的一切
what this whole VertexAttribPointer thing can do for us

57
00:02:04,500 --> 00:02:07,600
OpenGL中有一个叫glVertexAttribPointer的函数
there's a function in OpenGL called glVertexAttribPointer

58
00:02:07,700 --> 00:02:09,533
这就是我们今天要讲的内容
that's what we're going to be taking a look at today

59
00:02:09,533 --> 00:02:10,500
从着色器的一边来说
from the shader side

60
00:02:10,500 --> 00:02:13,933
你也需要匹配你在CPU端定义的布局
you also need to match the layout that you define on the CPU side

61
00:02:13,933 --> 00:02:15,400
在c++方面也是如此
on the c++ side as well

62
00:02:15,400 --> 00:02:17,466
那么当我们在下一集介绍着色器的时候
and when we actually introduce shaders in the next episode

63
00:02:17,500 --> 00:02:20,366
我们也会看一个那到底是怎么样的基本例子
we'll take a look at a basic example of what that looks like as well

64
00:02:20,366 --> 00:02:23,310
再说一次, 我只是从最基本的例子开始
and again I'm just starting off with really basic examples

65
00:02:23,310 --> 00:02:25,866
这样你就能看到它最简单的形式
so that you can see what it is like in its simplest form

66
00:02:25,866 --> 00:02:27,366
但随着系列的继续
but as the series goes on

67
00:02:27,566 --> 00:02:30,666
我们显然会增加它, 让它变得更复杂
we are obviously going to ramp it up, and make it way more complicated

68
00:02:30,666 --> 00:02:32,500
我只是想让你们慢慢开始
I'm just kind of starting you guys off gently

69
00:02:32,650 --> 00:02:34,925
好了, 别瞎扯, 继续
all right, without just rambling on, further

70
00:02:34,925 --> 00:02:36,000
让我们看一下代码
let's take a look at the code

71
00:02:36,000 --> 00:02:40,300
所以, 从上一集开始, 我们在这儿有浮点数组positions
so, from last episode, we have basically a float array of positions here

72
00:02:40,366 --> 00:02:42,300
你可以考虑一下我这样划分的方式
you consider the way that I've kind of divided it is that

73
00:02:42,300 --> 00:02:45,533
这里的每一行都是一个实际的顶点, 对吧
each line here is an actual vertex, right

74
00:02:45,700 --> 00:02:47,400
所以我们有三个顶点位置
so we have three vertex positions

75
00:02:47,400 --> 00:02:48,833
我们有三个顶点
we have three vertexes

76
00:02:48,833 --> 00:02:53,400
这就是我们顶点在屏幕上的xy坐标
this is the x coordinate, this is the y coordinate of our vertex on our screen

77
00:02:53,400 --> 00:02:54,375
在我继续之前
now before I go on

78
00:02:54,375 --> 00:02:56,375
事实上, 我只是想定义顶点是什么意思
I just really want to define what I mean by vertex

79
00:02:56,375 --> 00:02:58,850
因为人们似乎对此很困惑
because people seem to get pretty confused with that 

80
00:02:58,850 --> 00:03:00,833
并且也在错误地使用这个词
and also use that word incorrectly

81
00:03:00,833 --> 00:03:04,050
顶点与位置无关, 对吧
a vertex has nothing to do with the position, right

82
00:03:04,050 --> 00:03:07,433
顶点就是几何图形上的一个点
a vertex is just a point that is on your geometry

83
00:03:07,433 --> 00:03:11,233
大多数人在视觉上对它们的明显印象是通过它的位置
the way that most people think about them visually obviously is by its position

84
00:03:11,233 --> 00:03:14,266
所以如果我给你画一个三角形, 你会看到, 啊, 三个顶点
so if I draw you a triangle you'll be like, ah, three vertices

85
00:03:14,300 --> 00:03:15,866
但顶点不
but vertices don't

86
00:03:15,933 --> 00:03:17,850
顶点不是位置, 明白吧
vertices are not positions, right

87
00:03:17,850 --> 00:03:19,666
一个定点不是一个位置
a vertex is not a position

88
00:03:19,666 --> 00:03:22,700
一个顶点可以不仅仅包含一个位置
a vertex can contain way more than just a position

89
00:03:22,833 --> 00:03:24,133
所以, 如果你告诉我, 嘿
so, if you tell me, hey

90
00:03:24,133 --> 00:03:27,133
我有一个顶点, 它是0.5 0.5
I have a vertex, it's 0.5 0.5

91
00:03:27,866 --> 00:03:29,366
这没有告诉我任何东西, 对吧
that doesn't tell me anything, right

92
00:03:29,466 --> 00:03:30,900
因为你是在暗示
because you're kind of implying that

93
00:03:30,933 --> 00:03:32,333
我指的是顶点位置
I mean vertex position

94
00:03:32,400 --> 00:03:34,133
是的, 很多人都是这样用的
and yes, a lot of people do use it like that

95
00:03:34,133 --> 00:03:35,400
这并不完全正确
that's not exactly correct

96
00:03:35,400 --> 00:03:38,966
因为顶点可以包含比位置更多的数据
because a vertex can contain way more data than just a position

97
00:03:38,966 --> 00:03:41,400
虽然它通常包含一个位置
although it does usually contain a position

98
00:03:41,700 --> 00:03:42,500
所以, 我只是想说清楚
so, I just want to make that clear

99
00:03:42,500 --> 00:03:44,133
当我说顶点位置时
when I say vertex position

100
00:03:44,400 --> 00:03:46,300
我真正的意思不会只是
that's what I really mean I'm not going to just

101
00:03:46,300 --> 00:03:48,266
实际上, 如果我说什么顶点时
if I actually say that what vertex

102
00:03:48,300 --> 00:03:51,333
我指的是构成顶点的所有数据
I mean the whole blob of data that makes up that vertex

103
00:03:51,333 --> 00:03:53,666
这也可能包括位置
which again could include the position

104
00:03:54,000 --> 00:03:55,933
纹理坐标, 法线
texture coordinates, normals

105
00:03:56,000 --> 00:03:58,433
颜色, by normrs, 切线
colors, by normals, tangents

106
00:03:58,866 --> 00:03:59,933
诸如此类的东西
all of this kind of stuff

107
00:03:59,933 --> 00:04:02,433
对, 它们可能都在一个顶点上
right, that could all be in a single vertex

108
00:04:02,566 --> 00:04:03,866
所以, 只有位置
so, just the position

109
00:04:03,866 --> 00:04:05,466
如果你只是涉及到位置
if you're just referred to the position

110
00:04:05,466 --> 00:04:08,300
你应该叫它位置, 顶点位置
you should really call it positional, vertex position

111
00:04:08,400 --> 00:04:11,166
所以, 这就是为什么我把这个浮点数作为一种位置
so, that's why I've got this float here as kind of positions

112
00:04:11,166 --> 00:04:12,100
而不是顶点
not just vertices

113
00:04:12,100 --> 00:04:13,700
因为, 现在, 它们只是位置
because, at the moment, they're just positions

114
00:04:13,733 --> 00:04:15,166
尽管, 当我往里面添加东西的时候
although, when I add stuff to them

115
00:04:15,166 --> 00:04:16,875
我真的可能应该给它们重命名
I really probably should rename them, 

116
00:04:16,875 --> 00:04:19,350
不管怎样, 我们有这三个顶点
anyway, so we have these three vertices here

117
00:04:19,350 --> 00:04:21,200
然后我们生成一个缓冲绑定
and then we're generating a buffer binding

118
00:04:21,200 --> 00:04:23,500
然后把这个或者
and then actually putting this kind of or

119
00:04:23,500 --> 00:04:27,866
我应该说把这些positions复制到我们在这里定义的缓冲区中
I should say copying these positions into this actual buffer that we've defined here

120
00:04:27,866 --> 00:04:29,600
通过指定一个指向它们的指针
by just specifying a pointer to them

121
00:04:29,766 --> 00:04:30,866
以及它们有多大
and how big they are

122
00:04:30,866 --> 00:04:32,733
这就是我们到目前为止所做的
and that's it that's all we're doing so far

123
00:04:32,833 --> 00:04:34,666
再说一次, OpenGL不知道
so again, OpenGL has no idea

124
00:04:34,933 --> 00:04:37,133
如果你看这段代码, 我们可以清楚地看到
that if you look at this code we can clearly see

125
00:04:37,200 --> 00:04:40,464
好吧, 我们每个顶点有两个浮点数
okay, so we have two floats per vertex

126
00:04:40,464 --> 00:04:43,900
这是位置的xy坐标, 对吧
and that is the x and y position, right

127
00:04:44,050 --> 00:04:47,066
OpenGL不知道, 这对你来说可能很明显的东西
OpenGL doesn't know that, it might seem obvious to you

128
00:04:47,066 --> 00:04:48,325
因为你看着这段代码, 你会想
because you're looking at this code and you're like

129
00:04:48,325 --> 00:04:49,800
OpenGL怎么可能不知道呢
well, how can OpenGL not know that

130
00:04:49,933 --> 00:04:53,500
但如果我突然引入第三个坐标呢
but what if I suddenly introduce a third kind of coordinate, right

131
00:04:53,500 --> 00:04:54,466
所以, 换句话说
so, in other words

132
00:04:54,466 --> 00:04:57,433
如果我想要一个三维的坐标系而不是二维的呢
what if I want a three dimensional coordinate system instead of two dimensional

133
00:04:57,433 --> 00:04:58,466
就像我们这里一样
like we've kind of got here

134
00:04:58,633 --> 00:04:59,533
如果我这样做呢
what if I do this

135
00:04:59,733 --> 00:05:00,800
那么突然
well then suddenly

136
00:05:01,166 --> 00:05:02,666
你知道, OpenGL是怎么知道的
you know, how does OpenGL know

137
00:05:02,666 --> 00:05:07,566
实际上我有三个三维坐标系统的顶点
that I've actually got three vertices of a three kind of dimensional coordinate system

138
00:05:07,833 --> 00:05:09,000
而不是只有一个
instead of just one

139
00:05:09,600 --> 00:05:14,066
2 3, 然后是4, 还有一半, 我猜就是
2 3, and then kind of four, and a half I guess of just

140
00:05:14,300 --> 00:05:15,300
两个坐标,对吧
two coordinates, right

141
00:05:15,300 --> 00:05:18,100
因为如果我要重新排列这些代码
because if I was to rearrange this code

142
00:05:18,500 --> 00:05:19,533
那么突然
well then suddenly

143
00:05:19,633 --> 00:05:22,866
看起来我们实际上有三个以上的顶点
it looks like we actually have more than three vertices here

144
00:05:23,033 --> 00:05:25,700
如果你坚持二维法则, 对吧
if you kind of stick to the kind of two dimensional rule, right

145
00:05:26,033 --> 00:05:30,100
所以我想说的是我们需要告诉OpenGL, 外面的数据布局
so what I'm kind of getting at is that we need to tell OpenGL, out layout

146
00:05:30,100 --> 00:05:31,500
这就是我们要做的
and that's what we're about to do

147
00:05:31,700 --> 00:05:32,900
那么如果我们向下滚动一点
so if we scroll down a little bit

148
00:05:33,033 --> 00:05:34,300
一旦我们绑定了缓冲区
once we kind of bind the buffer

149
00:05:34,300 --> 00:05:35,300
并且我们用数据填充它
and we fill it with data

150
00:05:35,300 --> 00:05:36,600
你没必要这么做
you don't have to do this

151
00:05:36,750 --> 00:05:38,000
在用数据填充之前
before you fill it with data

152
00:05:38,000 --> 00:05:38,900
你没必要这么做
you don't have to do it

153
00:05:38,900 --> 00:05:41,900
之后只要缓冲区是实际绑定的, 就可以这样做
after you can do it whenever as long as the buffer is actually bound

154
00:05:42,033 --> 00:05:43,266
那时我们就可以告诉
that is when we can tell

155
00:05:43,266 --> 00:05:45,766
OpenGL, 我们缓冲区的布局是什么
OpenGL what the layout of our buffer actually is

156
00:05:45,900 --> 00:05:46,966
这就是我们做那个的主要方法
and the main way that we do that

157
00:05:46,966 --> 00:05:50,742
当打开我最喜欢的文档网站docs.gl
if I Just open up my favorite documentation website here, docs.gl

158
00:05:50,742 --> 00:05:53,375
我们需要写两行代码
there are two kind of lines of code that we have to write 

159
00:05:53,600 --> 00:05:58,666
最重要的是glVertexAttribPointer, 就在这里
the most important one though is glVertexAttribPointer which is right over here, right

160
00:05:59,066 --> 00:06:00,366
我将点击gl4链接
I'll click on the gl four link

161
00:06:00,366 --> 00:06:01,733
我们可以看到这里有什么
and we can see what we have here

162
00:06:01,733 --> 00:06:03,566
所以它需要很多参数
so it takes quite a few parameters in

163
00:06:03,633 --> 00:06:05,233
总的来说, 就是index(索引), size(大小), type(类型)
by the index, size, type

164
00:06:05,233 --> 00:06:06,500
normalized(标准化), stride(步幅)和pointer(指针)
normalized, stride and pointer

165
00:06:06,500 --> 00:06:07,966
那么, 让我们快速地过一遍
so let's go through them really quickly

166
00:06:08,150 --> 00:06:09,200
所以index是
so the index is the

167
00:06:09,200 --> 00:06:11,500
需要再次修改的共享信息顶点属性的索引
index of the share info vertex attribute to be modified again

168
00:06:11,500 --> 00:06:12,380
这没有多大意义
this doesn't make much sense

169
00:06:12,380 --> 00:06:13,566
如果你不知道这是怎么回事
if you don't know how this works

170
00:06:13,566 --> 00:06:17,200
基本上, 我们的着色器读取所有这些的方式是通过索引, 它是一个快照
basically, the way that our shader reads all this is by an index, it,s a picture

171
00:06:17,200 --> 00:06:18,466
它几乎像一个数组
it is almost like an array

172
00:06:18,466 --> 00:06:21,000
但数组中的类型可能不同
but the types in the array might be different

173
00:06:21,200 --> 00:06:24,750
这是一个索引, 表示你实际引用的是哪个属性
so, this is an index as to which attribute you're actually referring to 

174
00:06:24,750 --> 00:06:26,766
顺便说一下, 所有这些都被称为属性
all of these things by the way are called attributes

175
00:06:26,766 --> 00:06:27,866
并且这是我以其他方式提到的
and otherwise when I mentioned that

176
00:06:27,866 --> 00:06:30,033
顶点不仅仅由位置组成
a vertex is made up of more than just position

177
00:06:30,033 --> 00:06:31,166
对吧, 可能是位置
right, might be position

178
00:06:31,733 --> 00:06:34,100
纹理坐标, 法线, 颜色等等
texture coordinates, normal, colors whatever

179
00:06:34,233 --> 00:06:36,433
这些中的每一个就和位置一样, 都是一个属性
each one of those like a position is an attribute

180
00:06:36,433 --> 00:06:37,966
颜色是一种属性
a color is an attribute

181
00:06:38,066 --> 00:06:40,000
纹理坐标是一个属性
a texture coordinate is an attribute

182
00:06:40,000 --> 00:06:42,500
法线是一种属性, 它们都是属性
a normal is an attribute, they're all attributes

183
00:06:42,633 --> 00:06:44,666
所以, 这个index就是告诉我们, 嘿
so, this index is just telling us, hey

184
00:06:44,666 --> 00:06:46,533
这个属性的索引是什么
what index is this attribute at

185
00:06:46,766 --> 00:06:48,200
我这样说的原因是
the reason I say this is because

186
00:06:48,366 --> 00:06:50,233
一般来说, 如果我们有一个位置
typically if we have like a position

187
00:06:50,233 --> 00:06:52,733
例如, 在索引0处
for example, at index zero

188
00:06:52,733 --> 00:06:55,700
我们需要把它作为索引0来引用
we need to be able to refer to it as index zero

189
00:06:56,033 --> 00:06:58,033
那么, 我们来描绘一下吧
so, let's just picture this right

190
00:06:58,033 --> 00:07:03,000
我有三种属性, 位置, 纹理坐标和法线
I have three kind of attributes, I have position, texture coordinate and normal

191
00:07:03,000 --> 00:07:06,466
我需要能够说, 我想让我的位置在下标0处
I need to be able to say that I want my position to be at index zero

192
00:07:06,500 --> 00:07:10,100
纹理坐标在索引1, 法线在索引2
my texture coordinate at index one, and my normal to be at index two

193
00:07:10,366 --> 00:07:14,066
所以当我开始从着色器和显卡读取数据时
so that when I kind of start reading stuff from the shader side from the GPU side

194
00:07:14,533 --> 00:07:15,633
然后进入那个缓冲区
and I go into that buffer

195
00:07:15,633 --> 00:07:17,250
我可以简单地引用它们
I can simply reference them by 

196
00:07:17,250 --> 00:07:19,033
嘿, 请给我2号索引
hey, index two please

197
00:07:19,033 --> 00:07:20,533
然后, 我发现这将是我的法线
and I noticed that will be my normal

198
00:07:20,533 --> 00:07:22,066
因为我已经定义了那个缓冲区的布局
because I've kind of defined that layout

199
00:07:22,066 --> 00:07:23,233
这就是index(索引)
that's what an index is

200
00:07:23,533 --> 00:07:27,033
它只是缓冲区中实际属性的索引
it's just the index of that actual attribute in your buffer

201
00:07:27,066 --> 00:07:28,700
这里的size可能有点误导人
size here can be a bit misleading

202
00:07:28,700 --> 00:07:31,200
它是每个通用顶点属性的组件数
it's the number of components per generic vertex attribute

203
00:07:31,200 --> 00:07:32,900
你可以看到, 这里写得很清楚
you can see that it says here clearly

204
00:07:32,933 --> 00:07:34,433
它只能是1 2 3 4
that it must be 1 2 3 4

205
00:07:34,466 --> 00:07:36,775
所以, 这个size和字节没有关系
so again, this size has nothing to do with bytes 

206
00:07:36,775 --> 00:07:39,566
或者和它们实际占用了多少内存也没关系
or like actual how much memory these occupies

207
00:07:39,800 --> 00:07:41,433
它基本上是计数
it is basically the count

208
00:07:41,933 --> 00:07:44,866
所以我的意思是, 当我们在这里指定type时
so what I mean by that is when we specify the type here

209
00:07:45,233 --> 00:07:49,066
比如我们实际的顶点位置, GL_FLOAT(浮点型)
such as our actual vertex positions GL_FLOAT

210
00:07:49,366 --> 00:07:51,566
这就是提供的浮点数的数量
this is how many floats were providing

211
00:07:51,866 --> 00:07:55,200
显然这儿, 我们每个顶点有两个浮点数
so here clearly, we have two floats per vertex

212
00:07:55,333 --> 00:07:57,933
所以这个size是2
so this size will be two

213
00:07:57,933 --> 00:08:02,400
因为我们提供了一个两个分量的向量来表示我们的位置
because we're basically providing a two component vector that represents our position

214
00:08:02,566 --> 00:08:06,166
如果我们切换到我之前提到的那种3D坐标系
if we switch to that kind of 3D coordinate system as I mentioned earlier

215
00:08:06,333 --> 00:08:08,266
我们会把它设为3
we would be setting it to three

216
00:08:08,266 --> 00:08:11,000
因为这个属性有三个浮点数
because we have three floats for this actual attribute 

217
00:08:11,000 --> 00:08:13,166
好吧, 所以type如同我刚才解释的, 就是
all right, so type as I just explained is

218
00:08:13,333 --> 00:08:15,400
基本上就是我们提供的数据类型
basically the type of data that we're providing

219
00:08:15,400 --> 00:08:17,066
GL_FLOAT是我们需要的
GL_FLOAT is what we want

220
00:08:17,466 --> 00:08:19,633
normalized(标准化)，这有点棘手
normalized, this is a little bit more tricky

221
00:08:19,666 --> 00:08:22,266
我们真的不需要特别担心这个, 如果我们做
we don't really need to worry about this particularly, if we do

222
00:08:22,266 --> 00:08:25,066
如果我们处理的是浮点数, 因为它们已经被规范化了
if we're dealing with floats, because they already are normalized

223
00:08:25,100 --> 00:08:26,566
但基本上这是用来
but basically this is used for

224
00:08:26,566 --> 00:08:28,166
假设我们要指定一个字节
let's just say that we're specifying a byte

225
00:08:28,166 --> 00:08:30,133
在0到255之间
that is between zero and two fifty five

226
00:08:30,166 --> 00:08:31,466
因为这是我们颜色的值
because that's our color value

227
00:08:31,566 --> 00:08:36,500
它需要被规范化到0到1之间, 在我们的实际着色器中作为一个浮点数
that needs to be normalized to be between zero and one, as a float in our actual shader

228
00:08:36,500 --> 00:08:38,333
并且这就是我们实际要做的
and this is what we'll actually do it for us

229
00:08:38,533 --> 00:08:40,766
基本上, 这不是一个例子
so basically, this isn's an example of something

230
00:08:40,766 --> 00:08:42,866
这不是一个你可以在CPU上自己做的事情
that you can do yourself on the CPU side

231
00:08:42,866 --> 00:08:44,900
但你也可以让OpenGL替你做
but you can also let OpenGL do it for you

232
00:08:45,066 --> 00:08:45,966
如果你比较懒惰的话
if you're lazy

233
00:08:45,966 --> 00:08:47,100
或者如果你有点
or if you're kind of

234
00:08:47,100 --> 00:08:48,766
如果你只想让OpenGL为你做
if you just want OpenGL to do it for you

235
00:08:48,766 --> 00:08:51,750
所以我们将把这个设为false, 或者是指定的GL_FALSE
so we'll be setting this to false, or specifically GL_FALSE

236
00:08:51,750 --> 00:08:55,666
因为normalized实际上是一个整数GL_BOOLEAN
because normalized is actually a GL_BOOLEAN which is just an integer

237
00:08:55,666 --> 00:08:56,366
好了, 继续
all right

238
00:08:56,366 --> 00:09:00,966
stride指针, 这是很多人感到困惑的地方
stride pointer, this is where a lot of people get a little bit confused

239
00:09:00,966 --> 00:09:02,400
所以我想澄清一下
so I want to just be clear on this

240
00:09:02,800 --> 00:09:05,475
如文档所述, stride就是
stride is, as the documentation states

241
00:09:05,475 --> 00:09:09,300
连续通用顶点属性之间的字节偏移量
the byte offset between consecutive generic vertex attributes

242
00:09:10,550 --> 00:09:12,350
这个措辞就是
this is worded in

243
00:09:12,350 --> 00:09:14,875
不太清楚他们为什么这样描述它
not sure why they worded it like this

244
00:09:14,875 --> 00:09:17,166
但基本上, stride就是
but basically, what the stride is

245
00:09:17,166 --> 00:09:20,966
就是每个顶点之间的字节数
is the amount of bytes between each vertex

246
00:09:21,166 --> 00:09:24,233
所以, 在我们的例子中, 这是一个虚构的例子
so again, in our example, now kind of made-up example

247
00:09:24,233 --> 00:09:25,566
如果我们有一个位置
if we have a position

248
00:09:25,733 --> 00:09:28,266
我们有一个纹理坐标和一个法线
we have a texture coordinate and we have a normal

249
00:09:28,366 --> 00:09:31,566
我们说, 位置是一个三个分量的向量
let's just say, the position is a three component vector

250
00:09:31,650 --> 00:09:34,800
纹理坐标是一个两个分量的矢量, 或者两个浮点数
the texture coordinate is a two component vector, or two floats

251
00:09:34,800 --> 00:09:37,900
并且法线也是三个分量
and then the normal is three components once again

252
00:09:37,966 --> 00:09:40,266
明白吧, 所以, 我们有三个浮点数(位置)，一共12个字节
right, so we have three floats that's 12 bytes

253
00:09:40,400 --> 00:09:42,866
加上纹理坐标的两个浮点数
plus two floats for the texture coordinate

254
00:09:42,866 --> 00:09:45,366
那是另外8个字节, 所以我们在20个字节上
that's another eight bytes, so we're on 20 bytes

255
00:09:45,366 --> 00:09:47,533
然后法线再加12个字节
and then another 12 bytes for the normal

256
00:09:47,533 --> 00:09:50,033
所以一共32字节, 这就是我们的stride
so 32 bytes, that is our stride

257
00:09:50,125 --> 00:09:54,566
因为它是每个顶点的字节大小
because it's basically the size of each vertex

258
00:09:54,833 --> 00:09:57,400
这很重要的原因是因为, 如果OpenGL
the reason this is important is because if OpenGL

259
00:09:57,400 --> 00:09:59,166
并且这也是它被称为stride的原因, 是因为
and the reason it's called stride as well is because

260
00:09:59,166 --> 00:10:01,966
如果我们想从一个顶点跳到下一个顶点
if we want to jump from one vertex to the next

261
00:10:01,966 --> 00:10:05,033
所以, 例如, 我想查找索引1
so, for example, I want to look up index number 1

262
00:10:05,066 --> 00:10:07,466
从0开始, 0是第一个顶点
so from 0, 0 is our first vertex

263
00:10:07,466 --> 00:10:11,033
我想跳到第二个顶点, 也就是索引1
I want to jump to our second vertex which is index number 1

264
00:10:11,433 --> 00:10:14,500
我需要在缓冲区中加上32个字节
I need to go plus 32 bytes into the buffer

265
00:10:14,733 --> 00:10:17,133
所以, 如果我们有一个指针, 指向缓冲区的开始
so, if we have a pointer to the beginning of our buffer

266
00:10:17,166 --> 00:10:18,766
然后经过缓冲区的32个字节
and I go 32 bytes into it

267
00:10:18,766 --> 00:10:21,933
我应该在下一个顶点的起点
I should be at the very start of the next vertex

268
00:10:21,966 --> 00:10:23,233
这就是stride
that is what the stride is

269
00:10:23,233 --> 00:10:26,533
所以, 记住这一点. 另一方面, pointer是
so, just remember that. the pointer on the other hand is

270
00:10:26,700 --> 00:10:29,666
根据这个描述, 第一个组件的一个偏移量…
as this states, a offset of the first component of the

271
00:10:30,200 --> 00:10:31,733
说实话, 我都不想读这个
I don't even want to read this to be honest

272
00:10:31,733 --> 00:10:32,900
它是如此令人困惑
it's so confusing

273
00:10:33,466 --> 00:10:37,533
pointer是指向实际属性的指针
pointer is a pointer into the actual attribute

274
00:10:37,733 --> 00:10:42,466
所以, 这个已经在顶点的空间里了, 对吧
so, this is already inside the space of the vertex, right

275
00:10:42,466 --> 00:10:43,933
所以你只是假装
so you're just pretend

276
00:10:43,933 --> 00:10:45,900
不用担心有多少个顶点, 如果你有很多的话
don't worry about how many vertices, you have anymore

277
00:10:45,900 --> 00:10:48,833
你就假装只有一个顶点, 我有一个顶点
pretend you only have one vertex, I have one vertex

278
00:10:48,900 --> 00:10:52,566
在里面, 我有位置, 纹理坐标和法线
and inside there, I have position, texture coordinate, and normal

279
00:10:52,900 --> 00:10:55,533
每一个的偏移量以字节为单位是多少, 对吧
what is the offset of each of those in bytes, right

280
00:10:55,766 --> 00:10:57,700
所以, 对于位置, 偏移量为零
so, for position, the offset will be zero

281
00:10:57,700 --> 00:11:00,366
因为它是缓冲区的第一个字节
because it's the very first byte of our buffer

282
00:11:00,366 --> 00:11:04,566
我们实际顶点的第一个字节就是位置, 对吧
the very first byte of our actual vertex is the position, right

283
00:11:04,833 --> 00:11:06,533
然后我们前进12个字节
then we go 12 bytes forward

284
00:11:06,666 --> 00:11:09,400
我们到达了纹理坐标的开始
and we reach the beginning of the texture coordinate

285
00:11:09,433 --> 00:11:11,666
所以, 对于我的纹理坐标属性
so, for my texture coordinate attribute

286
00:11:11,666 --> 00:11:13,066
这个值(pointer)是12
this value would be 12

287
00:11:13,066 --> 00:11:15,600
因为在12个字节处就是我们开始的地方
because 12 bytes into it is where we begin

288
00:11:15,733 --> 00:11:18,100
并且最后再前进8字节
and finally eight bytes into that

289
00:11:18,533 --> 00:11:21,100
我们得到顶点法线, 对吧
we get to the vertex normal, right

290
00:11:21,100 --> 00:11:24,433
所以, 从开始算起第20个字节处就是顶点法线
so 20 bytes from the beginning is my vertex normal

291
00:11:24,533 --> 00:11:26,466
所以, 对于顶点法线属性
so, for my vertex normal attribute

292
00:11:26,700 --> 00:11:28,966
20是这个pointer的值
20 would be the value of this pointer

293
00:11:29,200 --> 00:11:33,833
现在, 我们不再写0 12 20这样泛指的东西
now, instead of just writing generic things like zero, twelve and twenty

294
00:11:34,000 --> 00:11:36,266
因为这可能会让人感到困惑, 而且不仅如此
because that can get a bit confusing, and not only that

295
00:11:36,266 --> 00:11:38,866
但如果你重新安排布局之类的
but if you actually rearrange your layout or something like that

296
00:11:38,866 --> 00:11:41,066
你得手动重新计算
you'll have to recalculate it all manually

297
00:11:41,166 --> 00:11:44,066
这儿有一些宏, 以及
there are macros and kind of well

298
00:11:44,233 --> 00:11:46,500
它确实是一个叫做偏移量的宏
it really is a macro called offset

299
00:11:46,500 --> 00:11:49,133
实际上, 德国人用箭头算符证明了这一点
of actually, German demonstrated that in the arrow operator

300
00:11:49,133 --> 00:11:50,766
如果你们看了我的箭头运算符的视频
if you guys watched my arrow operator video

301
00:11:50,900 --> 00:11:53,466
那应该, 因为它对c++很重要
which is should because it's important for c++

302
00:11:54,166 --> 00:11:56,000
我实际上演示了偏移
I actually kind of demonstrated offset off

303
00:11:56,000 --> 00:11:58,266
实际上是我自己写的, 而不是用宏
I actually wrote it myself, instead of using a macro

304
00:11:58,266 --> 00:12:00,100
但实际上, c++库
but the library actually, the c++ library

305
00:12:00,100 --> 00:12:02,050
在状态库中会为你提供宏偏移量
in the state library provides you with an offset of macro

306
00:12:02,400 --> 00:12:03,966
实际上, 你可以用它来
which you can use to actually

307
00:12:03,966 --> 00:12:06,933
查找结构或类中某物的偏移量
find the offset of something in a struct or class

308
00:12:07,400 --> 00:12:10,500
所以你也可以用同样的方法来处理stride, 
so you can use things to kind of same with stride as well,

309
00:12:10,500 --> 00:12:13,266
你可以使用宏之类的东西
you can use kind of macros and stuff like that

310
00:12:13,266 --> 00:12:14,933
为你自己自动化这些东西
to automate this stuff for yourself

311
00:12:14,933 --> 00:12:17,833
这样你就不用把值设置成
so that you don't have to just be putting values like

312
00:12:17,966 --> 00:12:20,625
就像我刚说的12或32那样的stride
12 or 32 as I said for the stride 

313
00:12:20,625 --> 00:12:22,900
手动, 我只是向你解释应该怎么做
manually, I'm just explaining to you what actually should be

314
00:12:22,900 --> 00:12:23,700
但就
but just

315
00:12:24,366 --> 00:12:28,600
希望这完整地解释了VertexAttribPointer函数
hopefully this explains the entire kind of VertexAttribPointer function

316
00:12:28,600 --> 00:12:31,500
因为这可能会让你困惑, 如果你才刚开始的话
because again it's something that can be confusing if you're just starting out

317
00:12:31,800 --> 00:12:34,733
但它实际上非常简单, 并确保它是对的
but it is actually really simple, and make sure that it's correct

318
00:12:34,733 --> 00:12:37,833
因为如果你在这里得到哪怕一个字节
because if you get even one byte kind of out of place here

319
00:12:38,066 --> 00:12:39,866
你会得到一些奇怪的东西
you're going to get weird artifacts

320
00:12:39,886 --> 00:12:43,125
可能在你的渲染中, 或者只在一个黑窗口中, 或者类似的东西
probably in your rendering, or just a black screen, or something like that 

321
00:12:43,125 --> 00:12:46,600
好了, 回到我们的代码中, 我们现在终于可以使用这个了
okay, so back here in our code, we can finally use this, now

322
00:12:47,000 --> 00:12:50,033
所以对于这个已经绑定了的缓冲区我能做什么, 这很重要
so what I can do is with the buffer actually bound, that's important

323
00:12:50,033 --> 00:12:53,766
我要写glVertexAttribPointer, 好了
I'm just going to write glVertexAttribPointer, all right

324
00:12:53,766 --> 00:12:55,575
继续, 第一个参数是index
so again, first parameter is the index 

325
00:12:55,575 --> 00:12:58,466
现在, 这是一个非常简单的例子, 就像我之前提到的
now, this is a really simple case, as I mentioned earlier

326
00:12:58,500 --> 00:13:00,666
我们只有位置, 所以首先
we just have positions, so first of all

327
00:13:00,733 --> 00:13:02,833
我们只有一个顶点属性
we only have one vertex attribute

328
00:13:02,833 --> 00:13:05,175
所以我们只需要调用这个函数一次
so we only need to call this function once 

329
00:13:05,175 --> 00:13:07,733
因为这里我们只指定了一个属性
because we're just specifying a single attribute here

330
00:13:08,000 --> 00:13:11,466
这个index, 当然, 是0, 因为它是第一个属性
the index, of course, will be zero, because it's the first attribute

331
00:13:11,550 --> 00:13:14,433
这个size, 记住size是指组件数量
the size, remember the size is the component count

332
00:13:14,433 --> 00:13:16,766
与实际大小和字节无关
not anything to do with actual size and bytes

333
00:13:16,766 --> 00:13:20,233
那么, 有多少个浮点数代表这个特定的顶点属性
so, how many floats represent this specific vertex attribute

334
00:13:20,333 --> 00:13:22,900
2, 所以我就写2, 接下来
two, so am I write two, next we have

335
00:13:23,766 --> 00:13:24,833
好吧, 这是一种…
well this one way

336
00:13:24,966 --> 00:13:26,766
接下来是type
next we have the type

337
00:13:26,766 --> 00:13:29,100
所以, 这就是我们这里的数据类型
so, this is going to be the type of data that we have here

338
00:13:29,100 --> 00:13:30,300
显然, 它们都是浮点数
clearly they're floats

339
00:13:30,333 --> 00:13:31,800
所以我们要输入GL_FLOAT
so we're going to type in GL_FLOAT

340
00:13:31,833 --> 00:13:33,966
接下来, 我们要考虑是否要将它们标准化
next, we have whether or not we want them to be normalized

341
00:13:33,966 --> 00:13:34,900
不, 它们已经是浮点型的了
no, they're already floats

342
00:13:34,900 --> 00:13:38,175
它们已经在我们想要的空间中了, 所以是GL_FALSE
they're already in the space that we want them to be, so GL_FALSE

343
00:13:38,175 --> 00:13:39,733
接下来是stride
next, we have the stride

344
00:13:39,800 --> 00:13:40,633
正如我提到的
now as I mentioned

345
00:13:40,633 --> 00:13:43,566
这个stride是每个顶点之间的字节数
the stride is the amount of bytes that we have between each vertex

346
00:13:43,566 --> 00:13:46,400
这是第一个顶点, 第二个顶点, 第三个顶点
so this is our first vertex, second vertex, third vertex

347
00:13:46,400 --> 00:13:48,933
显然, stride是两个浮点型的大小, 对吧
clearly, the stride is the size of two floats, right

348
00:13:49,200 --> 00:13:51,166
所以我们可以写成8
so what we could write is just eight

349
00:13:51,300 --> 00:13:55,166
基本上, 我们也可以写sizeof(float)*2
basically, we could also write size of float times two

350
00:13:55,400 --> 00:13:58,566
这可能是我们实现自动计算的最好方法
and that's probably our best way to kind of automate that

351
00:13:58,566 --> 00:14:01,366
也就是说, 让它尽可能的容易阅读
so to speak and make it as easy to read as possible here

352
00:14:01,500 --> 00:14:04,366
因为我们处理的不是结构之类的东西
because we're not dealing with something like a structure or anything like that

353
00:14:04,366 --> 00:14:07,750
最终, 当我们得到的不仅仅是每个顶点的位置
eventually when we have more than just kind of a position per vertex

354
00:14:07,750 --> 00:14:10,333
我们开始引入像坐标和法线这样的东西
and we start to introduce things like that your coordinates and normals

355
00:14:10,333 --> 00:14:13,266
我们会有一个结构, 组成一个独立的顶点
we will have a struct that makes up a single vertex

356
00:14:13,266 --> 00:14:16,833
从这个意义上说, 我们可以把结构的大小作为一个stride传递过去
and in that sense, we could just pass in the size of that struct as a stride

357
00:14:16,833 --> 00:14:17,700
这很好
and that would be fine

358
00:14:17,733 --> 00:14:19,700
但现在, sizeof(float)*2
but for now, size of float times two

359
00:14:19,833 --> 00:14:23,375
就是你需要向前移动到达第二个顶点的字节数
is how much you need to go forward to get to the second vertex 

360
00:14:23,375 --> 00:14:25,233
我只是把它说得非常清楚
and just to make that super clear

361
00:14:25,233 --> 00:14:26,633
因为我们这里只有一个属性
because we only have one attribute here

362
00:14:26,633 --> 00:14:29,766
这是我们到达第二个顶点所需要的字节总量
it's the amount that we need to go forward to get to the second vertex

363
00:14:29,766 --> 00:14:31,366
而不是第二个属性
not the second attribute

364
00:14:31,366 --> 00:14:32,066
明白吧
okay

365
00:14:32,066 --> 00:14:35,566
那是下一个参数pointer
that's kind of what this next parameter is the pointer

366
00:14:35,800 --> 00:14:39,208
记住, 你可以看到这实际上是一个指针
now keep in mind, you can see here that is actually a pointer

367
00:14:39,208 --> 00:14:41,433
它接受的是一个指针而不是一个数字
it's taking in a pointer not a number

368
00:14:41,600 --> 00:14:43,600
这可能有点令人困惑
so this might be a little bit confusing

369
00:14:43,900 --> 00:14:45,633
但它仍然只是一个数字
but it is still just a number

370
00:14:45,864 --> 00:14:47,850
因为记住指针是数字
because remember pointers are numbers

371
00:14:47,850 --> 00:14:49,500
如果你不能完全理解指针
if you don't understand pointers fully

372
00:14:49,500 --> 00:14:52,233
在上面观看我关于指针的视频
watch my video on pointers up there

373
00:14:52,233 --> 00:14:54,533
因为这样你就清楚多了
because that's going to clear so much up for you

374
00:14:54,566 --> 00:14:57,000
因为这个特殊属性是第一个
so since this particular attribute is the first

375
00:14:57,000 --> 00:14:58,733
并且, 在这里, 这个属性是唯一一个
and in this case only attribute

376
00:14:58,766 --> 00:15:00,100
这个是0
this is just going to be zero

377
00:15:00,100 --> 00:15:01,633
你可以像这样传递它
and you can just pass it in like that

378
00:15:01,800 --> 00:15:03,766
如果我们有另一个属性
if we had another attribute

379
00:15:03,766 --> 00:15:04,300
举个例子
for example, let's just say

380
00:15:04,300 --> 00:15:06,933
纹理坐标从这里开始或类似的东西
texture coordinate kind of started here or something like that

381
00:15:06,933 --> 00:15:10,100
然后我们需要传递偏移量到那个纹理坐标
then we would actually have to pass in the offset to that texture coordinate

382
00:15:10,100 --> 00:15:11,500
8个字节
which would be eight bytes

383
00:15:11,500 --> 00:15:12,933
所以, 我们就可以像这样写上8
so we could just write eight like that

384
00:15:13,300 --> 00:15:14,266
如果你试着这么做
if you try and do that

385
00:15:14,266 --> 00:15:15,600
在这儿, 你会得到一个错误
you're going to get an error here

386
00:15:15,600 --> 00:15:17,300
因为我们想传入8
because we're trying to pass in eight

387
00:15:17,500 --> 00:15:19,266
然而它需要是一个常量void指针
and it needs to be a constant void pointer

388
00:15:19,300 --> 00:15:23,133
解决这个问题的方法就是把8转换成一个常量void指针
the way you fix that is you just cast eight to a constant void pointer

389
00:15:23,133 --> 00:15:25,500
我觉得有点不靠谱, 不过没关系
I see a bit dodgy or whatever, but it's totally fine

390
00:15:25,500 --> 00:15:26,433
这就是你应该做的
that's what you're meant to do

391
00:15:26,433 --> 00:15:27,850
当然, 如果你做得对的话
and of course, if you were doing this properly 

392
00:15:27,850 --> 00:15:30,633
你有一个真正的应用或者引擎之类的东西
and you had a real kind of application or engine or something like that

393
00:15:30,800 --> 00:15:33,633
你可能需要一个结构来定义你的顶点
you would probably have a struct to actually define your vertex

394
00:15:33,800 --> 00:15:36,025
然后你可以使用宏偏移量
and then you could just use the offset of macro

395
00:15:36,025 --> 00:15:38,533
为了指出这对于来说是什么, 而不是只写8
to figure out what this is for you instead of just writing eight

396
00:15:38,533 --> 00:15:39,366
或者类似的东西
or something like that

397
00:15:39,400 --> 00:15:40,200
因为这
because that

398
00:15:40,266 --> 00:15:41,354
这不可是好方法
that's not a good way to go  

399
00:15:41,354 --> 00:15:43,866
不管怎样, 对我们来说, 它是零
anyway, of course, for us it's zero

400
00:15:43,866 --> 00:15:45,000
就这样, 就这样
there you go, that's it

401
00:15:45,000 --> 00:15:46,925
这就是在这种情况下使用这个函数的方法
that's how you use this function in this case 

402
00:15:46,925 --> 00:15:48,933
它应该可以正常工作
and it should work just fine

403
00:15:49,066 --> 00:15:51,266
但等等, 这儿总是
but wait, there is always

404
00:15:51,475 --> 00:15:53,133
总是忘了一些东西
always something that I forget

405
00:15:53,166 --> 00:15:54,966
你需要写一些东西才能让它运行
that you need to write to actually make this work

406
00:15:54,966 --> 00:15:58,466
我总是忘记这一点当我开始写OpenGL的东西时
I always forget this when I start writing OpenGL stuff from scratch

407
00:15:58,675 --> 00:16:00,333
因为很明显, 如果你和我一样
because obviously if you're kind of like me

408
00:16:00,333 --> 00:16:03,866
你通常不会经常编写这样的代码
you don't typically write code like this often

409
00:16:03,900 --> 00:16:05,570
因为这是你第一次做的事情
because this is something that you kind of do the first time

410
00:16:05,570 --> 00:16:07,266
当你设置一个新引擎的时候
when you're setting up a new engine

411
00:16:07,333 --> 00:16:08,700
然后你就忘了
and then you forget about it

412
00:16:09,133 --> 00:16:10,900
但我们还需要一行代码
but there is one more line of code that we need

413
00:16:10,900 --> 00:16:12,733
否则就会出现黑屏
otherwise we are just going to get a black screen

414
00:16:12,866 --> 00:16:13,366
这就是
and that is

415
00:16:13,366 --> 00:16:15,966
实际上, 我们需要启用顶点属性
we need to actually enable that vertex attribute

416
00:16:15,966 --> 00:16:17,475
所以, 回到我们的文档中
so back in our documentation here 

417
00:16:17,475 --> 00:16:19,750
我真的希望这个文档能说
I really wish that this documentation actually said 

418
00:16:19,750 --> 00:16:23,366
关于启用或必须调用enable的一些事
something about enabling or having to call enable

419
00:16:23,466 --> 00:16:25,466
事实上, 我不记得是否有
in fact I don't remember if it does

420
00:16:25,525 --> 00:16:26,700
是的, 它说了
yeah, it does

421
00:16:26,700 --> 00:16:27,866
最后, 它说
at the end, it says

422
00:16:27,933 --> 00:16:32,700
要启用或禁用通用的顶点属性数组, 调用glEnableVertexAttribArray
to enable or disable a generic vertex attribute array, call glEnableVertexAttribArray

423
00:16:32,700 --> 00:16:34,033
如果我们去看看这个函数
so if we go to this function

424
00:16:34,200 --> 00:16:36,666
你会看到它能做什么, 它说…
you'll see what this does is it enables, it says blah blah

425
00:16:36,666 --> 00:16:37,966
但基本上我们需要传入
but basically we take in

426
00:16:38,133 --> 00:16:39,266
这就是我们了对这个函数感兴趣的地方
this is the function we're interested in

427
00:16:39,266 --> 00:16:40,966
我们基本上只需要传入索引
we basically just take in the index

428
00:16:41,000 --> 00:16:43,866
通用顶点的索引绝对是启用或禁用的
the index of the generic vertex is absolutely enabled or disabled

429
00:16:43,866 --> 00:16:45,000
回到我们的代码
so back in our code

430
00:16:45,100 --> 00:16:46,833
我喜欢在做指针之前先做这个
I like to do this before I do the pointer

431
00:16:46,833 --> 00:16:48,000
这真的不重要
it doesn't really matter

432
00:16:48,050 --> 00:16:49,666
OpenGL当然是一个状态机
OpenGL of course is a state machine

433
00:16:49,666 --> 00:16:52,025
它不会检查它是否被启用
it's not like it's going to check to see if it's enabled

434
00:16:52,025 --> 00:16:53,506
也不会去检查如果没有启动的话
and they're not do this if it's not

435
00:16:53,853 --> 00:16:54,600
那样没关系
doesn't matter like that

436
00:16:54,633 --> 00:16:55,766
你可以在任何地方调用它
you can call it anywhere you like

437
00:16:55,766 --> 00:16:57,900
只要你的实际缓冲区是绑定的
as long as your actual buffer is bound

438
00:16:57,966 --> 00:17:01,766
那么, 我们就去调用glEnableVertexAttribArray
so we're going to call glEnableVertexAttribArray

439
00:17:01,900 --> 00:17:04,333
然后我们要启用的索引是0
and then the index we want to enable which is zero

440
00:17:04,766 --> 00:17:05,866
好了, 就这样
okay, and that is it

441
00:17:05,866 --> 00:17:08,000
在这种情况下, 这两行代码就是你需要做的全部
these two lines of code are all you need to do in this case

442
00:17:08,000 --> 00:17:11,300
告诉OpenGL缓冲区的布局是什么
to tell OpenGL what the layout of our buffer is

443
00:17:11,566 --> 00:17:13,366
理论上, 如果我们有一个着色器
and theoretically if we had a shader

444
00:17:13,633 --> 00:17:15,266
下一集我们会讲那个
which we're going to have in the next episode

445
00:17:15,366 --> 00:17:17,500
我们最终就可以在屏幕上看到三角形了
we'll be able to finally see our triangle on screen

446
00:17:17,500 --> 00:17:17,966
在这儿
going up here

447
00:17:17,966 --> 00:17:20,100
我要把这个小错误去掉
I'm just going to remove this little error here

448
00:17:20,966 --> 00:17:22,100
这个多余的浮点数
this extra kind of float

449
00:17:22,100 --> 00:17:23,600
我加进去只是为了演示
that I added just for demonstration

450
00:17:23,833 --> 00:17:24,566
就是这样
and that's it

451
00:17:24,566 --> 00:17:25,733
总结一下
so basically to summarize

452
00:17:25,733 --> 00:17:27,133
这是我们今天写的代码
this is the code that we've written today

453
00:17:27,300 --> 00:17:28,300
希望大家喜欢这个视频
hope you guys enjoyed this video

454
00:17:28,300 --> 00:17:30,000
如果你喜欢的话, 就点击那个点赞按钮
if you did, hit that like button

455
00:17:30,300 --> 00:17:32,466
你也可以加入我的discord
you can also go and join my discord a discord

456
00:17:32,466 --> 00:17:34,500
blah blah
or confidenceer the channel become such discord 

457
00:17:34,500 --> 00:17:36,300
这基本上是一个社区
which is just basically a community of

458
00:17:36,300 --> 00:17:37,433
人们在谈论这样的事情
people talking about stuff like this

459
00:17:37,433 --> 00:17:38,833
你可以在那里讨论这一集
you can discuss the episode there

460
00:17:39,166 --> 00:17:41,425
或者你也可以在下面的评论区留言
or you can leave a comment in the comment section below

461
00:17:41,425 --> 00:17:42,433
如果你喜欢这样的话
if you prefer to do it that way

462
00:17:42,433 --> 00:17:44,233
我真心建议你加入这discord
I really do recommend you join the discord though

463
00:17:44,233 --> 00:17:47,566
这是一个很棒的社区, 你可以在那里提问
that's a great community of people where you can ask questions about

464
00:17:47,566 --> 00:17:49,933
所有你在视频中见过的东西
everything that you kind of seen these videos as well as

465
00:17:50,200 --> 00:17:52,733
你知道, 如果你的代码不能工作之类的, 你就会得到帮助
you know get help with your code not working or stuff like that

466
00:17:52,733 --> 00:17:54,133
所以一定要加入
so definitely join up there

467
00:17:54,333 --> 00:17:55,733
如果你真的想支持这个系列
if you really want to support the series

468
00:17:55,733 --> 00:17:56,766
你想看更多的视频
and you want to see more videos

469
00:17:56,766 --> 00:17:58,533
你想早点看视频
and you want to see videos early and

470
00:17:58,766 --> 00:18:00,533
获得一堆其他类型的奖励
get a bunch of other kind of rewards

471
00:18:00,566 --> 00:18:03,266
以及我实际上开始了一场聚会
as well as I've actually started doing a hangout

472
00:18:03,266 --> 00:18:04,533
一个一个小时的聚会
a one-hour hangout

473
00:18:04,800 --> 00:18:07,366
和所有的赞助人一起
with all of the patrons on a specific tier

474
00:18:07,766 --> 00:18:09,900
我们聊上一个小时的话题
where we just basically talk about stuff for an hour

475
00:18:09,900 --> 00:18:11,733
昨天刚办了一个, 很顺利
just did one yesterday went really well

476
00:18:11,933 --> 00:18:12,733
所以一定要加入
so definitely join up there

477
00:18:12,733 --> 00:18:15,075
如果你感兴趣的话, patreon.com/TheCherno
if you're interested in that patreon.com/TheCherno

478
00:18:15,075 --> 00:18:16,550
这真的有助于支持这个系列
it really does help support the series 

479
00:18:16,550 --> 00:18:19,766
确保我能尽可能多地制作这些视频
and make sure that I can kind of keep making these videos as much as possible

480
00:18:19,766 --> 00:18:21,300
下次我们会写一些着色器
next time we're gonna write some shader

481
00:18:21,300 --> 00:18:23,066
那集可能会很长
it's probably gonna be quite a lengthy episode

482
00:18:23,066 --> 00:18:26,200
因为实际上会有很多代码
because there is actually going to be quite some code

483
00:18:26,200 --> 00:18:27,000
我需要去设置
we need to set up to

484
00:18:27,000 --> 00:18:29,566
让着色器在OpenGL中编译和链接
actually get shaders to compile and link in OpenGL

485
00:18:29,866 --> 00:18:31,600
但是一旦我们把它弄下来
but once we kind of get that down

486
00:18:31,600 --> 00:18:33,733
我们终于就可以在屏幕上看到三角形了
we'll finally have our triangle on the screen

487
00:18:33,733 --> 00:18:35,166
所以这应该是非常令人兴奋的
so it should be really exciting

488
00:18:35,300 --> 00:18:36,900
下次见, 拜
I'll see you guys next time goodbye

