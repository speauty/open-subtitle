1
00:00:00,133 --> 00:00:03,633
嘿，你们好，我是TheCherno，欢迎回到我的OpenGL系列教程
hey, what's up guys, my name is TheCherno, and welcome back to my OpenGL series

2
00:00:03,866 --> 00:00:06,433
那么今天我们会讲OpenGL中的纹理
so today we're gonna be talking all about textures in OpenGL

3
00:00:06,433 --> 00:00:09,300
我将从定义纹理到底是什么开始
I'm gonna start by defining what exactly a texture is

4
00:00:09,933 --> 00:00:12,033
所以当大多数人想到纹理的时候
so when most people think of textures

5
00:00:12,033 --> 00:00:16,933
他们真的只会想到在一个游戏中的3D对象上呈现图像
they really just think of having an image on a 3D object in a game

6
00:00:17,133 --> 00:00:19,166
当然，不一定非得是3D对象
it doesn't have to be a 3D object of course

7
00:00:19,166 --> 00:00:24,766
而你们在PS或画图等等中创建的图像
but some kind of image that you've created in something, like photoshop, a paint or whatever

8
00:00:24,833 --> 00:00:30,733
让它出现在你们的图形应用程序中
having that on some kind of surface in your graphical application

9
00:00:30,733 --> 00:00:32,666
那就是纹理的本质
that is essentially what a texture is

10
00:00:32,666 --> 00:00:36,400
或者至少是大部分人眼中的纹理
or at least that's how most people actually kind of think of a texture

11
00:00:36,666 --> 00:00:44,000
现在，除了这些，关于纹理的理解，比我刚才描述的要多得多
now, beyond that textures can really be, a lot more than just what I just described

12
00:00:44,100 --> 00:00:46,466
纹理可以用于很多事情
textures can be used really for a lot of things

13
00:00:46,466 --> 00:00:50,066
当我们讲到一些非常复杂的图形技术时，我们会发现那些
and we'll discover that, when we get into some pretty complicated graphics techniques

14
00:00:50,300 --> 00:00:56,466
但现在我只想让你们把纹理看作是我们可以使用的图像
but for now I just want you to think about a texture as essentially an image that we can use

15
00:00:56,800 --> 00:00:58,066
当我们渲染一些东西的时候
when we're rendering something

16
00:00:58,566 --> 00:01:03,566
那么我实际能做的就是设计或创造某种图像
so what I can actually do is design or create some kind of image

17
00:01:03,566 --> 00:01:08,133
不管是一张照片，还是画布上的一条弯弯曲曲的线
whether that be a photograph or maybe just a squiggly line on a canvas

18
00:01:08,133 --> 00:01:12,800
或者是纯色或者类似的颜色，任何类似的颜色
or maybe like a kind of solid color or something like that, anything like that

19
00:01:12,833 --> 00:01:17,900
我可以在我的电脑中创建任何图像文件，然后把它上传到我的显存中
I can create any image file in my computer, and then I can actually upload it to my GPU's memory

20
00:01:18,000 --> 00:01:22,500
然后在我的着色器中使用它来绘制我现在正在做的任何东西
and use that in my shader for whatever kind of drawing I'm doing now

21
00:01:22,500 --> 00:01:27,633
这可能像在我们的OpenGL程序中画一个矩形一样简单
this might be something as simple as just drawing a rectangle in our OpenGL program

22
00:01:27,650 --> 00:01:32,400
它包含了渲染纹理的元素，这样我们就可以在游戏中看到纹理
the contained that is actually rendering that texture, so that we can see the texture in our game

23
00:01:32,800 --> 00:01:35,150
或者也可能是更复杂的东西
or it might be something a lot more complicated

24
00:01:35,150 --> 00:01:39,950
就像使用预先计算好的数学值，将其融入到我们的纹理中
like using kind of prep calculated mathematical values, that are baked into our texture

25
00:01:39,950 --> 00:01:42,125
然后在着色器中对它们进行采样
and then being able to sample them in our shader

26
00:01:42,125 --> 00:01:45,046
这样我们可以做一些很酷的灯光效果，但现在
so that we can do some cool lighting effects, but for now

27
00:01:45,046 --> 00:01:50,233
它只会在OpenGL应用中从计算机获取图像到表面
it's just going to be getting an image from our computer onto a surface in our OpenGL application

28
00:01:50,633 --> 00:01:52,733
那么让我们来看看我们都有什么
so let's take a look at what we've got here

29
00:01:52,900 --> 00:01:54,533
如果我们现在启动应用
so if we launch our application right now

30
00:01:54,533 --> 00:01:56,600
这样我们就能想起我们到底在哪里了
just so that we can remember where we're actually at

31
00:01:56,700 --> 00:01:59,733
你们会看到我们有这样一个动态颜色的矩形
you'll see that we just had this kind of rectangle with a pulsating color

32
00:02:00,200 --> 00:02:01,566
现在我们今天能做的
now what we're going to do today

33
00:02:01,566 --> 00:02:05,733
实际上就是在那个矩形上绘制一个纹理，取代这种纯色
is actually draw a texture on that rectangle, instead of this kind of solid color

34
00:02:06,166 --> 00:02:09,666
现在如果我看这个OpenGL程序的实际目录
now if I look at my actual directory for this OpenGL program

35
00:02:09,666 --> 00:02:13,233
我已经创建了这个res文件夹，在那个里面，有个textures文件夹
I've made this resources folder, and inside there, I've made a folder called textures

36
00:02:13,233 --> 00:02:14,466
只有一张单独的图片
which just has a single image

37
00:02:14,466 --> 00:02:16,733
就是我这里的这个ChernoLogo
and it's going to be this ChernoLogo that I have here

38
00:02:16,925 --> 00:02:21,600
这就是我们要在程序中那个矩形上绘制的东西
this is what we're actually going to draw on top of that rectangle that we have in our program

39
00:02:21,733 --> 00:02:22,566
那么我们如何实现那个
so how do we do that

40
00:02:22,566 --> 00:02:26,733
我们如何从电脑上的物理png文件转变过来
how do we go from having a physical kind of png file on our computer

41
00:02:26,866 --> 00:02:28,833
才能在着色器中进行采样
to actually being able to sample it in our shader

42
00:02:28,833 --> 00:02:31,700
我们可以把它绘制在屏幕上，它是怎么工作的
so that we can draw it on the screen, how does that work

43
00:02:31,900 --> 00:02:37,700
第一步，我们需要以某种方式将图像加载到CPU内存中，对吧
well step one is we need to load that image somehow into our CPU memory, right

44
00:02:37,966 --> 00:02:40,133
那么在这个例子中，它是一张png图片
so in this case, it's a png

45
00:02:40,533 --> 00:02:44,466
现在我不打算深入讨论，在游戏中如何使用纹理以及它的格式化
now I'm not going to get into, how games use textures and what formats that

46
00:02:44,466 --> 00:02:49,133
所有那些都在游戏引擎系列中，png并未真正用于游戏引擎中
all that will see for the game engine series, png is aren't really used in game engine

47
00:02:49,133 --> 00:02:52,633
由于各种原因，大多数游戏引擎都有自己的纹理格式
most game engines have their own texture format for various reasons

48
00:02:52,766 --> 00:02:55,400
但现在，这都是关于载入OpenGL的
but for now, just because again this is all about loading OpenGL

49
00:02:55,400 --> 00:02:59,500
我们有一个png图像文件，我们需要以某种方式加载它
we do have a png image file, so what we need to do is load that somehow 

50
00:02:59,500 --> 00:03:02,800
现在png格式不是特别复杂
now png format isn't particularly complicated

51
00:03:02,800 --> 00:03:04,466
但这儿有几种
but there are a few kind of

52
00:03:04,466 --> 00:03:07,433
有一些不同的像素格式
there are a few different pixel formats inside there

53
00:03:07,600 --> 00:03:12,666
以及主要有一个压缩png的选项
as well as primarily the option of having a compressed png as well

54
00:03:12,666 --> 00:03:16,333
这里有很多解码，我们需要把数据取出来
and there's a bunch of decoding that, we actually need to do get the data out

55
00:03:16,500 --> 00:03:18,300
所以我们要做的是使用一个库来实现那个
so what we're going to do is we're going to use a library for that

56
00:03:18,300 --> 00:03:21,166
特别地，我们将使用stb_image库
and specifically, we're going to use something called stb_image

57
00:03:21,466 --> 00:03:23,866
这是一个非常非常小的文件
which is a very very small one file

58
00:03:24,033 --> 00:03:24,800
那就是我们要做的一切
that's all we're going to do

59
00:03:24,800 --> 00:03:26,633
我们马上就能得到它
we're going to get it from get in a second here

60
00:03:26,900 --> 00:03:28,500
但我们所需要的真就是一个文件
but all we need really is one file

61
00:03:28,500 --> 00:03:30,400
实际上，我们会用它来加载png
and we're going to use that to actually load the png

62
00:03:30,500 --> 00:03:34,000
当我说加载png时，我的意思是我们给它一个文件路径
now when I say load the png what I mean is we give it a file path

63
00:03:34,000 --> 00:03:35,600
所以这就是我电脑里的文件
so this is my file in my computer

64
00:03:35,700 --> 00:03:37,566
它会给我们
and what it's going to do is give us

65
00:03:37,733 --> 00:03:43,000
基本上就是一个指向RGBA像素缓冲区的指针，这就是我们想要的
basically a pointer to a buffer of RGBA pixels, which is what we actually want to

66
00:03:43,300 --> 00:03:44,766
然后进行下一步
then take to the next step

67
00:03:45,066 --> 00:03:49,200
我们会取那个像素数组，然后把它上传到我们的显卡
we're just going to be taking that pixel array, and uploading it to our GPU

68
00:03:49,366 --> 00:03:51,733
我们实现那个的方式当然就是通过OpenGL
and the way that we do that of course is through OpenGL

69
00:03:51,733 --> 00:03:54,133
因为OpenGL是我们的图形规范
because OpenGL is our graphic specification

70
00:03:54,133 --> 00:03:59,350
所以我们使用OpenGL然后把数据作为纹理发送到显卡
so we use OpenGL to then send that data into the GPU as a texture

71
00:03:59,350 --> 00:04:06,066
一旦我们做了那个，当它在绘制时，就可以修改着色器来读取那个纹理
once we've done that, we can modify our shader to actually read that texture, when it's drawing

72
00:04:06,066 --> 00:04:10,733
所以像素着色器，也就是片段着色器会从纹理内存中读取
so the pixel shader the fragment shader is going to read from that texture memory

73
00:04:10,800 --> 00:04:14,866
并实际计算出每个像素应该是什么，构成那个纹理每部分的颜色是什么
and actually work out which pixel should be, which color as per that texture

74
00:04:15,000 --> 00:04:18,933
那就是当我们绘制出矩形的时候会发生的事情
and that's what will happen when we actually draw that rectangle of ours

75
00:04:19,066 --> 00:04:21,166
那么我们来回顾一下
so just to recap over all of that

76
00:04:21,800 --> 00:04:25,733
中间还有一些详细的步骤可以解决这个问题
and there are some detailed steps kind of in between that will address definitely

77
00:04:25,833 --> 00:04:27,733
但那就是它的要点，对吧
but that is the gist of it, right

78
00:04:27,833 --> 00:04:30,633
我们载入图像，在OpenGL中创建纹理
we load our image, we create a texture in OpenGL

79
00:04:30,933 --> 00:04:33,525
然后，当渲染的时候，我们必须绑定纹理
we then have to bind that texture, when it's time to render

80
00:04:33,525 --> 00:04:37,066
我们修改我们的着色器来绑定到那个纹理插槽
we modify our shader to all sort of bind to that texture slot

81
00:04:37,066 --> 00:04:38,400
那就是我们要绑定我们纹理的地方
that we've bound our texture to

82
00:04:38,733 --> 00:04:41,533
我们也在着色器中对这个纹理采样
and we also sample that texture in our shader

83
00:04:41,600 --> 00:04:44,066
当我们绘制矩形时，我们应该看到纹理
and when we draw our rectangle, we should see the texture

84
00:04:44,066 --> 00:04:46,100
那么就让我们直接写一些代码吧
so let's just go ahead and write some code

85
00:04:46,100 --> 00:04:47,700
所以我们要做的第一件事就是
so the first thing that we really need to do

86
00:04:47,700 --> 00:04:52,333
加载这个图像到CPU内存中，这样我们就能把它发送到OpenGL
is load this image somehow into our CPU memory, so that we can send it to OpenGL

87
00:04:52,333 --> 00:04:56,950
那么在这儿，打开的是一个github库，我会把链接放在下面的描述中
so over here, what I've got, is a github repository, which I'll link in the description below

88
00:04:57,204 --> 00:05:01,900
这个里面就是stb库，这个就是c/c++的单一文件公共域库
and inside this kind of stb library, which single file public domain libraries for c/c++

89
00:05:01,900 --> 00:05:03,533
所以你可以完全免费使用它
so you can use this completely free

90
00:05:03,900 --> 00:05:08,500
这儿有个东西叫stb_image，我们只需要这个文件
there's something called stb_image, and really there's just this one file that's all we need

91
00:05:08,866 --> 00:05:12,166
打开文件，点击这儿这个Raw
I'm going to open that file, I'm going to click on Raw here

92
00:05:12,166 --> 00:05:14,366
只是为了方便自己
and just to make this really simple for myself

93
00:05:14,366 --> 00:05:18,666
按control a+c，那么我复制了这个文件中的所有文本
I'm just going to control a control c, so I'm copying all the text inside this file here

94
00:05:19,000 --> 00:05:22,933
回到我的项目中，我要在这里新建一个源文件
and back inside of my project, I'm going to make a new source file here

95
00:05:23,266 --> 00:05:25,433
现在我要创建一个名为vendor的文件夹
now I'm going to make a folder called vendor

96
00:05:26,833 --> 00:05:31,400
在里面，创建一个叫stb_image的文件夹
and inside there, a folder called stb_image

97
00:05:32,000 --> 00:05:34,900
这样我就能知道这不是我的代码
just so that I can kind of know that this isn't really my code

98
00:05:35,933 --> 00:05:39,333
然后创建一个头文件stb_image.h
I'll make a header file called stb_image.h

99
00:05:40,433 --> 00:05:43,700
并且删除这个文件中的一切，只粘贴我刚才复制的
and delete everything from this file, and just paste in what I've copied

100
00:05:43,700 --> 00:05:46,433
你们可以看到，这儿大概有7.5k行代码
and you can see, it's about seven and a half thousand lines of code here

101
00:05:46,566 --> 00:05:50,633
好了，酷，现在如果你们实际去阅读这个文件，那是你们应该做的
okay, cool, now if you actually read this file, this is what you should do

102
00:05:50,633 --> 00:05:53,933
当你们从互联网和新库等等上获得新的文件
when you when you get new files from the internet and new libraries and all that

103
00:05:54,200 --> 00:05:56,766
它基本上是说实现这个很简单，对吧
it basically says pretty simply do this, right

104
00:05:56,766 --> 00:06:00,700
在包含这个文件之前定义STB_IMAGE_IMPLEMENTATION
define STB_IMAGE_IMPLEMENTATION before you include this file in one

105
00:06:01,166 --> 00:06:04,033
在c++文件中创建实现，好了
see your c++ file to create the implementation, okay

106
00:06:04,166 --> 00:06:05,400
那么它应该看起来像这样
so it should look like this

107
00:06:05,766 --> 00:06:07,800
它甚至好像给了你们一个例子，对吧
it even like gives you an example, right

108
00:06:07,966 --> 00:06:11,166
所以为了编译这段代码一次我们需要做的，而且只编译一次
so what we need to do to actually compile this code once, and once only

109
00:06:11,366 --> 00:06:14,333
基本上就是添加一个新项，添加一个cpp文件
is we basically add a new item, I'm going to add a cpp file

110
00:06:14,333 --> 00:06:21,925
我就叫这个stb_image，就是stb_image.cpp，然后包含stb_image.h
I'm going to call this stb_image, call stb_image.cpp, I'm going to include stb_image.h

111
00:06:22,033 --> 00:06:27,533
但在此之前，正如这里所说，将定义STB_IMAGE_IMPLEMENTATION
but before I do that, as it says over here, I'm going to define STB_IMAGE_IMPLEMENTATION

112
00:06:28,200 --> 00:06:29,466
那就是我要做的
and that's all I need to do

113
00:06:29,466 --> 00:06:33,300
如果我按control+f7，它会编译所有的stb_image代码
and if I hit control f7, it's going to compile all of that stb_image code

114
00:06:33,300 --> 00:06:35,400
就这样，完成了，就那么简单
there we go, done, simple as that

115
00:06:35,466 --> 00:06:38,400
现在，下一步是为我们自己创建Texture类
now the next step is going to be the created Texture class for ourselves

116
00:06:38,400 --> 00:06:40,266
我们可以组织所有的代码
that we can kind of organize over all of our code

117
00:06:40,266 --> 00:06:43,033
那么我要添加一个新项，它将是一个头文件
so I'm going to add a new item, it's going to be a header file

118
00:06:43,900 --> 00:06:45,366
就叫它Texture.h
we're going to call it Texture.h

119
00:06:45,933 --> 00:06:48,533
我还要添加一个新项
I'm also going to add a new item

120
00:06:48,733 --> 00:06:51,733
这将是我们的cpp文件，当然就是Texture.cpp
which is going to be our cpp file, of course Texture.cpp

121
00:06:52,800 --> 00:06:55,233
在这儿包含Texture.h
going to include Texture.h in here

122
00:06:56,300 --> 00:06:58,933
这就是我们的Texture类
and this is just going to be our Texture class

123
00:06:59,400 --> 00:07:00,800
我会在这儿包含Renderer
I'll include the Renderer in here

124
00:07:00,800 --> 00:07:03,200
这样我们就能访问OpenGL和我们需要的一切
so that we have access to OpenGL and everything we need

125
00:07:04,433 --> 00:07:07,033
我们可以开始创建我们的Texture类
and we can start with creating our Texture class

126
00:07:07,033 --> 00:07:11,233
那么在这里，我把它设为m_RendererID，就像我们对所有东西做的那样
so inside here, I'll make it m_RendererID, as we have for pretty much everything

127
00:07:12,633 --> 00:07:16,966
我还会跟踪纹理的实际文件路径(m_FilePath)
I'm also going to keep track of the actual file path of our texture

128
00:07:17,300 --> 00:07:20,833
我要定义一个unsigned char，它将是我们的m_LocalBuffer
I'm going to define an unsigned char, which is going to be our m_LocalBuffer

129
00:07:20,833 --> 00:07:23,000
这将是纹理的本地存储
so this is just going to be local storage for the texture

130
00:07:23,166 --> 00:07:25,500
最后，我们还需要宽度(m_Width)和高度(m_Height)
and then finally, we also need the width and the height

131
00:07:25,500 --> 00:07:29,733
以及实际纹理的每像素位(m_BPP)
and the bits per pixel of the actual texture

132
00:07:29,766 --> 00:07:33,900
好了，酷，然后在public里面，我要创建一个构造方法
all right, cool, and then inside here public, I'm going to make a constructor

133
00:07:33,900 --> 00:07:36,266
它只接收一个路径(path)，那就是我们所需要的
which is just going to take in a path, that's all we need

134
00:07:36,600 --> 00:07:39,992
我也会创建一个析构方法，这样我们就能在需要的时候销毁一切
I'll make a destruct as well, so that we can destroy everything when we need to

135
00:07:40,666 --> 00:07:44,300
还有一个叫Bind的方法，以及Unbind，现在差不多了
a function called Bind and Unbind, that's pretty much it, now

136
00:07:44,533 --> 00:07:47,850
我会做一些辅助方法，比如GetWidth
I will make some like helpers here, like GetWidth for example

137
00:07:47,850 --> 00:07:53,100
这会返回宽度和高度，以防万一，我们以后想要得到那个
which will just return width and height, just in case, we want to get that later

138
00:07:53,400 --> 00:07:55,300
但总的来说，我喜欢添加这些东西
but in general, I like to kind of add these things

139
00:07:55,300 --> 00:07:58,075
因为我真的需要它们，而不是找我所有的类
as I actually need them, instead of pretty finding all my class

140
00:07:58,075 --> 00:08:00,500
否则，光是思考就会花上一段时间
because otherwise, it takes quite a while to just think about

141
00:08:00,533 --> 00:08:02,300
我想知道我想要这个类有什么
well I wonder what I want this class to have

142
00:08:03,000 --> 00:08:04,400
当你们以后可以扩展它的时候
when you can just extend it later

143
00:08:04,733 --> 00:08:07,300
现在就是Bind，我要做一点改变
now Bind, I'm going to change a little bit

144
00:08:07,333 --> 00:08:12,466
我要在这里放一个unsigned int slot = 0，那么这是一个可选参数
I'm actually going to put an unsigned int slot equals 0 over here, so what this is is an optional parameter

145
00:08:12,466 --> 00:08:14,532
如果你们不指定它，它将是0
if you don't specify that, it will be 0

146
00:08:14,532 --> 00:08:18,400
它基本上允许你们指定这个slot, 那就是你们想要绑定纹理的插槽
which basically allows you to specify the slot, that you want to bind a texture to

147
00:08:18,533 --> 00:08:21,766
现在在OpenGL中，我们有各种各样的插槽可以绑定纹理
now in OpenGL, we have various slots that we can bind textures to

148
00:08:21,766 --> 00:08:27,333
那个存在的原因是，因为我们有能力一次性绑定多个纹理
and the reason that exists is, because we have the ability to actually bind more than one texture at once

149
00:08:27,400 --> 00:08:33,000
那么在Windows上，典型的现代显卡，你们会有32个纹理插槽
so on Windows, typically in with modern GPUs, you have about 32 textures slots

150
00:08:33,033 --> 00:08:35,400
而在移动设备上，比如android或iPhone
whereas on mobile, like on an android or an iphone

151
00:08:35,400 --> 00:08:40,900
你们可能有比如八个插槽，这取决于你们的实际显卡
you might have like eight for example again, this really depends on the actual GPU that you have

152
00:08:41,300 --> 00:08:44,300
以及它们的OpenGL实现，你们总是可以询问OpenGL
and their implementation of OpenGL, you can always ask for OpenGL

153
00:08:44,300 --> 00:08:45,866
嘿，我有多少纹理槽
hey, how many textures slots do I have

154
00:08:46,266 --> 00:08:50,566
只会给你们一个大概的数字，在Windows上，现代GPU，大约32个
just to give you a rough ballpark, on Windows, on modern GPU, you have about 32

155
00:08:50,900 --> 00:08:54,433
在移动显卡上，你们可能有8个，那大概就是它的情况
on mobile GPU, you may have 8, that's roughly what it will be

156
00:08:54,433 --> 00:08:57,000
当然，你们可以咨询你们的平台来找到答案
but of course, you can just consult your platform to find out

157
00:08:57,100 --> 00:09:01,200
那么我右键点击Texture, 使用VS助手，创建所有的方法实现
so I'm going to right click on Texture, and using visual assistant, just create all of the method implementations

158
00:09:01,200 --> 00:09:05,100
这将为我的构造和所有方法创建这些实现
that's just going to create these implementations for my construction and all of my methods

159
00:09:05,466 --> 00:09:09,366
我将在构造方法中，将filePath指定为path
I'm going to in my constructor, assign filePath to be path

160
00:09:09,700 --> 00:09:13,466
我想设置初始化这些东西
I want to set basically initialize most of these things

161
00:09:13,466 --> 00:09:21,033
m_LocalBuffer将设置为nullptr，宽度(m_Width)高度(m_Height)为0
m_LocalBuffer will set to nullptr, width height to 0

162
00:09:23,600 --> 00:09:25,648
你们真的应该试着用同样的方法来做这个
and you should really try and do this in the same thing

163
00:09:25,648 --> 00:09:30,100
我在m_BPP中的定义，m_BPP(0)
what I'm defined in m_BPP, m_BPP to 0

164
00:09:31,000 --> 00:09:33,675
看起来很不错，所以我唯一做的就是
and that looks pretty good, so the only thing I really did was

165
00:09:33,675 --> 00:09:35,033
实际上我是按顺序做的
actually I did do it in order

166
00:09:35,033 --> 00:09:37,785
把它(m_RendererID)写成第一个0
and write it was the first thing 0

167
00:09:37,785 --> 00:09:41,833
好了，酷，那么继续，我们得到了一些，我在初始化所有的变量
alright cool so there we go I've got some, I'm initializing all of my variables

168
00:09:41,833 --> 00:09:43,900
然后我要做的就是开始加载纹理
and then what I'm going to do here is just start loading the texture

169
00:09:43,900 --> 00:09:47,266
那么我会使用GLCall(glGenTextures())
so I'm going to use GLCall glGenTextures

170
00:09:47,266 --> 00:09:50,366
第一个参数是1，生成一个纹理，并且赋值到m_RendererID
1, generate one texture, and assign it to RendererID

171
00:09:50,466 --> 00:09:51,966
然后我要直接绑定它
I'm then going to go ahead and bind it

172
00:09:51,966 --> 00:09:54,533
那么我们可以通过调用glBindTexture来绑定它
so we bind it by just calling glBindTexture

173
00:09:54,966 --> 00:10:00,933
现在我们指定，就像对顶点缓冲区所做的那样，当实际绑定它的时候
now we specify kind of like what we do with our vertex buffer, when where we actually bind it

174
00:10:00,933 --> 00:10:04,733
我们指定它是哪种类型的缓冲区，或者在哪个插槽运行它
we specify kind of which what kind of buffer it is, or what slot with running it to

175
00:10:04,933 --> 00:10:07,775
所以在这个例子中，这将是一个GL_TEXTURE_2D
so in this case, this is going to be a GL_TEXTURE_2D

176
00:10:07,775 --> 00:10:09,766
因为它只是一个二维的纹理
because it's just a two dimensional texture

177
00:10:09,866 --> 00:10:13,133
我们以后可能会讨论不同的纹理类型，当我们接触它们的时候
we might talk about the different texture types in the future, when we get to them

178
00:10:13,600 --> 00:10:18,033
RendererID就是我们绑定的纹理，现在让我们直接来加载图像
RendererID is the texture that we're binding, now let's go ahead and actually load our image

179
00:10:18,333 --> 00:10:21,833
那么要做到这一点，我们需要包含stb_image，所以我要输入include
so to do that, we need to include stb_image, so I'm just going to type in include

180
00:10:22,200 --> 00:10:26,066
提示一下，当然是在vendor/stb_image中，那就是stb_image
as a tip now, of course is gonna be in vendor/stb_image, that's stb_image

181
00:10:26,066 --> 00:10:28,066
如果我实际正确地设置了这个项目
if I was actually properly setting up this project

182
00:10:28,066 --> 00:10:31,925
我可能实际上已经在编译器的包含部分中包含了vendor文件夹
I might have actually included the vendor folder in the include parts for my compiler

183
00:10:31,925 --> 00:10:34,366
这样我就可以不用写vendor了，不过这也没关系
so that I wouldn't have to kind of do vendor, but this is fine

184
00:10:35,366 --> 00:10:37,525
实际上，在我们做这些之前，先让我们实际加载图像
now actually, before we do all of this, let's actually load the image

185
00:10:37,525 --> 00:10:42,450
现在我要做的第一件事是输入stbi_set_flip_vertically_on_load
now the first thing I want to do is type in stbi_set_flip_vertically_on_load 

186
00:10:42,450 --> 00:10:45,766
现在我们需要这样做的原因，然后我要把这个设为1
now the reason we need to do this, and then I'm going to just set this to 1

187
00:10:46,200 --> 00:10:49,100
那么这实际上是垂直翻转我们的纹理
so what this does is actually flips our texture vertically

188
00:10:49,100 --> 00:10:52,100
所以它是颠倒的，我们这么做的原因是
so it makes it upside down, the reason we need to do this is 

189
00:10:52,100 --> 00:10:56,766
因为OpenGL希望我们的纹理像素从左下角开始
because OpenGL actually expects our texture pixels to kind of start at the bottom left

190
00:10:56,766 --> 00:11:01,300
不是左上角，对吧，OpenGL的左下角坐标就是(0, 0)
not the top left, right, so the bottom left in OpenGL is 0 0

191
00:11:01,625 --> 00:11:04,700
现在通常当我们加载像png这样的图像
now typically when we load images like png

192
00:11:04,700 --> 00:11:09,866
比如把它存储在扫描行中，从图像的顶部到底部
for example stores it in scan lines kind of, from the top of the image to the bottom of the image

193
00:11:09,866 --> 00:11:11,700
所以实际上我们需要在加载时翻转它
so we need to actually flip it on load

194
00:11:11,766 --> 00:11:14,600
这真的取决于你们的纹理格式，所以一定要看看这个
this really does depend on your texture format, so definitely take a look at this

195
00:11:14,733 --> 00:11:18,166
对于我们的用例，对于这里的png，我们确实需要翻转它
for our use case, for our png here, we do need to flip it

196
00:11:18,166 --> 00:11:20,950
所以如果你们看到你们的纹理是上下颠倒的
so just if you see that your texture is upside down or whatever 

197
00:11:20,950 --> 00:11:23,625
你们可以设置这个标志，以确保你们得到正确的方式
you can play with this flag to make sure that you get it the right way up 

198
00:11:23,625 --> 00:11:26,200
好了，下一件事我们要做的是赋值m_LocalBuffer
okay, the next thing we're going to do is assign m_LocalBuffer

199
00:11:26,200 --> 00:11:30,633
就是我们的纹理的本地存储，是stbi_load(赋给m_LocalBuffer)
which is our local storage for our texture, to be stbi_load

200
00:11:31,000 --> 00:11:34,500
现在我们需要指定文件名，也就是path.c_str()
now we're going to have to specify a file name, which is just going to be path.c_str()

201
00:11:34,500 --> 00:11:36,966
然后我们有指向x和y通道的指针
then we have pointers to x and y channels

202
00:11:36,966 --> 00:11:41,033
就是存储了我们实际的宽度和高度，诸如此类的
which is just going to store all of our actual width and height, and all that

203
00:11:41,033 --> 00:11:43,950
那么我们已经为这个创建了变量，我们只是传递内存地址
so we've already created variables for this, we're just passing the memory address 

204
00:11:43,950 --> 00:11:46,733
这个stbi_load函数所做的就是写入
and what this stbi_load function will do is actually write

205
00:11:46,733 --> 00:11:50,369
宽度，高度，每像素位等等
the width and height and the bits per pixel or whatever

206
00:11:50,369 --> 00:11:54,800
（为我们写入）到那些实际的变量，所以我们传入这些变量的指针
into those actual variables for us, so we're passing pointers to these variables

207
00:11:54,800 --> 00:11:57,100
这样这个函数就能写入到它们中去
so that this function can actually write to them

208
00:11:57,100 --> 00:12:00,733
预期通道就是我们有多少个预期（颜色）通道
and desired channels is kind of how many desired channels we have

209
00:12:00,800 --> 00:12:04,933
那么想要使用RGBA，所以那是4，所以只需要像那样输入4，好了
so we want RGBA, so that's 4, so I just want to type in 4 like that, okay

210
00:12:04,933 --> 00:12:09,366
那么一旦我们有了这个，我们实际上就有了在这个LocalBuffer中所有的纹理数据
so once we've got this, we've actually got all of our texture data inside this LocalBuffer here

211
00:12:09,666 --> 00:12:12,700
我现在需要做的是设置一些实际的设置
what I need to do now is set up some actual settings

212
00:12:12,700 --> 00:12:15,366
我猜就是对于我们刚刚生成的纹理
I guess for our texture that we've just generated here

213
00:12:15,366 --> 00:12:19,100
那么我们设置任何纹理参数的方式，就是调用glTextParameter
so the way that we set any texture parameters, we call glTextParameter

214
00:12:19,300 --> 00:12:22,366
然后是我们要设置的数据类型，那么这个就是i，表示整数
and then the type of data we're trying to set, so this is going to be an i, for integer

215
00:12:22,433 --> 00:12:27,066
第一个参数是目标GL_TEXTURE_2D，下一个参数是实际的参数名
so the first parameter here is the target which is TEXTURE_2D, the next slot is the actual parameter name

216
00:12:27,066 --> 00:12:30,900
在这个例子中是GL_TEXTURE_MIN_FILTER
which in this case is going to be GL_TEXTURE_MIN_FILTER

217
00:12:30,900 --> 00:12:36,500
那么这是缩小过滤器，这就是我们的纹理将如何被模拟下来
so this is the minification filter, this is how our texture will actually be resembled down

218
00:12:36,966 --> 00:12:40,333
如果它需要被渲染的比它的像素要小
if it needs to be rendered smaller than it is kind of per pixel

219
00:12:40,533 --> 00:12:46,366
我们会有一期关于深入了解所有这些纹理参数的视频
we're going to have an in depth episode on all of these kind of texture parameters 

220
00:12:47,100 --> 00:12:51,966
因为就像处理MIT地图，放大和放大过滤
because like dealing with MIT maps and kind of magnification and magnification filtering 

221
00:12:52,133 --> 00:12:54,033
就像你们知道的边缘缩小所有这些
and like you know edge clamping all of that

222
00:12:54,633 --> 00:12:58,200
这是一个很大的话题，我就不想塞在这里了
is it kind of a big topic, then I don't want to just squeeze it in here

223
00:12:58,400 --> 00:13:00,233
所以我们以后会更详细地讨论这个东西
so we will talk about the stuff in more detail and the future

224
00:13:00,233 --> 00:13:04,133
别担心，但现在，你们可以使用这些设置，我会边做边解释的
don't worry, but for now, you can just kind of use these settings, and I'll explain them as I go

225
00:13:04,133 --> 00:13:08,400
那么我们将这个设置为GL_LINEAR，也就是线性重新取样
so this we're gonna set to GL_LINEAR, which is just going to linearly resample everything

226
00:13:08,400 --> 00:13:10,200
所以看起来还是不错的
so it will kind of still look okay

227
00:13:10,200 --> 00:13:13,333
它不会在最近的像素上断开，这是GL_LINEAR，我们会做的
it's not gonna snap at the nearest pixel, which is what GL_LINEAR, us would do

228
00:13:13,675 --> 00:13:15,766
我们还必须指定放大过滤器
we also have to specify the magnification filter

229
00:13:15,766 --> 00:13:19,325
也就是如果我们在一个区域上渲染纹理
which is if we actually kind of render our texture on an area

230
00:13:19,325 --> 00:13:23,666
那比实际的纹理大小更大，所以它需要放大
that is larger in pixels than the actual texture size, so it needs to scale it up

231
00:13:23,700 --> 00:13:26,075
我们还需要指定嵌入模式
we also need to specify the clamp mode 

232
00:13:26,075 --> 00:13:31,100
那么就是glTextParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP)
so glTextParameteri GL_TEXTURE_2D GL_TEXTURE_WRAP

233
00:13:31,100 --> 00:13:34,133
现在我称它们为嵌入模式，但它们实际上是环绕模式
now I call them clamp modes, but they're just, they're really wrap modes

234
00:13:34,166 --> 00:13:37,566
那么WRAP_S就是水平环绕，所以我们想要它嵌入
so WRAP_S is the horizontal wrap, so we want it to clamp

235
00:13:37,566 --> 00:13:43,100
这意味着我们基本上不希望它扩大区域，另一个选项是平铺
which means that we want it to basically not extend the area, the other option is tiling

236
00:13:43,566 --> 00:13:47,466
所以我们不想在这里平铺纹理，那么S&T是有点像x和y
so we don't want to tile our textures here, so S and T is kind of like x and y

237
00:13:47,466 --> 00:13:52,500
但是对于纹理，你们需要指定这四个参数，如果你们不指定这四个参数
but for textures, and these four parameters you need to specify, if you don't specify these four parameters

238
00:13:53,033 --> 00:13:56,433
只会得到像一个黑色的纹理，这有点烦人
you're just gonna get it like a black texture, which is a little bit annoying

239
00:13:56,433 --> 00:14:00,366
因为你们希望它们是无意识的默认值，默认情况下，但它们不是
because you kind of expect them to maybe be insensible defaults, by default, but they're not

240
00:14:00,525 --> 00:14:04,666
所以一定要指定这四个参数，否则你们可能会得到一个黑色纹理
so make sure you specify these four, otherwise you may probably will get a black texture

241
00:14:04,666 --> 00:14:07,250
但当然，这取决于你们的OpenGL实现
but of course that does depend on your OpenGL implementation

242
00:14:07,250 --> 00:14:12,333
好了，酷，下一步是给OpenGL我们在这里读取到的数据
okay, cool, next step is going to be to actually give OpenGL the data that we've read in here

243
00:14:12,333 --> 00:14:14,933
那么我们已经在m_LocalBuffer中有了一些像素数据
so we've got a bunch of pixel data inside m_LocalBuffer

244
00:14:15,100 --> 00:14:17,100
我们现在把它发送到OpenGL
let's actually send it now to OpenGL

245
00:14:17,100 --> 00:14:20,966
那么实现那个的方式是通过一个叫做glTextImage2d的OpenGL函数
so the way that we do that is via an OpenGL called called glTextImage2d

246
00:14:20,966 --> 00:14:24,500
所以目标是GL_TEXTURE_2D
so the target is going to be GL_TEXTURE_2D

247
00:14:25,000 --> 00:14:27,233
这个level参数，在这一点上
the level, this is at this point

248
00:14:27,233 --> 00:14:29,900
你可能需要阅读文档来了解所有这些参数
you probably want to read the documentation to figure out what all of these are

249
00:14:29,933 --> 00:14:34,100
其中很多参数与我们完全无关，我跳过那些
a lot of these are completely irrelevant to us, I'm going to kind of skip past that

250
00:14:34,100 --> 00:14:37,300
我们将在以后看看高级纹理，那么就会讲到那些 
we will look at advanced textures in the future, so we'll cover them then

251
00:14:37,300 --> 00:14:40,300
但现在我们想让level为0，因为这不是一个复合纹理
but for now we want the level to be 0, because this is not a multi level texture

252
00:14:40,466 --> 00:14:42,900
内部格式将是GL_RGBA
internal format is going to be GL_RGBA

253
00:14:42,900 --> 00:14:45,333
这是OpenGL看到我们实际格式的方式
that's how OpenGL is going to see our actual format

254
00:14:45,333 --> 00:14:48,100
RGBA不是我们提供的数据格式
RGBA not the format of the data we're supplying

255
00:14:48,100 --> 00:14:50,433
而是我们希望OpenGL如何处理我们的数据
but how we want OpenGL to deal with our data

256
00:14:50,900 --> 00:14:54,133
内部格式与格式本身就是一个巨大的主题
internal format versus format is a huge topic in itself

257
00:14:54,133 --> 00:14:57,666
甚至这也需要单独占用一期，因为人们总是混淆这一点
which will probably even dedicate an episode too, because people confuse that all the time

258
00:14:57,966 --> 00:15:02,645
但是内部格式，也就是第一种格式，那是OpenGL存储纹理数据的方式
but internal format, which is the first format, that's how OpenGL will store your texture data

259
00:15:02,645 --> 00:15:08,025
而格式是纹理数据，是你们提供给OpenGL的数据格式
whereas format is the texture data, is the format of the data you're providing OpenGL with

260
00:15:08,025 --> 00:15:10,400
那么换句话说，也就是m_LocalBuffer的格式
so in other words, the format of m_LocalBuffer

261
00:15:10,400 --> 00:15:16,433
在最近的OpenGL实现中，你们实际上应该叫它GL_RGBA8，好了
now in recent implementations of OpenGL, you should actually call this GL_RGBA8, okay

262
00:15:16,533 --> 00:15:20,033
那么应该指定每个通道的实际比特数
so you should be specifying the actual bits per channel

263
00:15:20,066 --> 00:15:21,933
就是你希望OpenGL如何存储你的纹理
which is how you want to OpenGL to store your texture

264
00:15:21,933 --> 00:15:25,566
所以GL_RGBA是一种被弃用的，但它仍将在大多数实现上工作
so GL_RGBA is kind of deprecated, it will still work on most implementations

265
00:15:25,566 --> 00:15:28,966
除了你们实现的，但严格来说，现代OpenGL完成这个正确的方法是
but you do, technically, the correct modern OpenGL way to do this is

266
00:15:28,966 --> 00:15:32,950
实际上就是在这里指定一个数字，也就是每个通道有多少比特
actually to specify a number here, which says how many bits you have per channel

267
00:15:33,433 --> 00:15:35,366
好了，那么width就是m_Width
allright, so width is going to be m_Width

268
00:15:35,366 --> 00:15:37,933
这是我们从stbi_load函数中读取到的
which is what we read in from our stbi_load function

269
00:15:38,000 --> 00:15:40,400
然后我们传递一个m_Height作为我们纹理的高度
then we pass an m_Height for the height of our texture

270
00:15:40,500 --> 00:15:43,633
至于边框，而我们绝对不需要边框，所以就是零像素边框
border, we definitely don't want a border, so zero pixel border

271
00:15:43,633 --> 00:15:45,766
那么格式就是第二种格式
so format is that's like the second format

272
00:15:45,800 --> 00:15:47,300
就是我们提供的数据格式
that's the format of the data we're supplying

273
00:15:47,300 --> 00:15:49,633
就是GL_RGBA，我们这里不用数字
GL_RGBA, what it is we don't use numbers here

274
00:15:50,075 --> 00:15:53,866
类型是数据的类型，也就是GL_UNSIGNED_BYTE，对吧
the type is the type of data, so unsigned byte, right

275
00:15:54,033 --> 00:15:57,700
那么我们有GL_RGBA，每个通道都是一个无符号字节
so we have GL_RGBA, and each one of these channels is an unsigned byte

276
00:15:57,733 --> 00:16:00,833
最后，我们指定了像素，现在你们可以做这个了
and then finally, we have appointed to pixels, now you can make this

277
00:16:00,833 --> 00:16:03,866
你们可以在这里传递一个空指针，0或类似的东西
you can actually pass in a null pointer here, 0 or something like that

278
00:16:03,933 --> 00:16:08,233
如果你们在这个阶段还没有准备好把你们的数据给OpenGL
if you're not ready at this stage to actually give OpenGL your data

279
00:16:08,666 --> 00:16:11,400
那意味着你们只是在显存上分配空间
what that means is that you're just allocating space on the GPU

280
00:16:11,400 --> 00:16:12,800
因为它知道那个需要多少空间
because it knows how much space it needs

281
00:16:12,800 --> 00:16:15,500
但是你们并没有给它提供数据，现在我们已经有了数据
but you're not actually providing it with data, now we already have the data

282
00:16:15,566 --> 00:16:18,766
我们会传入m_LocalBuffer，就像那样
so we're just gonna pass in m_LocalBuffer, just like that

283
00:16:18,800 --> 00:16:20,600
很好，那就是我们所需要的
allright great, and that's really all we need

284
00:16:20,600 --> 00:16:25,675
那么我现在要做的是通过调用glBindTexture(0)来解绑我们的纹理
so what I want to do now is unbind our texture by just calling glBindTexture 0

285
00:16:25,675 --> 00:16:28,366
也可以调用UnbindTextureFunc
could also call the UnbindTextureFunc

286
00:16:28,366 --> 00:16:31,266
我们当然需要指定我们想要解绑的东西，那么就是GL_TEXTURE
well we of course need to specify what we want to unbind, so GL_TEXTURE

287
00:16:31,266 --> 00:16:32,866
因为我今天有这段代码
today since I've got this code here

288
00:16:32,866 --> 00:16:36,225
我要复制这个，然后把它也解绑
I'm just going to copy and face this into unbind as well

289
00:16:36,225 --> 00:16:38,700
因为那就是我们需要的，酷
because that's really all we need, cool

290
00:16:38,700 --> 00:16:42,166
现在我们能做的是，如果m_LocalBuffer，对吧
so now what we can do is if m_LocalBuffer, right

291
00:16:42,166 --> 00:16:44,566
那么如果这个缓冲区确实包含数据
so if this buffer does actually contain data

292
00:16:44,566 --> 00:16:48,700
我们会用stbi_image_free来释放这个LocalBuffer
we're going to use stbi_image_free to actually free this LocalBuffer

293
00:16:48,700 --> 00:16:49,966
现在在更复杂的设置中
now in more complicated setups

294
00:16:49,966 --> 00:16:54,300
你们可能希望在CPU上保留像素数据的副本
you may want to retain a copy of the pixel data on your CPU

295
00:16:54,300 --> 00:16:56,433
因为你们可能想要对它进行抽样或进行其他的操作
because you might want to sample it or do something

296
00:16:57,433 --> 00:16:59,166
不管你们想怎么处理这些数据
whatever you may want to do with that data

297
00:16:59,166 --> 00:17:02,633
所以那是非常完美的，好了
so that's totally perfectly, okay, as well totally perfectly, okay

298
00:17:02,633 --> 00:17:04,466
那也是可以接受的，对吧
that's also kind of acceptable, right

299
00:17:04,466 --> 00:17:07,500
所以你们可能想在构造方法中
so you may want to have something something in the constructor

300
00:17:07,500 --> 00:17:11,100
那就像，你们知道的，保存本地数据之类的
that's like, you know, keep local data around or something like that

301
00:17:11,233 --> 00:17:12,866
我们不关心这个，所以我就直接释放它
we don't really care about that, so I'm just freeing it

302
00:17:12,866 --> 00:17:16,075
这就是为什么我把这个设为成员变量m_LocalBuffer
but that's why I kind of made this a member variable m_LocalBuffer

303
00:17:16,075 --> 00:17:18,500
以防你们想要存储它，就是那样
in case you kind of want to store it, and that's it

304
00:17:18,500 --> 00:17:21,866
最后，在析构方法中，我们可以删除那个数据
now finally over here inside our destructor, we could delete the data

305
00:17:21,866 --> 00:17:24,500
现在我们已经释放了构造方法中的数据
now we've already freed the data in the constant in the constructor

306
00:17:24,500 --> 00:17:25,866
所以我们不需要在这里处理那个
so we don't have to deal with that here

307
00:17:26,166 --> 00:17:31,300
但我们确实需要glDeleteTexture从显卡中删除我们的实际纹理
but we do need to actually glDeleteTexture to delete our actual texture from the GPU

308
00:17:31,733 --> 00:17:34,166
当此对象实例被销毁时
when this object guests destroy

309
00:17:34,166 --> 00:17:37,300
所以我们只要glDeleteTextures，并传入那个RendererID
so we'll just glDeleteTextures and pass in that RendererID

310
00:17:37,625 --> 00:17:39,600
现在Bind是一个有趣的函数
now Bind is an interesting function

311
00:17:39,600 --> 00:17:42,933
因为我们已经知道如何绑定纹理，它真的只是这样，对吧
because we already know how to bind textures, it's really just this, right

312
00:17:43,600 --> 00:17:48,300
但这里我们能做的实际上就是指定一个纹理槽
but what we can do here is actually specify a texture slot

313
00:17:48,300 --> 00:17:51,833
我们通过输入GLCall(glActiveTexture)来实现那个
and we do that by typing in GLCall glActiveTexture

314
00:17:52,033 --> 00:17:55,866
现在ActiveTexture取一个整数，这是一个真正的GLenum
now ActiveTexture takes in an integer, which is this really a GLenum

315
00:17:55,925 --> 00:17:59,933
将是我们当前激活的那个纹理插槽
which is going to be which texture slot we're currently activating

316
00:18:00,033 --> 00:18:03,300
所以再说一次，这有点像OpenGL上的整个状态机选择
so again, this is kind of like the whole state machine selecting thing on OpenGL

317
00:18:03,300 --> 00:18:08,801
我们会说，嘿，我要创建glActiveTexture(16)
we basically say, hey, I'm going to make glActiveTexture slot 16

318
00:18:08,801 --> 00:18:12,933
那意味着我绑定的下一个纹理将绑定到16号插槽上
that means that the next texture that I bind will be bound to slot 16

319
00:18:12,966 --> 00:18:15,466
直到我用一个不同的插槽再次调用glActiveTexture
until I call glActiveTexture again with a different slot

320
00:18:15,800 --> 00:18:19,200
所以在这种情况下，我们指定插槽的方法是用减号，对吧
so in this case, the way that we specify slots is we use minus, right

321
00:18:19,400 --> 00:18:23,200
那么GL_TEXTURE_ZERO是第一个插槽
so GL_TEXTURE_ZERO like that is the very first slot

322
00:18:23,400 --> 00:18:28,233
现在我们有纹理1，纹理2等等，如果你仔细观察它们等于什么
now we have texture 1, texture 2, whatever, if you actually look at what these are equal to

323
00:18:28,466 --> 00:18:33,100
它们当然只是整数，一直到31，对吧
they are of course just integers, and they go all the way up to 31, right

324
00:18:33,100 --> 00:18:34,566
那么你们有32个纹理插槽
so you have 32 texture slots

325
00:18:34,566 --> 00:18:37,300
这并不意味着你们的平台支持那个
now this does not mean that your platform supports that

326
00:18:37,300 --> 00:18:42,300
许多纹理只有32恰好是OpenGL规格允许的最大值
many textures is just 32 happens to be the maximum that OpenGL that the OpenGL specification allows

327
00:18:42,500 --> 00:18:45,133
你们的平台，如我所说的手机可能支持8个
your platform as I said mobile may have like 8

328
00:18:45,366 --> 00:18:47,366
所以你们应该查询并找出你们有多少纹理插槽
so you should query and find out how many you have

329
00:18:47,366 --> 00:18:49,366
如果你们打算使用这么多纹理插槽
if you are going to use this many texture slots

330
00:18:49,366 --> 00:18:54,200
通常情况下，除非你们制作的是一款真正大型的游戏，否则不会这么做
but you probably usually won't be unless you're making a really big game

331
00:18:54,200 --> 00:18:58,200
因为有很多方法可以使用，你知道的，比如重用纹理
because there are ways to kind of you know reuse textures 

332
00:18:58,333 --> 00:19:02,500
我们稍后会讲到，不管怎样，我们有所有的纹理插槽
and we'll talk about that later, but anyway, we have all the textures slot 

333
00:19:02,500 --> 00:19:04,833
在这个例子中，我们指定了一个无符号整型
now in this case, we are specifying an unsigned int

334
00:19:05,066 --> 00:19:07,800
这个大概是0到31
now this will be something like 0 through through the 31

335
00:19:07,800 --> 00:19:12,533
你们能做的就是输入GL_TEXTURE_ZERO加上slot，然后它添加这个slot
so what you can do is just type in GL_TEXTURE_ZERO plus slot, and then it will add the slot

336
00:19:12,533 --> 00:19:14,266
因为如果你们看这些定义
because if you look at these definitions

337
00:19:14,300 --> 00:19:18,866
你们可以看到它们实际上是连续的数字，对吧，它们只是在增加
you can see that they are actually consecutive numbers, right, they do just count up

338
00:19:19,533 --> 00:19:21,400
所以那就是我们的整个Texture类
so that's our entire Texture class

339
00:19:21,400 --> 00:19:26,200
这就是我们需要的全部，就是glActiveTexture，渲染它和所有这些
that is all that we need to actually is glActiveTexture, and for us to render it and all of that

340
00:19:26,200 --> 00:19:28,066
好吧，我知道这一期会很长
alright, so I knew this was gonna be a long episode

341
00:19:28,066 --> 00:19:30,533
让我们继续，让我们实际在屏幕上看到一些东西
but let's keep going, and let's actually see something on the screen

342
00:19:30,533 --> 00:19:32,866
因为那就是今天视频的目标
because that is the goal for today's video

343
00:19:33,100 --> 00:19:35,966
那么回到Application文件，让我们设置所有这些
so back inside Application, let's set all this up

344
00:19:35,966 --> 00:19:40,666
那么我在任何时候都只需要输入Texture texture
so I'm going to at any point really just type in Texture texture

345
00:19:40,833 --> 00:19:46,666
我给它的路径是textures/ChernoLogo.png
I'm gonna give it the path which is read such textures/ChernoLogo.png

346
00:19:46,966 --> 00:19:50,100
我将在顶部包含Texture，因为我还没有这样做
I'm going to include Texture at the top, because I haven't done that yet

347
00:19:51,233 --> 00:19:56,300
然后向下滚动，我要绑定我的纹理，我不会传入参数
and scrolling back down, I'm going to bind my texture, I'm not gonna pass in the parameter

348
00:19:56,300 --> 00:19:58,633
也就是说默认值是0
which means it's gonna be called 0 by default

349
00:19:58,833 --> 00:20:00,133
顺便说一句，我还有件事要做
one thing I need to do, by the way

350
00:20:00,133 --> 00:20:04,000
对于我的这个Shader，在我忘记之前，我们需要首先修复
with my Shader before I forget is we need to first of all fix out

351
00:20:04,366 --> 00:20:08,033
我上次犯的一个可怕的错误
this awful error I made last time in which I passed in

352
00:20:08,033 --> 00:20:10,233
我基本上创建了有一个无符号到整型的映射
and well basically I make this map have an unsigned to int

353
00:20:10,233 --> 00:20:13,025
看起来我只是我使用无符号整型有点太多了
and I just I use unsigned int a bit too much, it seems 

354
00:20:13,369 --> 00:20:16,066
因为只有GetUniformLocation函数
because just GetUniformLocation function

355
00:20:17,633 --> 00:20:20,466
我甚至检查一下location是否为-1
I even check to see if the location is -1 here

356
00:20:20,466 --> 00:20:23,333
因为这是完全有效的，这意味着它找不到我们的统一变量
because that's totally valid, that just means that it couldn't find our uniform

357
00:20:23,666 --> 00:20:26,966
但这里我把它赋值给了一个无符号整数，它显然永远不会是-1
but I'm assigning it to an unsigned int here, which is obviously never going to be -1

358
00:20:27,466 --> 00:20:30,100
所有这些都应该是整型，而不是无符号整型
so all of this should be an int, not an unsigned int

359
00:20:30,100 --> 00:20:32,766
当你们处理OpenGL中统一变量的位置时
when you're dealing with uniform locations in OpenGL

360
00:20:33,133 --> 00:20:38,775
类型是32位整数，好了，所以就是整型，这个也应该是整型
the type is a 32 bit integer, okay, so int and this should also be int

361
00:20:38,775 --> 00:20:40,525
如果我们回到头文件
and if we go back to our header file

362
00:20:40,800 --> 00:20:43,266
这应该是int，因为这是我们的统一变量的缓存
this should be int, because that's our uniform cache

363
00:20:43,566 --> 00:20:47,100
而且这个应该是整型的，我想这就是所有的整型了
and also this should be int, and I think that's all the ints

364
00:20:47,133 --> 00:20:50,900
如果我编译这个，希望能运行一丢丢，是的，我们都很好
if I compile this, hope little work, and yep we're all good

365
00:20:51,033 --> 00:20:52,697
好了，那就是我需要澄清的一件事
okay, that's one thing I need to clear up

366
00:20:52,697 --> 00:20:57,466
我们现在需要做的一件事是我们需要告诉我们的着色器
now, one thing that we need to do is we need to actually tell our shader

367
00:20:57,733 --> 00:21:02,300
从哪个纹理插槽取样，我们这样做的方法是通过一个统一变量
which texture slot to sample from, and the way that we do that is via a uniform

368
00:21:02,300 --> 00:21:07,000
现在这并不是一个整数插槽，而是一个采样插槽
now this isn't really an integer slot, it's something called a sampler slot 

369
00:21:07,033 --> 00:21:09,733
这有点模糊，有点奇怪
and this is a bit hazy and a bit weird

370
00:21:10,300 --> 00:21:15,900
基本上我们需要做的是发送一个整数统一变量到我们的着色器
basically what we need to do is send an integer uniform to our shader

371
00:21:16,166 --> 00:21:21,000
那个整数是我们绑定了纹理到我们想要取样的那个插槽
and that integer is the slot that we've bound a texture to that we want to sample from

372
00:21:21,000 --> 00:21:26,033
然后在着色器代码中，我们可以使用那个采样器或者传入的那个整数
and then in the shader code, we can actually use that sampler or that integer that we've passed in

373
00:21:26,266 --> 00:21:30,866
对纹理进行取样，然后做我们想做的，对吧
to actually sample that texture and do what we want with it, okay

374
00:21:30,966 --> 00:21:32,233
所以那就是它的工作原理
so that's how that works

375
00:21:32,333 --> 00:21:36,600
那么为了做到这一点，我们需要在这里写另一个着色器统一变量函数
so to do that, we need to write another shader uniform function here

376
00:21:36,833 --> 00:21:40,066
也就是SetUniform1i，它代表整数
which is going to be called SetUniform1i, which is for integer

377
00:21:40,366 --> 00:21:45,466
然后我们取一个这样的整数值，复制粘贴这个1f函数
and then we take an inter value like that, I'll copy and paste this 1f function

378
00:21:47,400 --> 00:21:51,200
然后用int替换这个，差不多就是这样了，对吧
and replace this with int and that's pretty much it, right

379
00:21:51,200 --> 00:21:55,700
一定要把这里的1f换成1i，好了
just make sure you replace uniform 1f here with 1i, okay

380
00:21:55,833 --> 00:21:58,333
酷，回到Application文件，我们有了这个
cool, back to application, so that we have this

381
00:21:58,333 --> 00:22:00,100
我们实际也可以把它设置好
we can actually set that up as well

382
00:22:00,100 --> 00:22:05,066
那么就是shader.SetUniform1i("u_Texture")
so shader.SetUniform1i, we're going to call this uniform u_Texture

383
00:22:05,233 --> 00:22:10,966
我们会把它设为0，因为我们把纹理绑定到插槽0
and we're going to set it to 0, okay, because we've bound our texture to slot 0

384
00:22:10,966 --> 00:22:13,500
所以0需要匹配你们这儿传入的任何东西
so that 0 needs to match whatever you're passing in here

385
00:22:13,500 --> 00:22:17,366
如果我把纹理2之类的东西传给插槽2
if I had passed in like texture bound 2 or something to slot 2

386
00:22:17,366 --> 00:22:21,700
我们会在这里传入2，好了，让我们撤销它，很好，酷
we would be passing in 2 here, okay, let's undo that, alright cool

387
00:22:21,700 --> 00:22:25,366
好了，很简单的东西，现在还有一件事我们没做过
so there we go, pretty simple stuff, now, one thing we haven't done

388
00:22:25,566 --> 00:22:28,900
实际上就是创建了一个叫做纹理坐标的东西
is actually created something called texture coordinates

389
00:22:29,266 --> 00:22:34,250
那么我们需要使用一个叫做TextureCoordinateSystem的东西
so what we need to do is actually use something called a TextureCoordinateSystem

390
00:22:34,250 --> 00:22:38,733
告诉我们的几何图形，我们渲染的是纹理的哪一部分来采样
to tell our geometry that we're rendering which part of the texture to sample from

391
00:22:39,000 --> 00:22:44,466
所以我们的像素着色器通过渲染并分解我们的矩形，对吧
so our pixel shader goes through and renders and factorizes our rectangle, right

392
00:22:44,466 --> 00:22:46,900
只是遍历矩形并绘制每个像素
just goes through the rectangle and draws every pixel

393
00:22:47,066 --> 00:22:51,866
像素着色器或片段着色器负责确定每个像素的颜色
the pixel shader or the fragment shader is responsible for determining the color of each pixel

394
00:22:51,966 --> 00:22:57,600
所以在某种程度上，我们真正需要做的是，在渲染某个像素的时候
so what we actually need to do is somehow, when it's up to rendering a certain pixel

395
00:22:57,600 --> 00:23:04,200
告诉它对纹理的某个区域进行采样，以检索像素应该是什么颜色
tell it to sample a certain area of our texture to retrieve what color the pixel should be

396
00:23:04,533 --> 00:23:08,100
对吧，如果你们仔细想想，这其实很简单，并不复杂到难以理解
right, if you think about it, it's actually kind of simple, it's not too complicated to understand

397
00:23:08,100 --> 00:23:11,133
希望这会有意义，如果你们不往下扔硬币的话
hopefully this makes sense, if you don't drop a coin below 

398
00:23:11,133 --> 00:23:15,133
我可能会做一个关于原始关系如何运行的视频
and I might make a detailed kind of in depth video on how the raw relation works

399
00:23:15,133 --> 00:23:17,133
以及纹理采样是如何工作的等等
and how texture sampling works and all that stuff

400
00:23:17,466 --> 00:23:20,633
但基本上我想说的是我们需要这么说
but basically what I'm saying is we need to say that

401
00:23:20,700 --> 00:23:26,466
屏幕上矩形的左下角是坐标(0, 0)
hey, the bottom left of our rectangle on our screen is like coordinate 0 0

402
00:23:26,600 --> 00:23:30,766
右边的顶部是纹理的另一端
and the top like right is the other end of the texture

403
00:23:30,766 --> 00:23:33,266
在OpenGL中就是(1, 1)
which in OpenGL terms is going to be 1 1

404
00:23:33,366 --> 00:23:37,933
好了，因为纹理并没有真正地将纹理绑定到特定的大小
okay, because textures don't really literally tie textures to certain sizes

405
00:23:38,133 --> 00:23:40,833
我们不会将纹理坐标绑定到特定的分辨率
we don't tie texture coordinates to a certain resolution

406
00:23:40,866 --> 00:23:43,425
因为纹理可以是64x64
because the texture could be 64 by 64

407
00:23:43,425 --> 00:23:49,833
可以是1024x1024，可以是57x19，可以是任何分辨率的，对吧
it could be 1024 by 1024, it could be like 57 by 19, it could be anything, right

408
00:23:50,066 --> 00:23:55,000
所以我们需要做的就是指定矩形中的每个顶点
so what we need to do is basically specify for each vertex that we have of our rectangle

409
00:23:55,333 --> 00:23:57,266
什么区域的纹理应该是什么
what area of the texture should be

410
00:23:57,300 --> 00:24:02,033
然后片段着色器会在这之间插入，所以如果我们进入一个像素
and then the fragment shader will interpolate between that, so that if we're entering a pixel

411
00:24:02,033 --> 00:24:05,666
这就像是在两个顶点之间，它会选择纹理坐标
that's like halfway between two vertices, it will pick the texture coordinates

412
00:24:05,900 --> 00:24:09,333
它就像是，你们知道的，在两个顶点的中间
it's like, you know, halfway between the two vertices

413
00:24:09,466 --> 00:24:12,533
让我们可以设置那个，为了做到那一点，如果来到这里到我们的位置
let's set that up, so to do that, if we come over here into our positions

414
00:24:12,533 --> 00:24:14,133
我们知道这个1在左下角
we know this 1 is the bottom left

415
00:24:14,500 --> 00:24:18,166
它将是(0, 0)，我添加了另一个vec2
that's going to be 0 by 0, I'm adding another vec2 basically

416
00:24:18,166 --> 00:24:21,933
我给每个顶点添加了两个浮点数，这是我们的纹理坐标
I'm adding two more floats to each vertex here, which are our texture coordinates

417
00:24:21,933 --> 00:24:27,200
这是(1.0, 0.0)，因为这是在右边，对吧
now this is going to be 1.0 0.0, because it's the right side, right

418
00:24:27,566 --> 00:24:33,000
那么0.5f是矩形最右边的边缘位置
so 0.5f is the right most edge of our actual rectangle

419
00:24:33,366 --> 00:24:37,266
我把它设为1，这意味着从纹理的右边取样
and so I'm setting that to be 1, which means sample from the right side of the texture

420
00:24:37,266 --> 00:24:42,833
这是1.0，而右上方也是(0.5, 0.5)
this is going to be 1.0, when 1.0, as well 0.5 0.5 is the top right

421
00:24:42,833 --> 00:24:46,166
那也是我们在没有纹理坐标的情况下匹配的
and that's what we're also matching without texture coordinate

422
00:24:46,533 --> 00:24:49,566
最后，我们有0和1.0
and then finally, we have 0 and 1.0

423
00:24:49,866 --> 00:24:54,766
现在需要把这个添加到VertexBufferLayout，通过我们的接口，很简单
now we need to add this to our VertexBufferLayout again, with our api, it's really easy

424
00:24:54,766 --> 00:24:57,225
我们只需要做这个layout推入两个浮点数
we just do this layout push two more floats 

425
00:24:57,225 --> 00:24:58,966
对吧，就这样，这就是我们需要做的
right, that's it, that's all we need to do

426
00:24:58,966 --> 00:25:03,825
我们还需要扩展这个VertexBuffer来包含这些额外的东西，对吧
we also need to actually expand this VertexBuffer to contain these extra things, right

427
00:25:03,825 --> 00:25:06,900
所以现在不是每个顶点有两个浮点数
so now instead of having two floats per vertex

428
00:25:06,900 --> 00:25:10,066
实际上每个顶点有四个浮点数，所以我们把它增加到四个
we actually have four floats per vertex, so we'll increase this to four

429
00:25:10,200 --> 00:25:13,866
最后我们需要进入Shader，基本上重写整个东西
and finally we need to go into our Shader, and basically rewrite the whole thing

430
00:25:13,966 --> 00:25:19,200
那么在我们的VertexShader中，我们现在在位置1处取一个纹理坐标
so in our VertexShader, we now take in a texture coordinate at location one

431
00:25:19,733 --> 00:25:24,033
也就是一个矢量，或者叫它textCoord之类的
which is a vector or call it, I don't know, a textCoord or something like that

432
00:25:24,100 --> 00:25:26,000
现在我们要面对一些新的东西
and now we're faced with something a little bit new

433
00:25:26,400 --> 00:25:29,900
我们需要把这个纹理坐标放到我们实际的片段着色器中
we need to get this texture coordinate into our actual fragment shader

434
00:25:29,900 --> 00:25:34,200
因为看看这个，就像我之前说的，我们取样纹理的方法是
because check this out, the way that we're going to actually sample our texture is, as I said earlier

435
00:25:34,200 --> 00:25:37,050
通过使用sampler2D，对吧
by using that sampler2D uniform, right

436
00:25:37,050 --> 00:25:41,466
那么就是uniform sampler2D u_Texture，也就是我们在这里设置的统一纹理
so sampler2D u_Texture, which is the uniform that we set over here

437
00:25:41,800 --> 00:25:46,500
我们设它为0，对吧，那么我们需要对它进行采样
we set it to be 0, right, so we need to sample this somehow

438
00:25:46,500 --> 00:25:48,366
并且这就是纹理统一变量
and that's this texture uniform

439
00:25:48,566 --> 00:25:50,933
我们这样做的方法就是，我们实际计算出颜色
and the way that we do that is, we actually work out the color

440
00:25:50,933 --> 00:25:53,900
这个返回的vec4，有点像我们的textColor
this returns of vec4, which is kind of like our textColor

441
00:25:53,933 --> 00:25:57,700
我把这个写出来，textColor = texture()
I'll just write this out for you guys, text color is going to be texture

442
00:25:58,033 --> 00:26:00,366
我们正在采样的纹理是u_Texture
the texture that we're sampling which is u_Texture

443
00:26:00,533 --> 00:26:03,900
然后我们需要指定那些纹理坐标，对吧
and then we need to specify those texture coordinates, right

444
00:26:03,933 --> 00:26:06,500
我们如何指定我们的纹理坐标
so how do we actually specify our texture coordinates

445
00:26:06,500 --> 00:26:08,733
因为它们在顶点着色器中
because they're in the vertex shader

446
00:26:09,066 --> 00:26:12,300
我们在顶点和片段着色器之间发送数据的方式
so the way that we kind of send data between the vertex and the fragment shaders

447
00:26:12,300 --> 00:26:14,633
就是通过叫Varying的东西，在现代OpenGL中
by something called a Varying, now in modern OpenGL

448
00:26:14,633 --> 00:26:18,300
这是一种我们已经习惯了的输入输出系统
this is kind of the in and out system that we're already used to

449
00:26:18,333 --> 00:26:22,633
类似地，我们可以通过输入数据到顶点着色器中通过输入in
similarly to how we can actually input data into the vertex shader by typing it in

450
00:26:22,633 --> 00:26:25,666
同时从片段着色器输出数据通过标记它为out
and also output data from the fragment shader by having it out

451
00:26:25,933 --> 00:26:31,433
也可以将数据从顶点着色器输出到片段着色器中，我们这样做的方式
we can also output data from the vertex shader into the fragment shader, and the way that we do that

452
00:26:31,833 --> 00:26:32,966
所以我们输入out
so we type in out

453
00:26:33,300 --> 00:26:35,666
这将是一个vec2，当然这是我们的文本
now this is going to be a vec2 of course it's our text according it

454
00:26:35,666 --> 00:26:40,600
我将这个命名为v_TextCoord, v听起来像是Varying，就是这个的名字
and I'll call this v_TextCoord, v sounds for Varying which is what this is called

455
00:26:40,666 --> 00:26:45,733
然后我分配v_TextCoord等于我们从顶点缓冲区中获取的TextCoord
and then I'll assign v_TextCoord to be the TextCoord that we take in from our vertex buffer

456
00:26:45,733 --> 00:26:47,500
同样在片段着色器中
and then similarly in the fragment shader

457
00:26:47,500 --> 00:26:53,133
我要输入in vec2 v_TextCoord，就像这样
I'm going to type in vec2 v_TextCoord just like that

458
00:26:53,700 --> 00:26:56,400
我将在这里使用textCoord
and I'm going to use that textCoord over here

459
00:26:56,600 --> 00:27:00,169
这样我们就可以对特定的纹理坐标进行采样
so that we actually sample that specific texture coordinate

460
00:27:00,300 --> 00:27:03,300
因为记住这个片段着色器为每个像素运行
because remember this fragment shader runs for every pixel

461
00:27:03,300 --> 00:27:08,266
所以我们需要知道纹理中的精确位置来查找
so we need to know the precise location in the texture to actually look up

462
00:27:08,266 --> 00:27:12,433
这样我们就可以在实际屏幕中从纹理中绘制出那个像素
so that we can draw that pixel from the texture in our actual scene

463
00:27:12,433 --> 00:27:15,066
这就是采样的意义所在
and that's what this whole sampling thing is about

464
00:27:15,500 --> 00:27:18,966
我相信我们以后会更深入地讨论这个问题，好了，酷
again, I'm sure we'll discuss this in the future and more depth, okay, cool

465
00:27:18,966 --> 00:27:22,300
现在我不把这个赋值给u_Color，我要把这个赋值给textColor
so now instead of assigning this to u_Color, I'm going to assign this to textColor

466
00:27:22,300 --> 00:27:24,400
就是我们实际的纹理查找颜色
which is our actual texture look up color

467
00:27:24,633 --> 00:27:27,833
一切看起来都很好，现在我确实写了很多代码
and everything looks pretty good to me, now I did write a lot of code

468
00:27:27,833 --> 00:27:30,500
我不确定这是否可行，因为我还没运行过这个程序
and I'm not sure if this will work, because I haven't even run this program once

469
00:27:30,500 --> 00:27:34,333
我们按下f5，谁知道呢，也许会很漂亮
but let's just hit f5, and who knows, maybe this will just be beautiful

470
00:27:34,750 --> 00:27:36,833
好了，这里我们得到了一个很好的OpenGL错误
okay, so we get nice little OpenGL error here

471
00:27:36,833 --> 00:27:39,400
如果我们看看实际的控制台，我们可以看到它是1280
if we look at the actual console, we can see it's 1280

472
00:27:39,466 --> 00:27:41,100
这是因为它不是GL_CLAMP
this is because this is not GL_CLAMP

473
00:27:41,100 --> 00:27:44,500
在更现代的版本中，它应该是GL_CLAMP_TO_EDGE
it's supposed to be GL_CLAMP_TO_EDGE, in more modern versions

474
00:27:44,500 --> 00:27:46,966
所以我们把这个设为GL_CLAMP_TO_EDGE
so we'll just set this to be GL_CLAMP_TO_EDGE

475
00:27:47,566 --> 00:27:49,500
现在，我在调试的时候注意到的另一件事
now, one other thing that I noticed when I was debugging

476
00:27:49,500 --> 00:27:51,733
这也是LocalBuffer实际上是null
this as well is the LocalBuffer was actually null

477
00:27:51,733 --> 00:27:53,966
也就是说我们加载的不是错误的
which means we're not loading this incorrectly

478
00:27:54,166 --> 00:27:58,366
那么我来刷新一下，看看我们实际的纹理发生了什么
so let me just refresh this, and figure out what's going on with our actual texture

479
00:27:58,400 --> 00:28:01,133
那么我来刷新一下这个
so if I so if I just refresh this

480
00:28:01,566 --> 00:28:05,133
因为某些原因，这里看起来并没有纹理
it doesn't look like we've actually got the textures in here for some reason

481
00:28:05,200 --> 00:28:08,566
当然，这是因为这个res文件夹不在我的项目目录中
and that's of course because this res folder wasn't inside my project directory

482
00:28:08,566 --> 00:28:10,833
确保将其放入项目目录中
make sure you put it into your project directory

483
00:28:11,100 --> 00:28:15,766
如果我点击刷新按钮，你们会看到这里有纹理等等
now if I hit this refresh button, you'll see we have textures in here and all of that

484
00:28:15,766 --> 00:28:19,266
所以这样效果会更好，现在按f5，取两个，好了
so this should work better, now let's hit f5, take two, alright

485
00:28:19,266 --> 00:28:20,900
很美，那么我们来看看TheChernoLogo
beautiful, so we see TheChernoLogo

486
00:28:20,900 --> 00:28:25,766
现在看起来就像垃圾，为什么我的标志看起来像垃圾
now it looks like absolute trash, why does my logo look like trash

487
00:28:26,066 --> 00:28:29,566
我不知道我该不该留一个悬念来结束这一切
well I don't know if I should end this on a cliffhanging

488
00:28:29,566 --> 00:28:32,200
或者我是否应该完成这个
or if I should actually finish this

489
00:28:32,733 --> 00:28:38,766
我明显知道它为什么没运行，但这可能没问题
I know why it's not working obviously, but this could be fine

490
00:28:38,766 --> 00:28:40,833
你们知道吗，我通常会留个悬念
you know what, I usually would leave this on a cliffhanger

491
00:28:40,833 --> 00:28:44,800
但这一期实在是太美了，我想我们还是把它搞完吧
but this is just such a beautifully long episode that I think we might as well finish it

492
00:28:44,900 --> 00:28:46,733
这是因为我没有启用混合
it's because I don't have blending enabled

493
00:28:46,733 --> 00:28:50,633
当然，正如你们所看到的，ChernoLogo确实有透明的区域
and of course as you saw that ChernoLogo did have areas of transparency

494
00:28:50,633 --> 00:28:54,333
那么现在没有透明渲染，没有混合
so there's no transparency being rendered right now, it's not blending at all

495
00:28:55,166 --> 00:28:57,533
那就是为什么要解决这个问题会显得很奇怪
that's why it's coming out weird to fix that

496
00:28:57,533 --> 00:29:00,366
我们只需要设置我们的混合函数，并启用混合
we just need to set up our blending function and enable blending

497
00:29:00,633 --> 00:29:05,666
以后会有一期关于混合和透明的，我保证
there will be an episode on blending and transparency in the future, 100% guarantee that

498
00:29:05,933 --> 00:29:07,766
让我们暂时把这事做好吧
let's just make this work now for the time being

499
00:29:07,766 --> 00:29:11,466
那么如果我关闭这个，回到我的Application文件
so if I close this, and I go back into my Application

500
00:29:11,666 --> 00:29:13,133
或者是我的Renderer
or in fact into my Renderer I think

501
00:29:13,133 --> 00:29:15,625
我是否在Renderer中进行了OpenGL设置
did I do kind of OpenGL setup stuff in the Renderer

502
00:29:15,625 --> 00:29:17,133
我想我没有，不，我没有
I don't think I did, no, I didn't

503
00:29:17,266 --> 00:29:19,933
好了，我们现在在Application文件中做这个
okay, so we'll do this in the Application file for now

504
00:29:20,300 --> 00:29:23,600
我要做的是滚动到这里
what I'm going to do is scroll up here

505
00:29:23,733 --> 00:29:27,300
一旦我有了OpenGL上下文，它是OpenGL和初始化的一部分
once I have my OpenGL context, it's kind of part of the OpenGL and initialization

506
00:29:27,300 --> 00:29:33,000
我想我会设置glBlendFunc，所以我要设置一个BlendFunc
I guess I'm going to set up glBlendFunc, so I'm going to set a BlendFunc

507
00:29:33,000 --> 00:29:37,466
并且这个是GL_SRC_ALPHA，而不是SRC_ZERO_ALPHA
and this is going to be GL_SRC_ALPHA, not SRC_ZERO_ALPHA

508
00:29:37,466 --> 00:29:40,966
就是GL_SRC_ALPHA和GL_ONE_MINUS_SRC_ALPHA
GL_SRC_ALPHA and GL_ONE_MINUS_SRC_ALPHA

509
00:29:40,966 --> 00:29:43,300
所以我们现在这儿做的就是我们基本上定义了
so what we're doing here is is we're basically defining

510
00:29:43,400 --> 00:29:47,833
OpenGL如何混合alpha像素，对吧
how OpenGL is going to blend alpha pixels, right

511
00:29:48,600 --> 00:29:51,766
所以这真的需要单独的一期
so this really does require its own episode

512
00:29:51,966 --> 00:29:55,600
但本质上，我们说的是对于src，就是取src的alpha
but essentially, we're saying that for the src, take the src alpha

513
00:29:55,666 --> 00:29:58,533
当你们在上面渲染的时候
and when you're trying to render something on top of that

514
00:29:58,866 --> 00:30:03,966
取1，这个src的alpha会得到它的差值
take 1, that src alpha which will basically get the difference of that

515
00:30:05,000 --> 00:30:06,100
所以它真的只是
so it's just really just

516
00:30:06,100 --> 00:30:10,500
它只是一个数学等式，像字面上的1
it really is just a mathematical equation, equation like literally 1

517
00:30:10,500 --> 00:30:14,633
src的alpha值就是最后的dest值
the src alpha is what the dest out for is going to end up being

518
00:30:14,666 --> 00:30:16,166
以后还有一期关于那个的
and get an episode on that in the future

519
00:30:16,166 --> 00:30:19,233
最后，我们还需要启用混合
and then finally, we do need to also enable blending

520
00:30:19,400 --> 00:30:22,233
通过调用glEnable，然后就是GL_BLEND
by calling glEnable and then GL_BLEND

521
00:30:22,475 --> 00:30:24,666
好了，你们可以按任意顺序来做，这并不重要
okay, and you can do this in any order, doesn't really matter

522
00:30:24,666 --> 00:30:27,066
我喜欢这样做，只是因为我们启用了混合
I kind of like doing it in this order, just because we enable blending

523
00:30:27,066 --> 00:30:28,700
然后我们设置混合函数
and then we kind of set up the blend function

524
00:30:28,700 --> 00:30:31,833
让我们按f5运行一下，我们应该会看到一个美丽的ChernoLogo
let's hit f5, and we should see a beautiful ChernoLogo

525
00:30:32,566 --> 00:30:35,533
你们可以看到，好了，当然它现在看起来有点拉伸
and you can see, there we go, now of course it does look a bit stretched

526
00:30:35,533 --> 00:30:37,600
因为我们渲染的矩形不是方形的
because the rectangle that we're rendering is not square

527
00:30:37,666 --> 00:30:39,666
因为我们的窗口不是方形的
because our window is not square

528
00:30:39,766 --> 00:30:41,633
这是基于窗口位置的
and this is kind of based on window positions

529
00:30:41,633 --> 00:30:42,833
但如果你们能克服这一点
but if you can kind of get over that

530
00:30:42,833 --> 00:30:45,500
你们就可以看到我们有一个漂亮的ChernoLogo渲染图
you can see that we have a beautiful ChernoLogo rendering

531
00:30:45,733 --> 00:30:48,466
那就是我们在OpenGL中使用纹理的方式
and that is how we use textures in OpenGL

532
00:30:48,933 --> 00:30:51,700
如果你们有想要得到回答任何关于纹理的问题
if you have any questions about textures that you want answered

533
00:30:51,700 --> 00:30:53,200
请在下方留言
leave a comment below

534
00:30:53,333 --> 00:30:56,933
因为我以后会做很多和纹理相关的视频
because I am going to make a lot of related videos to textures in the future

535
00:30:56,933 --> 00:31:00,233
纹理是一个非常重要的图形编程
textures are a really big deal graphics programming and all of that

536
00:31:00,600 --> 00:31:03,733
很明显，我们以后会讲到更多
obviously so we are going to talk a lot more about them in the future

537
00:31:04,000 --> 00:31:05,600
除此之外，我希望你们喜欢这个视频
other than that, I hope you guys enjoyed this video

538
00:31:05,600 --> 00:31:07,550
如果你们喜欢的话，可以点击那个喜欢按钮
if you did, you can hit that like button

539
00:31:07,550 --> 00:31:11,433
请在下面的评论区告诉我你们的想法
and let me know what your thoughts are about all this stuff in the comment section below

540
00:31:11,725 --> 00:31:14,950
和往常一样，非常感谢所有的赞助人
as always, huge thank you to all the patron supporters that

541
00:31:14,950 --> 00:31:17,266
让我为你们所有人制作这样的视频
let me make videos like this for all of you

542
00:31:18,233 --> 00:31:21,266
如果你们想支持这个系列，看更多的视频，提前获得视频
if you want to support this series and see more episodes and get videos early

543
00:31:21,266 --> 00:31:22,833
可以访问patreon.com/TheCherno
patreon.com/TheCherno

544
00:31:23,133 --> 00:31:25,633
下次见，拜
and I will see you guys next time, goodbye

